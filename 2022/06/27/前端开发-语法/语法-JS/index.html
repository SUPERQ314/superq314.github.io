<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>语法——JS | superQ的个人小站</title><meta name="keywords" content="JS"><meta name="author" content="superQ,220202090@seu.edu.cn"><meta name="copyright" content="superQ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JS说说js中的词法作用域js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如： var value &#x3D; 1; function foo() &amp;#123;    console.log(value);&amp;#125; function bar() &amp;#123;    var value &#x3D; 2;    foo();&amp;#125; bar();&lt;br&gt;&#x2F;&#x2F;1  注意： with和">
<meta property="og:type" content="article">
<meta property="og:title" content="语法——JS">
<meta property="og:url" content="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/index.html">
<meta property="og:site_name" content="superQ的个人小站">
<meta property="og:description" content="JS说说js中的词法作用域js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如： var value &#x3D; 1; function foo() &amp;#123;    console.log(value);&amp;#125; function bar() &amp;#123;    var value &#x3D; 2;    foo();&amp;#125; bar();&lt;br&gt;&#x2F;&#x2F;1  注意： with和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-06-27T13:28:26.092Z">
<meta property="article:modified_time" content="2022-06-27T16:42:58.127Z">
<meta property="article:author" content="superQ">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '语法——JS',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-06-28 00:42:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3332915_ymmoy7wnkg.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="superQ的个人小站" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/11/qDzgSLuwBd48iJG.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴刻度</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类目</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 回忆</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fa fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-game"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/HTML/index.html"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> butterfly主题</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">superQ的个人小站</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴刻度</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类目</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 回忆</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fa fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-game"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/HTML/index.html"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> butterfly主题</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">语法——JS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-27T13:28:26.092Z" title="发表于 2022-06-27 21:28:26">2022-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-27T16:42:58.127Z" title="更新于 2022-06-28 00:42:58">2022-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/">前端开发-语法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="语法——JS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="说说js中的词法作用域"><a href="#说说js中的词法作用域" class="headerlink" title="说说js中的词法作用域"></a>说说js中的词法作用域</h2><p>js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"> </span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bar();&lt;br&gt;//1</span><br></pre></td></tr></table></figure>

<p>注意： with和eval可以修改词法作用域</p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>《深入浅出nodejs》中对闭包的定义：</p>
<blockquote>
<p>在js中，实现外部作用域访问内部作用域中变量的方法叫做“闭包”。</p>
</blockquote>
<h2 id="说说js的垃圾回收-GC"><a href="#说说js的垃圾回收-GC" class="headerlink" title="说说js的垃圾回收(GC)"></a>说说js的垃圾回收(GC)</h2><p>v8的垃圾回收策略主要基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。</p>
<h3 id="新生代采用Scavenge算法"><a href="#新生代采用Scavenge算法" class="headerlink" title="新生代采用Scavenge算法"></a>新生代采用Scavenge算法</h3><p>Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色对换(又称反转)。</p>
<p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p>
<h3 id="老生代采用Mark-Sweep-和-Mark-Compact"><a href="#老生代采用Mark-Sweep-和-Mark-Compact" class="headerlink" title="老生代采用Mark-Sweep 和 Mark-Compact"></a>老生代采用Mark-Sweep 和 Mark-Compact</h3><p>老生代中对象存活时间较长，不适合Scavenge算法。</p>
<p>Mark-Sweep是标记清除的意思。Scavenge是只复制存活对象，而Mark-Sweep是只清除死亡对象。该算法分为两个步骤：</p>
<ol>
<li>遍历堆中所有对象并标记活着的对象</li>
<li>清除没有标记的对象</li>
</ol>
<p>Mark-Sweep存在一个问题，清除死亡对象后会造成内存空间不连续，如果这时候再分配一个大对象，所有的空间碎片都无法完成此次分配，就会造成提前触发gc。这时候v8会使用Mark-Compact算法。</p>
<p>Mark-Copact是标记整理的意思。它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。因为存在整理过程，所以它的速度慢于Mark-Sweep，node中主要采用Mark-Sweep。</p>
<h3 id="Incremental-Marking"><a href="#Incremental-Marking" class="headerlink" title="Incremental Marking"></a>Incremental Marking</h3><p>为了避免出现Javascript应用逻辑与垃圾回收器看到的情况不一致，垃圾回收时应用逻辑会停下来。这种行为被成为全停顿(stop-the-world)。这对老生代影响较大。</p>
<p>Incremental Marking称为增量标记，也就是拆分为许多小的“步进”，每次做完一“步进”，就让Javascript执行一会儿，垃圾回收与应用逻辑交替执行。</p>
<p>采用Incremental Marking后，gc的最大停顿时间较少到原来的 1 &#x2F; 6 左右。</p>
<h2 id="说说你了解的设计模式"><a href="#说说你了解的设计模式" class="headerlink" title="说说你了解的设计模式"></a>说说你了解的设计模式</h2><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>在js中事件模型就相当于传统的发布订阅模式，具体实现参考<a href="#3-2" title="#3-2">实现一个node中的EventEmiter</a></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义： 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<h5 id="策略模式实现表单校验"><a href="#策略模式实现表单校验" class="headerlink" title="策略模式实现表单校验"></a>策略模式实现表单校验</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const strategies = &#123;</span><br><span class="line">    isNoEmpty: function(value, errorMsg)&#123;</span><br><span class="line">        if(value.trim() === &#x27;&#x27;)&#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    maxLength: function(value, errorMsg, len) &#123;</span><br><span class="line">        if(value.trim() &gt; len) &#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Validator &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.catch = [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(value, rule, errorMsg, ...others) &#123;</span><br><span class="line">    this.catch.push(function() &#123;</span><br><span class="line">      return strategies[rule].apply(this, [value, errorMsg, ...others]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    for (let i = 0, validatorFunc; (validatorFunc = this.catch[i++]); ) &#123;</span><br><span class="line">      let msg = validatorFunc();</span><br><span class="line">      if (msg) &#123;</span><br><span class="line">        return msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">const validatorFunc = function() &#123;</span><br><span class="line">    const validator = new Validator();</span><br><span class="line">    validator.add(username, &#x27;isNoEmpty&#x27;, &#x27;用户名不能为空&#x27;);</span><br><span class="line">    validator.add(password, &#x27;isNoEmpty&#x27;, &#x27;密码不能为空&#x27;);</span><br><span class="line">    const USERNAME_LEN = PASSWORD_LEN = 10;</span><br><span class="line">    validator.add(username, &#x27;maxLength&#x27;, `用户名不能超过$&#123;USERNAME_LEN&#125;个字`, USERNAME_LEN);</span><br><span class="line">    validator.add(password, &#x27;isNoEmpty&#x27;, `密码不能为空$&#123;PASSWORD_LEN&#125;个字`, PASSWORD_LEN);</span><br><span class="line">    let msg = validator.start();</span><br><span class="line">    if(msg) &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>应用场景： 有时候我们要向某些对象发送请求，但不知道请求的接收者是谁，也不知道请求的操作是什么，此时希望以一种松耦合的方式来设计软件，使得请求的发送者和接收者能够消除彼此的耦合关系。</p>
<h5 id="命令模式实现动画"><a href="#命令模式实现动画" class="headerlink" title="命令模式实现动画"></a>命令模式实现动画</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MoveCommand &#123;</span><br><span class="line">  constructor(reciever, pos) &#123;</span><br><span class="line">    this.reciever = reciever;</span><br><span class="line">    this.pos = pos;</span><br><span class="line">    this.oldPos = null;</span><br><span class="line">  &#125;</span><br><span class="line">  excute() &#123;</span><br><span class="line">    this.reciever.start(&quot;left&quot;, this.pos, 1000);</span><br><span class="line">    this.reciever.getPos();</span><br><span class="line">  &#125;</span><br><span class="line">  undo() &#123;</span><br><span class="line">    this.reciever.start(&quot;left&quot;, this.oldPos, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？"><a href="#简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？" class="headerlink" title="简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？"></a>简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？</h2><p>在 JavaScript 中利用<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903843197616136#heading-3" title="https://juejin.cn/post/6844903843197616136#heading-3">事件循环机制</a>（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如</p>
<ul>
<li>Node.js 中的 Callback、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/events.html%23events_class_eventemitter" title="http://nodejs.cn/api/events.html#events_class_eventemitter">EventEmitter</a>、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/stream.html" title="http://nodejs.cn/api/stream.html">Stream</a></li>
<li>ES6 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise" title="https://es6.ruanyifeng.com/#docs/promise">Promise</a>、<a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/generator-async" title="https://es6.ruanyifeng.com/#docs/generator-async">Generator</a></li>
<li>ES2017 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/async" title="https://es6.ruanyifeng.com/#docs/async">Async</a></li>
<li>三方库 RxJS、<a href="https://link.juejin.cn/?target=https://github.com/kriskowal/q" title="https://github.com/kriskowal/q">Q</a> 、<a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co、</a><a href="https://link.juejin.cn/?target=https://github.com/petkaantonov/bluebird" title="https://github.com/petkaantonov/bluebird">Bluebird</a></li>
</ul>
<p>我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。</p>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a><strong>Callback</strong></h3><p>Callback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IObj</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">deferExec</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">deferExecAnonymous</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">console</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">IObj</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExecBind</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用箭头函数可达到一样的效果</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">console</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">deferExecBind</span>(); <span class="comment">// hello</span></span><br><span class="line">obj.<span class="title function_">deferExec</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>回调函数经常会因为调用环境的变化而导致 <code>this</code> 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileC, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">      fs.<span class="title function_">readFile</span>(fileD, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC</span></span><br><span class="line">        <span class="comment">// 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求）</span></span><br><span class="line">        <span class="comment">// 这些异步任务之间纵向嵌套强耦合，无法进行横向复用</span></span><br><span class="line">        <span class="comment">// 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置）</span></span><br><span class="line">        <span class="comment">// 因此称这种现象为 回调地狱</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数不能通过 <code>return</code> 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希望延迟 3s 后执行并拿到结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResult</span>(<span class="params">result: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">3</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管这是常规的编程思维方式</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getAsyncResult</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 但是打印 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResultWithCb</span>(<span class="params">result: <span class="built_in">number</span>, cb: (result: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(result * <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调的形式获取结果</span></span><br><span class="line"><span class="title function_">getAsyncResultWithCb</span>(<span class="number">3000</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result); <span class="comment">// 9000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 <code>try...catch...</code> 的方式进行错误捕获：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下述是异常代码</span></span><br><span class="line">    <span class="comment">// 你可以在回调函数的内部进行 try...catch...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// 这里不会执行</span></span><br><span class="line">  <span class="comment">// 进程会被终止</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为 <strong>执行反转</strong> （回调函数的执行权在三方库中）导致以下一些问题：</p>
<ul>
<li>使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误</li>
<li>使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中</li>
<li>使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求</li>
<li>…</li>
</ul>
<p>举个简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILib</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">params</span>: T;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">params</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">callback</span>: <span class="function">(<span class="params">params: T</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下是一个三方库，并发布成了npm 包</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">lib</span>: <span class="title class_">ILib</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">params</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">params</span> = params;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// callback 回调执行权在 lib 上</span></span><br><span class="line">      <span class="comment">// lib 库可以决定回调执行多次</span></span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="comment">// lib 库甚至可以决定回调延迟执行</span></span><br><span class="line">      <span class="comment">// 异步执行回调函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 假设 lib 库的捕获没有抛出任何异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发者引入 lib 库开始使用</span></span><br><span class="line">lib.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用者希望 on 里的回调只执行一次</span></span><br><span class="line">	<span class="comment">// 这里的回调函数的执行时机是由三方库 lib 决定</span></span><br><span class="line">  <span class="comment">// 实际上打印四次，并且其中一次是异步执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下述是异常代码</span></span><br><span class="line">  <span class="comment">// 但是执行下述代码不会抛出任何异常信息</span></span><br><span class="line">  <span class="comment">// 开发者无法感知自己的代码设计错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><strong>Promise</strong></h3><p>Callback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于<a href="https://link.juejin.cn/?target=https://promisesaplus.com/" title="https://promisesaplus.com/"> Promise A +</a> 规范的异步编程解决方案）利用<a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html" title="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">有限状态机</a>的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：</p>
<ul>
<li>Promise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： <code>pending</code>（进行中）、 <code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果</li>
<li>Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 <code>pending</code>（进行中）变为 <code>fulfilled</code>（已成功）或从 <code>pending</code>（进行中）变为 <code>rejected</code>（已失败）</li>
</ul>
<blockquote>
<p>温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。</p>
</blockquote>
<p>Promise 对象的执行状态不可变示例如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 状态变更为 fulfilled 并返回结果 1 后不会再变更状态</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 不会变更状态</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务）</span></span><br><span class="line">    <span class="comment">// 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;error: &#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 <code>setTimeout</code> 来指代异步请求）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doubble</span> = (<span class="params">result: <span class="built_in">number</span>, callback: (finallResult: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Mock 第一个异步请求</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果）</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(result * <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doubble</span>(<span class="number">1000</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。</p>
</blockquote>
<p>如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="comment">// 将 resolve 改成 reject 会被 catch 捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="comment">// 将 resolve 改成 reject 会被 catch 捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">nextPromise</span>(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s 后打印 2000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 任何一个 Promise 到达 rejected 状态都能被 catch 捕获</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 的错误回调可以同时捕获 <code>firstPromise</code> 和 <code>nextPromise</code> 两个函数的 <code>rejected</code> 状态。接下来考虑以下调用场景：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">nextPromise</span>(result).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 后打印</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise result: &#x27;</span>, result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先打印</span></span><br><span class="line">    <span class="comment">// 由于上一个 then 没有返回值，这里打印 undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstPromise result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>首先 Promise 可以注册多个 <code>then</code>（放在一个执行队列里），并且这些 <code>then</code> 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 <code>then</code> 执行互不干扰。 我们将示例进行简单的变换：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回了 nextPromise 的 then 执行后的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">nextPromise</span>(result).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 接着 nextPromise 的 then 执行的返回结果继续执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s 后打印 2000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述例子中的执行结果是因为 <code>then</code> 的执行会返回一个新的 Promise 对象，并且如果 <code>then</code> 执行后返回的仍然是 Promise 对象，那么下一个 <code>then</code> 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下述是异常代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 继续执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括</p>
<ul>
<li><code>Promise.all</code>：适合多个异步任务并发执行但不允许其中任何一个任务失败</li>
<li><code>Promise.race</code> ：适合多个异步任务抢占式执行</li>
<li><code>Promise.allSettled</code> ：适合多个异步任务并发执行但允许某些任务失败</li>
</ul>
<p>Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：</p>
<ul>
<li>无法取消 Promise 的执行</li>
<li>无法在 Promise 外部通过 <code>try...catch...</code> 的形式进行错误捕获（Promise 内部捕获了错误）</li>
<li>状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用</li>
</ul>
<blockquote>
<p>温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。</p>
</blockquote>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><strong>Generator</strong></h3><p>Promise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Generator 函数里执行的异步代码看起来和同步代码一致</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(result)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line">	<span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行 Generator 函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：</p>
<ul>
<li>丰富了状态类型，Generator 通过 <code>next</code> 可以产生不同的状态信息，也可以通过 <code>return</code> 结束函数的执行状态，相对于 Promise 的 <code>resolve</code> 不可变状态更加丰富</li>
<li>Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护</li>
<li>Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度</li>
</ul>
<p><code>next</code> 可以不停的改变状态使得 <code>yield</code> 得以继续执行的代码可以变得非常有规律，例如从上述的<strong>手动执行 Generator 函数</strong>可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> =  <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 自动执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen: () =&gt; Gen</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = g.<span class="title function_">next</span>(data)</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过递归的方式处理相同的逻辑</span></span><br><span class="line">      <span class="title function_">next</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一次调用 next 主要用于启动 Generator 函数</span></span><br><span class="line">  <span class="comment">// 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式</span></span><br><span class="line">  <span class="comment">// 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错）</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(gen)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：<a href="https://link.juejin.cn/?target=https://github.com/tj" title="https://github.com/tj">TJ Holowaychuk </a>设计了一个 Generator 自动执行器 <a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co</a>，使用 Co 的前提是 <code>yield</code>  命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的<a href="https://link.juejin.cn/?target=https://github.com/tj/co%23arrays" title="https://github.com/tj/co#arrays"> API 文档</a>。</p>
</blockquote>
<p>需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用 next 是继发执行，而这里是并发执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="title function_">gen</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> <span class="title function_">gen</span>()) &#123;</span><br><span class="line">  promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 需要注意这里的reject 没有被捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Generator 函数错误捕获: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获</span></span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// Generator 函数错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  <span class="comment">// 执行器错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;执行错误捕获: &#x27;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>g.throw</code> 的时候还需要注意以下一些事项：</p>
<ul>
<li>如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获</li>
<li>如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息</li>
<li>如果没有执行过 <code>g.next</code>，则 <code>g.throw</code> 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获</li>
</ul>
<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a><strong>Async</strong></h3><p>Async 是 Generator 函数的语法糖，相对于 Generator 而言 Async 的特性如下：</p>
<ul>
<li>内置执行器：Generator 函数需要设计手动执行器或者通用执行器（例如 Co 执行器）进行执行，Async 语法则内置了自动执行器，设计代码时无须关心执行步骤</li>
<li><code>yield</code> 命令无约束：在 Generator 中使用 Co 执行器时 <code>yield</code> 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 <code>await</code> 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 <code>Promise.resolve()</code> 包装处理）</li>
<li>返回 Promise： <code>async</code> 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 <code>await</code>  的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用</li>
</ul>
<p>举个简单的示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 1s 后打印 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult); </span><br><span class="line">  <span class="comment">// 等待 firstPromise 的状态发生变化后执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(firstResult);</span><br><span class="line">  <span class="comment">// 2s 后打印 6</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult); </span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 6</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过上述示例可以看出，<code>async</code> 函数的特性如下：</p>
<ul>
<li>调用 <code>async</code> 函数后返回的是一个 Promise 对象，通过 <code>then</code> 回调可以拿到 async 函数内部 <code>return</code> 语句的返回值</li>
<li>调用 <code>async</code> 函数后返回的 Promise 对象必须等待内部所有 <code>await</code> 对应的 Promise 执行完（这使得 <code>async</code> 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 <code>return</code> 语句</li>
<li><code>await</code> 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型</li>
</ul>
<p>上述代码是阻塞式执行，<code>nextPromise</code> 需要等待 <code>firstPromise</code> 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">firstPromise</span>(<span class="number">1</span>), <span class="title function_">nextPromise</span>(<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// [2,3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">10000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 firstPromise</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 和 firstPromise 同时执行 nextPromise</span></span><br><span class="line">  <span class="keyword">const</span> next = <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 等待 firstPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> first;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="comment">// 等待 nextPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> next;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>async</code> 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 <code>rejected</code> 状态，从而可以通过 <code>catch</code> 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 <code>firstPromise</code> 错误后可以继续执行 <code>nextPromise</code>，则可以通过 <code>try...catch...</code> 在 <code>async</code> 函数里进行局部错误捕获：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// nextPromise 继续执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// res: 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 <a href="https://link.juejin.cn/?target=https://www.youtube.com/watch?v=1gIiZfSbEAE" title="https://www.youtube.com/watch?v=1gIiZfSbEAE">Deno is a New Way to JavaScript</a>。</p>
</blockquote>
<p>作者：子弈<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6987549240436195364">https://juejin.cn/post/6987549240436195364</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/SUPERQ314">superQ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/">https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SUPERQ314.github.io" target="_blank">superQ的个人小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-CSS/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端开发——CSS</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src="https://s2.loli.net/2022/04/11/g4WaDYOXqtUNRhQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">语法-Html面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/04/11/qDzgSLuwBd48iJG.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">superQ</div><div class="author-info__description">学技术 提升自己</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SUPERQ314"><i class="fab fa-github"></i><span>Follow Me！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SUPERQ314" target="_blank" title="fa fa-github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1078857679@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1078857679" target="_blank" title="iconfont icon-QQ"><i class="fas fa-qq"></i></a><a class="social-icon" href="https://www.zhihu.com/people/qin-chao-10-90" target="_blank" title="iconfont icon-zhihu"><i class="fas fa-zhihu"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">superQ的个人小站！一只学习前端开发的菜鸟甜甜圈~</div></div><div class="card-widget card-widget 所寫的 class_name" id="所寫的 id_name"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JS"><span class="toc-number">1.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">说说js中的词法作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">1.2.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-GC"><span class="toc-number">1.3.</span> <span class="toc-text">说说js的垃圾回收(GC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E9%87%87%E7%94%A8Scavenge%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">新生代采用Scavenge算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3%E9%87%87%E7%94%A8Mark-Sweep-%E5%92%8C-Mark-Compact"><span class="toc-number">1.3.2.</span> <span class="toc-text">老生代采用Mark-Sweep 和 Mark-Compact</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Incremental-Marking"><span class="toc-number">1.3.3.</span> <span class="toc-text">Incremental Marking</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">说说你了解的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">发布订阅模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.4.2.0.1.</span> <span class="toc-text">策略模式实现表单校验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB"><span class="toc-number">1.4.3.0.1.</span> <span class="toc-text">命令模式实现动画</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94%E4%B8%80%E4%B8%8B-Callback%E3%80%81Promise%E3%80%81Generator%E3%80%81Async-%E5%87%A0%E4%B8%AA%E5%BC%82%E6%AD%A5-API-%E7%9A%84%E4%BC%98%E5%8A%A3%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Callback"><span class="toc-number">1.5.1.</span> <span class="toc-text">Callback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">1.5.2.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator"><span class="toc-number">1.5.3.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async"><span class="toc-number">1.5.4.</span> <span class="toc-text">Async</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/webpack/webpack%E4%B8%AD%E7%9A%84HMR%E5%8E%9F%E7%90%86/" title="Webpack中的HMR原理"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack中的HMR原理"/></a><div class="content"><a class="title" href="/2022/06/30/webpack/webpack%E4%B8%AD%E7%9A%84HMR%E5%8E%9F%E7%90%86/" title="Webpack中的HMR原理">Webpack中的HMR原理</a><time datetime="2022-06-30T14:04:13.293Z" title="发表于 2022-06-30 22:04:13">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/webpack/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8/" title="webpack性能优化总结大全"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack性能优化总结大全"/></a><div class="content"><a class="title" href="/2022/06/30/webpack/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8/" title="webpack性能优化总结大全">webpack性能优化总结大全</a><time datetime="2022-06-30T14:04:10.806Z" title="发表于 2022-06-30 22:04:10">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/webpack/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/" title="构建工具选择"><img src="https://s2.loli.net/2022/04/11/g4WaDYOXqtUNRhQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="构建工具选择"/></a><div class="content"><a class="title" href="/2022/06/30/webpack/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/" title="构建工具选择">构建工具选择</a><time datetime="2022-06-30T07:18:10.319Z" title="发表于 2022-06-30 15:18:10">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/webpack/webpack_plugin/" title="webpack plugin"><img src="https://tva1.sinaimg.cn/large/832afe33ly1gbhxplql40j22801e0q3c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack plugin"/></a><div class="content"><a class="title" href="/2022/06/30/webpack/webpack_plugin/" title="webpack plugin">webpack plugin</a><time datetime="2022-06-30T07:17:34.496Z" title="发表于 2022-06-30 15:17:34">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/webpack/webpack_loader/" title="webpack loader"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack loader"/></a><div class="content"><a class="title" href="/2022/06/30/webpack/webpack_loader/" title="webpack loader">webpack loader</a><time datetime="2022-06-30T07:17:20.748Z" title="发表于 2022-06-30 15:17:20">2022-06-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022.04 - 2022 By superQ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,  welcome to my <a target="_blank" rel="noopener" href="https://www.antmoe.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'forest' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-listfolded="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>