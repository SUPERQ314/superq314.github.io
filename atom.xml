<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-10-18T02:23:02.576Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue族谱架构</title>
    <link href="https://superq314.github.io/posts/a97a1a46/"/>
    <id>https://superq314.github.io/posts/a97a1a46/</id>
    <published>2022-10-17T09:55:40.000Z</published>
    <updated>2022-10-18T02:23:02.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>静态网站：html 放到服务器，ok了。</p></li><li><p>动态网站: 静态网站 + 动态语言 + 链接数据库</p></li><li><p>Node.js</p><blockquote><p>nodejs中文网: <a href="http://nodejs.cn/">http://nodejs.cn/</a><br>官方介绍：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。</p></blockquote></li><li><p>WebPack</p><blockquote><p>WebPack官网：<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a><br>官方介绍：打包所有的样式 脚本 资源 图片</p></blockquote></li><li><p>@vue&#x2F;cli-service</p><blockquote><p>脚手架</p></blockquote></li><li><p>Babel</p><blockquote><p>Babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a><br>官方介绍：Babel 是一个 JavaScript 编译器。</p></blockquote></li><li><p>Eslint</p><blockquote><p>Eslint官网：<a href="https://eslint.org/">https://eslint.org/</a><br>官方介绍：Find and fix problems in your JavaScript code</p></blockquote></li></ul><p>前台核心基本功</p><ul><li><p>ES6</p><blockquote><p>ES6官网：<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br>官方介绍：《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。</p></blockquote></li><li><p>VUE 2.x</p><blockquote><p>Vue官网：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a><br>官方介绍：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote></li><li><p>vue-router</p><blockquote><p>vue-router官网：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a><br>官方介绍：Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote></li><li><p>vuex</p><blockquote><p>vuex官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a><br>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote></li><li><p>Axios</p><blockquote><p>个人介绍：当年的Ajax，如今的Axios</p></blockquote></li><li><p>LESS</p><blockquote><p>LESS中文官网：<a href="http://lesscss.cn/">http://lesscss.cn/</a><br>官方介绍：Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。</p></blockquote></li><li><p>VIEW-Design</p><blockquote><p>VIEW-Design官网：<a href="https://www.iviewui.com/">https://www.iviewui.com/</a><br>官方介绍：View UI，即原先的 iView，是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。</p></blockquote></li></ul><p>一般常用拓展库</p><ul><li><p>Echarts</p><blockquote><p>Echarts官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a><br>官方介绍：ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p></blockquote></li><li><p>VueTreeSelect</p><blockquote><p>VueTreeSelect官网：<a href="https://vue-treeselect.js.org/">https://vue-treeselect.js.org/</a><br>官方介绍：vue-treeselect is a multi-select component with nested options support for Vue.js.</p></blockquote></li><li><p>print-js</p><blockquote><p>print-js官网：<a href="https://printjs.crabbly.com/">https://printjs.crabbly.com/</a><br>官方介绍：A tiny javascript library to help printing from the web.</p></blockquote></li><li><p>js-cookie</p><blockquote><p>js-cookie官网：<a href="https://github.com/js-cookie/js-cookie">https://github.com/js-cookie/js-cookie</a><br>官方介绍：A simple, lightweight JavaScript API for handling cookies</p></blockquote></li><li><p>lodash</p><blockquote><p>lodash官网：<a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a><br>官方介绍：Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。</p></blockquote></li><li><p>Mockjs</p><blockquote><p>Mockjs官网：<a href="http://mockjs.com/">http://mockjs.com/</a><br>官方介绍：生成随机数据，拦截 Ajax 请求</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>将excel文件转为本地json文件的插件</title>
    <link href="https://superq314.github.io/posts/93bc55ab/"/>
    <id>https://superq314.github.io/posts/93bc55ab/</id>
    <published>2022-10-17T02:56:29.000Z</published>
    <updated>2022-10-17T04:17:55.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>excel-2b-json插件用于将google excel文件转化成本地json文件。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-安装excel-2b-json"><a href="#1-安装excel-2b-json" class="headerlink" title="1. 安装excel-2b-json"></a>1. 安装excel-2b-json</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install excel-2b-json</span><br></pre></td></tr></table></figure><h3 id="2-引入使用"><a href="#2-引入使用" class="headerlink" title="2. 引入使用"></a>2. 引入使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> excelToJson = <span class="built_in">require</span>(<span class="string">&#x27;excel-2b-json&#x27;</span>);</span><br><span class="line"><span class="comment">// path 生成的json文件目录</span></span><br><span class="line"><span class="title function_">excelToJson</span>(<span class="string">&#x27;https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0&#x27;</span>, path)</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-fd3aff58b3f9b44d6160c9f0d4ef4f5f_720w.webp"><br>转化得到<br><img src="https://pic2.zhimg.com/80/v2-ab6e90fb06caec7d652f3a95fbba8fe9_720w.webp"></p><p>下面是插件的实现</p><blockquote><p>源码已放到github：<a href="https://link.zhihu.com/?target=https://github.com/Sunny-lucking/HowToBuildMyExcelTobeJson">https://github.com/Sunny-lucking/HowToBuildMyExcelTobeJson</a></p></blockquote><h2 id="一、涉及的算法"><a href="#一、涉及的算法" class="headerlink" title="一、涉及的算法"></a>一、涉及的算法</h2><h3 id="1-26字母转换成数字，26进制，a为1，aa为27，ab为28"><a href="#1-26字母转换成数字，26进制，a为1，aa为27，ab为28" class="headerlink" title="1. 26字母转换成数字，26进制，a为1，aa为27，ab为28"></a>1. 26字母转换成数字，26进制，a为1，aa为27，ab为28</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">colToInt</span>(<span class="params">col</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> letters = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line">    col = col.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; col.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        n *= <span class="number">26</span></span><br><span class="line">        n += letters.<span class="title function_">indexOf</span>(col[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-生成几行几列的二维空数组"><a href="#2-生成几行几列的二维空数组" class="headerlink" title="2. 生成几行几列的二维空数组"></a>2. 生成几行几列的二维空数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEmpty2DArr</span>(<span class="params">rows, cols</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrs = <span class="keyword">new</span> <span class="title class_">Array</span>(rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        arrs[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(cols).<span class="title function_">fill</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">//每行有cols列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-清除二维数组中空的数组"><a href="#3-清除二维数组中空的数组" class="headerlink" title="3. 清除二维数组中空的数组"></a>3. 清除二维数组中空的数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">转化为</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title function_">clearEmptyArrItem</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">val1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) !== <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-矩阵的翻转"><a href="#4-矩阵的翻转" class="headerlink" title="4. 矩阵的翻转"></a>4. 矩阵的翻转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">转化为</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array*2</span>&#125; matrix 一个二维数组，返回旋转后的二维数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">rotateExcelDate</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix[<span class="number">0</span>]) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">var</span> results = [],</span><br><span class="line">        result = [],</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        lens,</span><br><span class="line">        len</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, lens = matrix[<span class="number">0</span>].<span class="property">length</span>; i &lt; lens; i++) &#123;</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, len = matrix.<span class="property">length</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[j] = matrix[j][i]</span><br><span class="line">        &#125;</span><br><span class="line">        results.<span class="title function_">push</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、插件的实现"><a href="#二、插件的实现" class="headerlink" title="二、插件的实现"></a>二、插件的实现</h2><h3 id="1-下载google-Excel文档到本地"><a href="#1-下载google-Excel文档到本地" class="headerlink" title="1. 下载google Excel文档到本地"></a>1. 下载google Excel文档到本地</h3><p>我们先看看google Excel文档的url的组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/文档ID/edit#哈希值</span></span><br></pre></td></tr></table></figure><p>例如下面这条，你可以尝试打开，下面这条链接是可以打开的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0</span></span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-df4c89880f1bbf9efcce79ab6eb9d3c5_720w.webp"></p><p>下载google文档的步骤非常简单，只要获取原始的链接，然后拼接成下面的url，向这个Url发起请求，然后以流的方式写入生成文件就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/ + &quot;文档ID&quot; + &#x27;/export?format=xlsx&amp;id=&#x27; + id + &#x27;&amp;&#x27; + hash</span></span><br></pre></td></tr></table></figure><p>因此实现下载的方法非常简单，可以直接看代码<br><strong>downLoadExcel.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> rmobj = <span class="built_in">require</span>(<span class="string">&#x27;./remove&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载google excel 文档到本地</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; url  // https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">downLoadExcel</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 记录当前下载文件的目录，方便删除</span></span><br><span class="line">    rmobj.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: __dirname,</span><br><span class="line">        <span class="attr">ext</span>: <span class="string">&#x27;xlsx&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> down1 = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> down2 = down1.<span class="title function_">pop</span>() <span class="comment">// edit#gid=0</span></span><br><span class="line">        <span class="keyword">var</span> url2 = down1.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>) <span class="comment">// https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM</span></span><br><span class="line">        <span class="keyword">var</span> id = down1.<span class="title function_">pop</span>() <span class="comment">// 12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM</span></span><br><span class="line">        <span class="keyword">var</span> hash = down2.<span class="title function_">split</span>(<span class="string">&#x27;#&#x27;</span>).<span class="title function_">pop</span>() <span class="comment">// gid=0</span></span><br><span class="line">        <span class="keyword">var</span> downurl = url2 + <span class="string">&#x27;/export?format=xlsx&amp;id=&#x27;</span> + id + <span class="string">&#x27;&amp;&#x27;</span> + hash  <span class="comment">// https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/export?format=xlsx&amp;id=12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM&amp;gid=0</span></span><br><span class="line">        <span class="keyword">var</span> loadedpath = __dirname + <span class="string">&#x27;/&#x27;</span> + id + <span class="string">&#x27;.xlsx&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> stream = fs.<span class="title function_">createWriteStream</span>(loadedpath)</span><br><span class="line">        <span class="keyword">const</span> req = request.<span class="title function_">get</span>(downurl)</span><br><span class="line">        req.<span class="title function_">pipe</span>(stream).<span class="title function_">on</span>(<span class="string">&#x27;finish&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(loadedpath)</span><br><span class="line">        <span class="comment">// 已经成功下载下来了，接下来将本地excel转化成json的工作就交给Excel对象来完成</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = downLoadExcel</span><br></pre></td></tr></table></figure><p>入口文件可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">excelToJson</span>(<span class="params">excelPathName, outputPath</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Util</span>.<span class="title function_">checkAddress</span>(excelPathName) === <span class="string">&#x27;google&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.判断是谷歌excel文档，需要交给Google对象去处理，主要是下载线上的，生成本地excel文件</span></span><br><span class="line">        <span class="keyword">const</span> filePath = <span class="keyword">await</span> <span class="title function_">downLoadExcel</span>(excelPathName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.解析本地excel成二维数组</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">parseXlsx</span>(filePath)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 3.生成json文件</span></span><br><span class="line">        <span class="title function_">generateJsonFile</span>(data, outputPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = excelToJson</span><br></pre></td></tr></table></figure><p>之所以写if判断，是为了后面扩展，也许就不止是解析google文档了，或许也要解析腾讯等其他文档呢</p><p>第一步已经实现了，接下来就看第二步怎么实现</p><h3 id="2-解析本地excel成二维数组，获取excel的sheet信息和strings信息"><a href="#2-解析本地excel成二维数组，获取excel的sheet信息和strings信息" class="headerlink" title="2. 解析本地excel成二维数组，获取excel的sheet信息和strings信息"></a>2. 解析本地excel成二维数组，获取excel的sheet信息和strings信息</h3><p>excel 文件其实本质上是多份xml文件的压缩文件。</p><blockquote><p>xml是存储数据的，而html是显示数据的</p></blockquote><p>而在这里我们只需要获取两份xml 文件，一份是strings，就是excel里的内容，一份是sheet，概括整个excel文件的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">parseXlsx</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 解析本地excel文件，获取excel的sheet信息和content信息</span></span><br><span class="line">    <span class="keyword">const</span> files = <span class="keyword">await</span> <span class="title function_">extractFiles</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据strings和sheet解析成二维数组</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">extractData</span>(files)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 处理二维数组的内容，</span></span><br><span class="line">    <span class="keyword">const</span> fixData = <span class="title function_">handleData</span>(data)</span><br><span class="line">    <span class="keyword">return</span> fixData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以第一步我们看看怎么获取excel的sheet信息和strings信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractFiles</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="comment">// excel的本质是多份xml组成的压缩文件，这里我们只需要xl/sharedStrings.xml和xl/worksheets/sheet1.xml</span></span><br><span class="line">    <span class="keyword">const</span> files = &#123;</span><br><span class="line">        <span class="attr">strings</span>: &#123;&#125;, <span class="comment">// strings内容</span></span><br><span class="line">        <span class="attr">sheet</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&#x27;xl/sharedStrings.xml&#x27;</span>: <span class="string">&#x27;strings&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xl/worksheets/sheet1.xml&#x27;</span>: <span class="string">&#x27;sheet&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stream = path <span class="keyword">instanceof</span> <span class="title class_">Stream</span> ? path : fs.<span class="title function_">createReadStream</span>(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> filePromises = [] <span class="comment">// 由于一份excel文档，会被解析成好多分xml文档，但是我们只需要两份xml文档，分别是（xl/sharedStrings.xml和xl/worksheets/sheet1.xml），所以用数组接受</span></span><br><span class="line">        stream.<span class="title function_">pipe</span>(unzip.<span class="title class_">Parse</span>())</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, reject)</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(filePromises).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(files)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).<span class="title function_">on</span>(<span class="string">&#x27;entry&#x27;</span>, <span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 每解析某个xml文件都会进来这里，但是我们只需要xl/sharedStrings.xml和xl/worksheets/sheet1.xml，并将内容保存在strings和sheet中</span></span><br><span class="line">            <span class="keyword">const</span> file = files[entry.<span class="property">path</span>]</span><br><span class="line">            <span class="keyword">if</span> (file) &#123;</span><br><span class="line">                <span class="keyword">let</span> contents = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">let</span> chunks = []</span><br><span class="line">                <span class="keyword">let</span> totalLength = <span class="number">0</span></span><br><span class="line">                filePromises.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                    entry.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">                        chunks.<span class="title function_">push</span>(chunk)</span><br><span class="line">                        totalLength += chunk.<span class="property">length</span></span><br><span class="line">                    &#125;).<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        contents = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks, totalLength).<span class="title function_">toString</span>()</span><br><span class="line">                        files[file].<span class="property">contents</span> = contents</span><br><span class="line">                        <span class="keyword">if</span> (<span class="regexp">/�/g</span>.<span class="title function_">test</span>(contents)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;本次转化出现乱码�&#x27;</span>)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="title function_">resolve</span>()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                entry.<span class="title function_">autodrain</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以断点看看entry.path，你就会看到分别进来了好几次，然后我们会分别看到我们想要的那两个文件</p><p><img src="https://pic2.zhimg.com/80/v2-c5a24f7ea29e7b0c3de3de4ecf1a13dd_720w.webp"></p><p>两份xml文件解析之后就会到close方法里了，这时就可以看到strings和sheet都有内容了，而且内容都是xml</p><p><img src="https://pic2.zhimg.com/80/v2-df174239b78c1855b30fd831afa0cb29_720w.webp"></p><p>我们分别看看strings和sheet的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream.<span class="title function_">pipe</span>(unzip.<span class="title class_">Parse</span>())</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, reject)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>(filePromises).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(files.<span class="property">strings</span>.<span class="property">contents</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(files.<span class="property">sheet</span>.<span class="property">contents</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(files)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-f9cf1e973ac326808ef302a15d4e5aa1_720w.webp"></p><p>格式化一下</p><p><strong>strings</strong></p><p><img src="https://pic2.zhimg.com/80/v2-92d46307423131de25104058ed95571d_720w.webp"></p><p><strong>sheet</strong></p><p><img src="https://pic2.zhimg.com/80/v2-aef401e7709cbb2cb8a03279ecfdd3d1_720w.webp"></p><p>可以发现strings的内容非常简单，现在我们借助xmldom将内容解析为节点对象，然后用xpath插件来获取内容</p><p>xpath的用法：<a href="https://link.zhihu.com/?target=https://github.com/goto100/xpath%23readme">https:&#x2F;&#x2F;<strong>github.com&#x2F;goto100&#x2F;xpat</strong>h#readme</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">XMLDOM</span> = <span class="built_in">require</span>(<span class="string">&#x27;xmldom&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> xpath = <span class="built_in">require</span>(<span class="string">&#x27;xpath&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ns = &#123; <span class="attr">a</span>: <span class="string">&#x27;http://schemas.openxmlformats.org/spreadsheetml/2006/main&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> select = xpath.<span class="title function_">useNamespaces</span>(ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> valuesDoc = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(</span><br><span class="line">    files.<span class="property">strings</span>.<span class="property">contents</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有每个格子的内容都放进了values数组里。</span></span><br><span class="line">values = <span class="title function_">select</span>(<span class="string">&#x27;//a:si&#x27;</span>, valuesDoc).<span class="title function_">map</span>(<span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="title function_">select</span>(<span class="string">&#x27;.//a:t&#x27;</span>, string).<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">textContent</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>‘<code>//a:si</code>‘ 是xpath语法，&#x2F;&#x2F;表示选择当前节点下的所有子孙节点，a是<a href="https://link.zhihu.com/?target=http://schemas.openxmlformats.org/spreadsheetml/2006/main">http:&#x2F;&#x2F;<strong>schemas.openxmlformats.org</strong>&#x2F;spreadsheetml&#x2F;2006&#x2F;main</a>的命名空间。所以合起来就是找到当前节点下的所有si节点。<code>.//a:t</code>则是找到当前si节点下的所有t节点。</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-b50f77d4c392f606921c961f1ffffb6d_720w.webp"></p><p>可以看到，xpath的用法很简单，就是找到si节点下的子节点t的内容，然后放进数组里</p><p><img src="https://pic4.zhimg.com/80/v2-c9d54ab8f6d2c33225ed89efbec59287_720w.webp"></p><p>最终生成的values数组是 <code>[ &#39;lang&#39;, &#39;cn&#39;,&#39;en&#39;, &#39;lang001&#39;,&#39;我是阳光&#39;, &#39;i am sunny&#39;,&#39;lang002&#39;, &#39;前端阳光&#39;,&#39;FE Sunny&#39;, &#39;lang003&#39;,&#39;带带我&#39;, &#39;ddw&#39;]</code></p><p>现在我们要获取sheet的内容了，我们先分析一下xml结构</p><p><img src="https://pic4.zhimg.com/80/v2-f33366ece0d6989efb5c94e5930af507_720w.webp"></p><p>可以看到sheetData节点其实就是记录strings的内容的信息的，strings的内容是我们真正输入的，而sheet则是类似一种批注。</p><p>我们分析看看</p><p>row就是表示表格中的行，c则表示的是列，属性t&#x3D;”s”表示的是当前这个格子有内容，r&#x3D;”A1”表示的是在第一行中的A列</p><p><img src="https://pic3.zhimg.com/80/v2-1059e798cded4a9a5c3c207ab98c9232_720w.webp"></p><p>而节点v则表示该格子是该表格的第几个有值的格子，不信？我们可以试试看</p><p><img src="https://pic4.zhimg.com/80/v2-5af242307963fe82dbd0c10b7a0fa45f_720w.webp"></p><p><img src="https://pic2.zhimg.com/80/v2-1ec56afec3a9d20b5b8a1e6e0df09e61_720w.webp"></p><p>可以看到这打印出来的xml内容，strings中已经没有了那两个值，而sheet中的那两个格子的c节点的t属性没了，而且v节点也没有了。</p><p><strong>现在我们可以知道，string只保存有值的格子里的值，而sheet则是一个网格，不管格子有没有值都会记录，有值的会有个序号存在v节点中。</strong></p><p>现在就要收集c节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> na = &#123;</span><br><span class="line">    <span class="attr">textContent</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellCoords</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">cell</span>) &#123;</span><br><span class="line">        cell = cell.<span class="title function_">split</span>(<span class="regexp">/([0-9]+)/</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">row</span> = <span class="built_in">parseInt</span>(cell[<span class="number">1</span>])</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">column</span> = <span class="title function_">colToInt</span>(cell[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">cellNode</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> r = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">       <span class="keyword">const</span> type = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;t&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">       <span class="keyword">const</span> value = (<span class="title function_">select</span>(<span class="string">&#x27;a:v&#x27;</span>, cellNode, <span class="number">1</span>) || na).<span class="property">textContent</span></span><br><span class="line">       <span class="keyword">const</span> coords = <span class="keyword">new</span> <span class="title class_">CellCoords</span>(r)</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">column</span> = coords.<span class="property">column</span> <span class="comment">// 该格子所在列数</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">row</span> = coords.<span class="property">row</span> <span class="comment">// 该格子所在行数</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">value</span> = value <span class="comment">// 该格子的顺序</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">type</span> = type <span class="comment">// 该格子是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cells = <span class="title function_">select</span>(<span class="string">&#x27;/a:worksheet/a:sheetData/a:row/a:c&#x27;</span>, sheet).<span class="title function_">map</span>(</span><br><span class="line">    <span class="function"><span class="params">node</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(node)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>每个c节点用cell对象来表示</p><p>可以看到cell节点有四个属性。</p><p><strong>你现在知道它为什么要保存顺序了吗？</strong></p><p>因为这样才可以直接从strings生成的values数组中拿出对应顺序的值填充到网格中。</p><p>接下来要获取总共有多少列数和行数。这就需要获取最大最小行数列数，然后求差得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDimensions</span>(<span class="params">cells</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">comparator</span> = (<span class="params">a, b</span>) =&gt; a - b</span><br><span class="line">   <span class="keyword">const</span> allRows = cells.<span class="title function_">map</span>(<span class="function"><span class="params">cell</span> =&gt;</span> cell.<span class="property">row</span>).<span class="title function_">sort</span>(comparator)</span><br><span class="line">   <span class="keyword">const</span> allCols = cells.<span class="title function_">map</span>(<span class="function"><span class="params">cell</span> =&gt;</span> cell.<span class="property">column</span>).<span class="title function_">sort</span>(comparator)</span><br><span class="line">   <span class="keyword">const</span> minRow = allRows[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">const</span> maxRow = allRows[allRows.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">   <span class="keyword">const</span> minCol = allCols[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">const</span> maxCol = allCols[allCols.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> [&#123; <span class="attr">row</span>: minRow, <span class="attr">column</span>: minCol &#125;, &#123; <span class="attr">row</span>: maxRow, <span class="attr">column</span>: maxCol &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就根据列数和行数造空二维数组，然后再根据cells和values填充内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成二维空数组</span></span><br><span class="line">data = <span class="title function_">getEmpty2DArr</span>(rows, cols)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充二维空数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cell <span class="keyword">of</span> cells) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = cell.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// s表示该格子有内容</span></span><br><span class="line">    <span class="keyword">if</span> (cell.<span class="property">type</span> == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">        value = values[<span class="built_in">parseInt</span>(value)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充该格子</span></span><br><span class="line">    <span class="keyword">if</span> (data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>]) &#123;</span><br><span class="line">        data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>][cell.<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span>] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>我们看看最终生成的data，可以发现，excel的网格已经被二维数组模拟出来了</p><p><img src="https://pic2.zhimg.com/80/v2-15b4d6409f81c87fa05d62ab9d7e0f91_720w.webp"></p><p>所以我们看看extractData的完整实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractData</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sheet</span><br><span class="line">    <span class="keyword">let</span> values</span><br><span class="line">    <span class="keyword">let</span> data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sheet = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(files.<span class="property">sheet</span>.<span class="property">contents</span>)</span><br><span class="line">        <span class="keyword">const</span> valuesDoc = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(files.<span class="property">strings</span>.<span class="property">contents</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把所有每个格子的内容都放进了values数组里。</span></span><br><span class="line">        values = <span class="title function_">select</span>(<span class="string">&#x27;//a:si&#x27;</span>, valuesDoc).<span class="title function_">map</span>(<span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">            <span class="title function_">select</span>(<span class="string">&#x27;.//a:t&#x27;</span>, string)</span><br><span class="line">            .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">textContent</span>)</span><br><span class="line">            .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (parseError) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> na = &#123;</span><br><span class="line">        <span class="attr">textContent</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CellCoords</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">cell</span>) &#123;</span><br><span class="line">            cell = cell.<span class="title function_">split</span>(<span class="regexp">/([0-9]+)/</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">row</span> = <span class="built_in">parseInt</span>(cell[<span class="number">1</span>])</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">column</span> = <span class="title function_">colToInt</span>(cell[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">cellNode</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> r = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> type = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;t&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> value = (<span class="title function_">select</span>(<span class="string">&#x27;a:v&#x27;</span>, cellNode, <span class="number">1</span>) || na).<span class="property">textContent</span></span><br><span class="line">        <span class="keyword">const</span> coords = <span class="keyword">new</span> <span class="title class_">CellCoords</span>(r)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">column</span> = coords.<span class="property">column</span> <span class="comment">// 该格子所在列数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">row</span> = coords.<span class="property">row</span> <span class="comment">// 该格子所在行数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value <span class="comment">// 该格子的顺序</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = type <span class="comment">// 该格子是否为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cells = <span class="title function_">select</span>(<span class="string">&#x27;/a:worksheet/a:sheetData/a:row/a:c&#x27;</span>, sheet).<span class="title function_">map</span>(</span><br><span class="line">        <span class="function"><span class="params">node</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(node)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">    d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成二维空数组</span></span><br><span class="line">    data = <span class="title function_">getEmpty2DArr</span>(rows, cols)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充二维空数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> cell <span class="keyword">of</span> cells) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = cell.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s表示该格子有内容</span></span><br><span class="line">        <span class="keyword">if</span> (cell.<span class="property">type</span> == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">        value = values[<span class="built_in">parseInt</span>(value)]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充该格子</span></span><br><span class="line">        <span class="keyword">if</span> (data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>]) &#123;</span><br><span class="line">        data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>][cell.<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span>] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要去除空行和空列，并将二维数组翻转成我们需要的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        data = <span class="title function_">clearEmptyArrItem</span>(data)</span><br><span class="line">        data = <span class="title function_">rotateExcelDate</span>(data)</span><br><span class="line">        data = <span class="title function_">clearEmptyArrItem</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-58f5ce9df016541ef038537c7c2003b2_720w.webp"></p><p>可以看到，现在数组的第一项子数组则是key列表了。</p><p>接下来就可以根据key来生成对应的json文件了。</p><h3 id="3-生成json数据"><a href="#3-生成json数据" class="headerlink" title="3. 生成json数据"></a>3. 生成json数据</h3><p>这一步非常简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateJsonFile</span>(<span class="params">excelDatas, outputPath</span>) &#123;</span><br><span class="line">    <span class="comment">// 获得转化成json格式</span></span><br><span class="line">    <span class="keyword">const</span> jsons = <span class="title function_">convertProcess</span>(excelDatas)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成写入文件</span></span><br><span class="line">    <span class="title function_">writeFile</span>(jsons, outputPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是获取json数据</p><p>先获取data数组的第一项数组，第一项数组是key，然后生成每种语言的json对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array*2</span>&#125; <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> * 返回处理完后的多语言数组，每一项都是一个json对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convertProcess</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys_arr = [],</span><br><span class="line">        data_arr = [],</span><br><span class="line">        result_arr = [],</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        data_arr_len,</span><br><span class="line">        col_data_json,</span><br><span class="line">        col_data_arr,</span><br><span class="line">        data_arr_col_len</span><br><span class="line">    <span class="comment">// 表格合并处理，这是json属性列。</span></span><br><span class="line">    keys_arr = data[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 第一例是json描述，后续是语言包</span></span><br><span class="line">    data_arr = data.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, data_arr_len = data_arr.<span class="property">length</span>; i &lt; data_arr_len; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出第一个列语言包</span></span><br><span class="line">        col_data_arr = data_arr[i]</span><br><span class="line">        <span class="comment">// 该列对应的临时对象</span></span><br><span class="line">        col_data_json = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, data_arr_col_len = col_data_arr.<span class="property">length</span>; j &lt; data_arr_col_len; j++) &#123;</span><br><span class="line">            col_data_json[keys_arr[j]] = col_data_arr[j]</span><br><span class="line">        &#125;</span><br><span class="line">        result_arr.<span class="title function_">push</span>(col_data_json)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result_arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看看生成的result_arr<br><img src="https://pic3.zhimg.com/80/v2-7a9dcdeb07b4d88976836de7323c7b12_720w.webp"></p><p>可见已经成功生成每一种语言的json对象了。<br>接下来只需要生成json文件就可以了，注意把之前生成的excel文件删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到的数据写入文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeFile</span>(<span class="params">datas, outputPath</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = datas.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(outputPath + (datas[i].<span class="property">filename</span> || datas[i].<span class="property">lang</span>) + <span class="string">&#x27;.json&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(datas[i], <span class="literal">null</span>, <span class="number">4</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    rmobj.<span class="title function_">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>移动端多端适配（flexiblejs）</title>
    <link href="https://superq314.github.io/posts/740ab8bd/"/>
    <id>https://superq314.github.io/posts/740ab8bd/</id>
    <published>2022-10-17T02:35:41.000Z</published>
    <updated>2022-10-17T04:17:55.842Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p><strong>flexible.js帮我们计算出1rem 等于多少px</strong> 。</p><p><strong>计算方式</strong></p><blockquote><p>很简单，就是1rem &#x3D; 屏幕宽度width &#x2F; 10</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>  <span class="comment">// 返回文档的root元素,即html</span></span><br><span class="line"><span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span></span><br><span class="line">docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure><p>rem的大小是根据html节点的font-size的相对值<br>例如，iphone 6的屏幕宽度为375px，因此1rem &#x3D;&#x3D;&#x3D; 37.5px。</p><h2 id="计算rem的作用"><a href="#计算rem的作用" class="headerlink" title="计算rem的作用"></a>计算rem的作用</h2><p>发挥它的用处是当我们根据设计稿来转化成页面时需要用到。</p><p>举个例子，现在有两个手机，一个手机的屏幕宽度是375px，一个是750px，设计稿给我们的宽度是375px，那我们按照设计稿的设计在375px的手机上刚好完美匹配，但是却会发现在750px的手机上页面只有一半，空白了一半。</p><p>这就是我们需要解决的问题，即怎么解决移动端尺寸众多的问题，我们的设计稿是固定，怎么办，如果设计稿是弹性的可以随意缩放该多好。</p><p>好吧，设计只给一张设计稿，我们只能想其他方法啦。</p><h2 id="等比例放缩"><a href="#等比例放缩" class="headerlink" title="等比例放缩"></a>等比例放缩</h2><p>现在我们把设计稿分成10等份，设计稿 A &#x3D; W&#x2F;10，我们把设备可视区域也就是我们的各种移动端设备的这个画布也分成10份，并赋值给根元素的fontSize，我们都知道rem是根据根元素字体大小计算的，所以我们的1rem也就是设备可视区域&#x2F;10，现在设计稿上有一块区域宽B，那它是不是等比放到设备可视区域的宽度为 B&#x2F;A rem。</p><p>再啰嗦一下，B在设计稿上占B&#x2F;A份，那在设备可视区域上也要占B&#x2F;A份对不对，所以宽是B&#x2F;A rem。这就是flexible.js能实现设备兼容的原理。下面看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个立即执行函数，执行时传入的参数是window和document</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">flexible</span> (<span class="variable language_">window</span>, <span class="variable language_">document</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>  <span class="comment">// 返回文档的root元素</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span> <span class="comment">// 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// adjust body font size 设置默认字体大小，默认的字体大小继承自body</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setBodyFontSize</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = (<span class="number">12</span> * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setBodyFontSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setRemUnit</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span></span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setRemUnit</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset rem unit on page resize</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">      <span class="title function_">setRemUnit</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// detect 0.5px supports  检测是否支持0.5像素，解决1px在高清屏多像素问题，需要css的配合。</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    testElement.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">    fakeBody.<span class="title function_">appendChild</span>(testElement)</span><br><span class="line">    docEl.<span class="title function_">appendChild</span>(fakeBody)</span><br><span class="line">    <span class="keyword">if</span> (testElement.<span class="property">offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.<span class="title function_">removeChild</span>(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">window</span>, <span class="variable language_">document</span>))</span><br></pre></td></tr></table></figure><p>这就是flexible.js的源码，超级简单吧。</p><p><img src="https://pic1.zhimg.com/80/v2-98391a7a7033a03304afe78b500ebb90_720w.webp"><br><img src="https://pic2.zhimg.com/80/v2-6f4de7f8b828b1d56e0b3cd6312f51f1_720w.webp"></p><p>现在已经实现了将屏幕分为10等份，也就是1rem。</p><h2 id="将设计稿分成10等份"><a href="#将设计稿分成10等份" class="headerlink" title="将设计稿分成10等份"></a>将设计稿分成10等份</h2><p>根据我们上面画饼的方案，现在也要把设计稿转化为10等分才行。</p><p>我看了下我们项目的实现是用到了<code>postcss-pxtorem</code>插件来实现的</p><p>因为设计稿给我们的是px单位的，所以我们在开发的时候只能写px，然后这就需要postcss-pxtorem来帮我们将我们写的px转化为rem了。</p><p>安装完postcss-pxtorem之后的配合非常简单，只要在.postcssrc.js文件配置如下就好了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;postcss-pxtorem&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">rootValue</span>: <span class="number">75</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rootValue：75</strong> 为啥是75呢，这是因为我们的设计稿的宽度是750px，十分之一就是75px<br><img src="https://pic1.zhimg.com/80/v2-59153648cfdfaa6f72e6ffaad2beeef8_720w.webp"><br><strong>如果你们的设计稿是375px的，就需要将值改写成37.5</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这么简单的两步就实现了移动端的适配。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li>flexible.js 原理解析(看了不会忘)：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6923060568437817351">https://juejin.cn/post/6923060568437817351</a></li><li>通过插件postcss-pxtorem轻松实现px到rem转换，完成移动端适配：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/llq886/article/details/105737987">https://blog.csdn.net/llq886/article/details/105737987</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>魔改总览</title>
    <link href="https://superq314.github.io/posts/15174961/"/>
    <id>https://superq314.github.io/posts/15174961/</id>
    <published>2022-10-15T07:51:29.000Z</published>
    <updated>2022-10-15T10:47:29.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://akilar.top/posts/d9550c81/">添加白天夜间模式转换动画</a></li><li><a href="https://akilar.top/posts/3afa069a/">引入Aplayer播放音乐</a></li><li><a href="https://akilar.top/posts/194e1534/">Butterfly布局调整———相关推荐版块侧栏卡片</a></li><li><a href="https://akilar.top/posts/451ac5f8/">Butterfly fixed card widget</a></li><li><a href="https://akilar.top/posts/a9131002/">Categories Magnet</a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a>；</li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Hexo" scheme="https://superq314.github.io/categories/Hexo/"/>
    
    <category term="魔改" scheme="https://superq314.github.io/categories/Hexo/%E9%AD%94%E6%94%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Vuejs构建方式</title>
    <link href="https://superq314.github.io/posts/71fee748/"/>
    <id>https://superq314.github.io/posts/71fee748/</id>
    <published>2022-10-14T08:54:26.000Z</published>
    <updated>2022-10-14T09:03:38.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将 Vue.js 添加到项目中主要有四种方式：</p><ol><li>在页面上以 <a href="https://v3.cn.vuejs.org/guide/installation.html#cdn">CDN 包</a>的形式导入。</li><li>下载 JavaScript 文件并<a href="https://v3.cn.vuejs.org/guide/installation.html#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%87%AA%E6%89%98%E7%AE%A1">自行托管</a>。</li><li>使用 <a href="https://v3.cn.vuejs.org/guide/installation.html#npm">npm</a> 安装它。</li><li>使用官方的 <a href="https://v3.cn.vuejs.org/guide/installation.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-cli">CLI</a> 来构建一个项目，它为现代前端工作流程提供了功能齐备的构建设置 (例如，热重载、保存时的提示等等)。</li></ol><p>在使用 Vue 时，推荐在浏览器上安装 <a href="https://github.com/vuejs/vue-devtools#vue-devtools">Vue Devtools</a>，允许在一个更友好的界面中审查和调试 Vue 应用。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在用 Vue 构建大型应用时推荐使用 npm 安装。npm 能很好地和诸如 <a href="https://webpack.js.org/">webpack</a> 或 <a href="https://rollupjs.org/">Rollup</a> 模块打包器配合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新稳定版</span></span><br><span class="line">npm install vue@next</span><br></pre></td></tr></table></figure><p>Vue 还提供了编写<a href="https://v3.cn.vuejs.org/guide/single-file-component.html">单文件组件</a>的配套工具。如果你想使用单文件组件，那么你还需要安装 <code>@vue/compiler-sfc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D @vue/compiler-sfc</span><br></pre></td></tr></table></figure><h2 id="命令行工具-CLI"><a href="#命令行工具-CLI" class="headerlink" title="命令行工具 (CLI)"></a>命令行工具 (CLI)</h2><p>Vue 提供<a href="https://cli.vuejs.org/zh/">CLI</a>，为单页面应用 (SPA) 快速搭建脚手架。它为现代前端工作流提供了功能齐备的构建设置。</p><p>运行所需时间短，带有热重载、保存时 lint 校验。</p><p>详情查阅 <a href="https://cli.vuejs.org/zh/">Vue CLI 的文档</a>。</p><blockquote><p>TIP</p><p>CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读<a href="https://v3.cn.vuejs.org/guide/introduction.html">指南</a>，在熟悉 Vue 本身之后再使用 CLI。</p></blockquote><p>对于 Vue 3，你应该使用 <code>npm</code> 上可用的 Vue CLI v4.5 作为 <code>@vue/cli</code>。要升级，你应该需要全局重新安装最新版本的 <code>@vue/cli</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>然后在 Vue 项目中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue upgrade --next</span><br></pre></td></tr></table></figure><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p><a href="https://cn.vitejs.dev/">Vite</a> 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。</p><p>通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。</p><p>使用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 6.x</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; --template vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 7+，需要加上额外的双短横线</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; -- --template vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>或者 yarn：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn create vite &lt;project-name&gt; --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>或者 pnpm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pnpm create vite &lt;project-name&gt; -- --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">pnpm install</span><br><span class="line">pnpm dev</span><br></pre></td></tr></table></figure><h2 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h2><p>在 <a href="https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/">npm 包的 dist&#x2F; 目录</a>你将会找到很多不同的 Vue.js 构建版本。下面是一个概述，根据不同的使用情况，应该使用哪个 <code>dist</code> 文件：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初识Vue-数据绑定bind</title>
    <link href="https://superq314.github.io/posts/7ed0d5cb/"/>
    <id>https://superq314.github.io/posts/7ed0d5cb/</id>
    <published>2022-10-13T14:37:01.000Z</published>
    <updated>2022-10-14T09:15:03.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>操作元素的class列表和内联样式是数据绑定的一个常见需求。<br>因为都是attribute，所以用v-bind进行处理：只需要通过表达式计算出字符串结果。<br>表达式结果的类型：字符串、对象、数组。</p><h2 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a>v-bind语法糖</h2><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定class"><a href="#动态绑定class" class="headerlink" title="动态绑定class"></a>动态绑定class</h3><p>用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><ol><li>使用 JavaScript 表达式进行动态求值，求得的值作为最终的绑定参数。<br>&lt;a v-bind:[attributeName]&#x3D;”url”&gt; … <code>&lt;/a&gt;</code><br>例如，当Vue 实例中的data有个property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</li><li>使用动态参数为一个动态的事件名绑定处理函数：<br>&lt;a v-on:[eventName]&#x3D;”doSomething”&gt; … <code>&lt;/a&gt;</code><br>例如，当 eventName 的值为 “focus” 时，v-on:[eventName] 将等价于 v-on:focus。</li></ol><h2 id="绑定Class"><a href="#绑定Class" class="headerlink" title="绑定Class"></a>绑定Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><ol><li>传给 v-bind:class 一个对象，以动态地切换 class：<br><code>&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>active 这个 class 存在与否将取决于数据property isActive 的 truthiness。<br>可以在对象中传入更多字段来动态切换多个 class。</p></blockquote><ol start="2"><li>v-bind:class 指令可以与普通的 class attribute 共存。当有如下模板：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span></span><br><span class="line">  <span class="built_in">class</span>=<span class="string">&quot;static&quot;</span></span><br><span class="line">  v-bind:<span class="built_in">class</span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span><br><span class="line">&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">isActive:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError:</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：<br><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code><br>当 isActive 或者 hasError 变化时，class 列表将相应地更新。<br>例如，如果 hasError 的值为 true，class 列表将变为 “static active text-danger”。<br>3. 绑定的数据对象不必内联定义在模板里：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;<span class="symbol">classObject</span>&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>绑定一个返回对象的计算属性。这是一个常用且强大的模式：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><ol><li>把一个数组传给 v-bind:class，以应用一个 class 列表：</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;[<span class="symbol">activeClass, <span class="symbol">errorClass</span></span>]&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><code>&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></p><ol start="2"><li>根据条件切换列表中的 class，可以用三元表达式：<br><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>只有在 isActive 是 truthy时才添加 activeClass。</p></blockquote><ol start="3"><li>在数组语法中也可以使用对象语法</li></ol><blockquote><p>避免多个条件class时，书写繁琐。<br><code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</code></p></blockquote><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><p>当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。<br>例如，如果已经声明了这个组件：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;<span class="keyword">my</span>-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p <span class="built_in">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>在使用的时候添加一些 class：<br><code>&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</code><br>HTML 将被渲染为：<br><code>&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</code></li><li>对于带数据绑定 class ：<br><code>&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</code><br>当 isActive 为 truthy时，HTML 将被渲染成为：<br><code>&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</code></li></ol><h2 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p>v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，需用引号括起来) 来命名：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接绑定到样式对象，使模板更清晰：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;styleObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：<br><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></p><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，VueJS 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><code>&lt;div :style=&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;/div&gt;</code><br>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-创建Vue实例</title>
    <link href="https://superq314.github.io/posts/b7848c31/"/>
    <id>https://superq314.github.io/posts/b7848c31/</id>
    <published>2022-10-13T14:36:50.000Z</published>
    <updated>2022-10-14T09:14:00.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建-Vue-实例"><a href="#创建-Vue-实例" class="headerlink" title="创建 Vue 实例"></a>创建 Vue 实例</h2><p>由 Vue 函数创建 Vue 实例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>Vue 实例会将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。<br>当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="selector-tag">var</span> data = &#123; <span class="selector-tag">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="selector-tag">var</span> vm = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm<span class="selector-class">.a</span> == data<span class="selector-class">.a</span> <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm<span class="selector-class">.a</span> = <span class="number">2</span></span><br><span class="line">data<span class="selector-class">.a</span> <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data<span class="selector-class">.a</span> = <span class="number">3</span></span><br><span class="line">vm<span class="selector-class">.a</span> <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：只有当实例被创建时，就已经存在于 data 中的 property，才是响应式的。<br>也就是说如果添加一个新的 property，比如：<br><code>vm.b = &#39;hi&#39;</code><br>那么对 b 的改动将不会触发任何视图的更新。<br>如果知道后续会需要一个 property，但是一开始为空或不存在，那么仅需要设置一些初始值。比如：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">newTodoText:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">visitCount:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">hideCompletedTodos:</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">todos:</span> [],</span><br><span class="line">  <span class="attr">error:</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.freeze()：会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">var obj = </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  foo: &#x27;bar&#x27;</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">Object.freeze(obj)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">new Vue(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="template-variable">  data: obj</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; foo &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: <span class="built_in">data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === <span class="built_in">data</span> <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === document.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, function (newValue, oldValue) &#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>el:类型：string | HTMLElement<br>作用：决定之后Vue实例会管理哪一个DOM<br>data:类型：Object | Function<br>作用：Vue实例对应的数据对象<br>methods:类型：{[key:string]:Function}<br>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-计算属性和侦听器</title>
    <link href="https://superq314.github.io/posts/224f971c/"/>
    <id>https://superq314.github.io/posts/224f971c/</id>
    <published>2022-10-13T14:36:36.000Z</published>
    <updated>2022-10-14T09:14:39.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算属性 VS 表达式中调用方法 VS 侦听属性</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性，写在实例的computed选项中<br>计算属性的优势</p><blockquote><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p></blockquote><p>对于任何复杂逻辑，都可以使用计算属性。<br>每个计算属性都包含一个getter()和setter()</p><h3 id="计算属性的getter"><a href="#计算属性的getter" class="headerlink" title="计算属性的getter"></a>计算属性的getter</h3><blockquote><p>计算属性的getter函数是没有副作用的。</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">reversedMessage</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><p>计算属性默认只有 getter，不过在需要时也可以提供一个 setter：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行<br>vm.fullName &#x3D; ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h2 id="表达式中调用方法"><a href="#表达式中调用方法" class="headerlink" title="表达式中调用方法"></a>表达式中调用方法</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: <span class="string">&quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="attr">reversedMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h2><p>有时需要一个自定义的侦听器。因此，Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<br>例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Ask a yes/no question: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">answer</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">debouncedGetAnswer</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">getAnswer</span>, <span class="number">500</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">getAnswer</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">question</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = _.<span class="title function_">capitalize</span>(response.<span class="property">data</span>.<span class="property">answer</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 watch 选项允许用户执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>总结：<br><strong>计算属性是基于它们的响应式依赖进行缓存的。</strong><br>只在相关响应式依赖发生改变时它们才会重新求值。</p><ul><li>这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li><li>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-模板语法</title>
    <link href="https://superq314.github.io/posts/d3e99041/"/>
    <id>https://superq314.github.io/posts/d3e99041/</id>
    <published>2022-10-13T14:36:14.000Z</published>
    <updated>2022-10-14T09:23:56.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模板语法：基于 HTML，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><blockquote><p>所有 VueJS 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p></blockquote><h2 id="模板插值"><a href="#模板插值" class="headerlink" title="模板插值"></a>模板插值</h2><ol><li>文本插值<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：<br><code>&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</code><br><code>Mustache</code>标签将会被替代为对应数据对象上 <code>msg property</code> 的值。</li></ol><blockquote><p>无论何时，绑定的数据对象上 <code>msg property</code> 发生了改变，插值处的内容都会更新。</p></blockquote><ol start="2"><li><p>一次性文本插值<br>通过使用 v-once 指令，执行一次性文本插值，当数据改变时，插值处的内容不会更新。<br><code>&lt;div v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</code><br>注：这会影响到该节点上的其他数据绑定</p></li><li><p>插入原始HTML</p><ol><li>如果直接通过<code>&#123;&#123;&#125;&#125;</code>来输出，会将HTML格式进行解析，并且显示对应的内容。</li><li>可以使用v-html指令，该指令后跟上一个string类型</li><li>会将string的html解析处理并且进行渲染</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>span 的内容将会被替换为 property 值 rawHtml，直接作为 HTML内容<br>在站点上动态渲染任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。<br>请只对可信内容使用 HTML 插值，绝不要对用户提供的内容（UGC内容）使用插值。</p></blockquote><ol start="4"><li>v-text的作用和Mustache比较相似，独使用于将数据显示在界面中，一般情况下，接受一个string类型。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">message</span>: <span class="string">&#x27;你好&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="6"><li>v-cloak斗篷的意思。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>hello</span><span class="template-variable">&#123;&#123;<span class="name">name</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">name</span>: <span class="string">&#x27;web&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;,<span class="number">10000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> <span class="selector-attr">[v-cloak]</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">display</span>: none;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="7"><li>JavaScript表达式<br>实际上，对于所有的数据绑定，VueJS 都提供了完全的 JavaScript 表达式支持。<br><code>&lt;div&gt;&#123;&#123; gender === "male" ? 'Boy': 'Girl' &#125;&#125;&lt;/div&gt;</code></li></ol><blockquote><p>限制：每个绑定都只能包含单个表达式。<br>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。<br>指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况)。<br>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<br>接收参数<br>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。常用的有两个</p><ol><li>响应式地更新HTML attribute</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> app2 = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-2&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    message: <span class="string">&#x27;页面加载于 &#x27;</span> + <span class="literal">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将该元素节点的 title attribute 和 Vue实例中的 message proterty 绑定。</p></blockquote><ol start="2"><li>事件监听</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> app5 = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-5&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this<span class="selector-class">.message</span> = this<span class="selector-class">.message</span><span class="selector-class">.split</span>(<span class="string">&#x27;&#x27;</span>)<span class="selector-class">.reverse</span>()<span class="selector-class">.join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p>用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><ol><li>使用 JavaScript 表达式进行动态求值，求得的值作为最终的绑定参数。<br><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code><br>例如，当Vue 实例中的data有个property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</li><li>使用动态参数为一个动态的事件名绑定处理函数：<br><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code><br>例如，当 eventName 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 v-on:focus。</li></ol><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-条件渲染</title>
    <link href="https://superq314.github.io/posts/3e41d22b/"/>
    <id>https://superq314.github.io/posts/3e41d22b/</id>
    <published>2022-10-13T14:36:06.000Z</published>
    <updated>2022-10-14T09:16:19.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>条件渲染</p><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><div v-if = "male">i’m super man!</div><div v-else-if = "female">i’m super woman!</div><div v-else>i’m no one!</div><h2 id="条件渲染分组"><a href="#条件渲染分组" class="headerlink" title="条件渲染分组"></a>条件渲染分组</h2><p>将 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 v-if，从而一并切换多个元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h2><p>允许用户在不同的登录方式之间切换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码，可用于切换 loginType 并且不会清除用户已经输入的内容。</p><blockquote><p>因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 placeholder。</p></blockquote><ol start="2"><li>Vue 还提供了一种方式来表达“这两个元素是完全独立的，不要复用”。只需添加一个具有唯一值的 key attribute 即可：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，每次切换时，输入框都将被重新渲染。<br>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 key attribute。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>根据条件展示元素的选项。用法和v-if大致一样：<br><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code></p><ul><li>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。</li></ul><blockquote><p>v-show 只是简单地切换元素的 CSS property display。<br>注意，v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p></blockquote><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p>v-if </p><ul><li>“真正”的条件渲染：确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li>惰性：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show </li><li>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</li></ul><blockquote><p>因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-事件处理</title>
    <link href="https://superq314.github.io/posts/38e178ba/"/>
    <id>https://superq314.github.io/posts/38e178ba/</id>
    <published>2022-10-13T14:35:57.000Z</published>
    <updated>2022-10-14T09:14:55.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。<br>示例：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked </span><span class="template-variable">&#123;&#123; <span class="name">counter</span> &#125;&#125;</span><span class="language-xml"> times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var example = new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    counter: 0</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><p>v-on 可以接收一个需要调用的方法名称，从而处理许多复杂逻辑的事件处理。<br>示例：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">var example = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">   <span class="built_in"> name</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="keyword">function</span> (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(<span class="string">&#x27;Hello &#x27;</span> + this<span class="built_in">.name</span> + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 也可以用 JavaScript 直接调用方法</span><br><span class="line">example.greet() </span><br><span class="line">// =&gt; <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example-3&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-3&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-<span class="keyword">on</span>:click=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, <span class="keyword">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">      <span class="keyword">event</span>.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。<br>尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。<br>为了解决这个问题，VueJS 为 v-on 提供了事件修饰符。</p><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line">`<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。<br>因此，用 v-on:click.prevent.self会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.1.4 新增</span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">.once不仅能作用于原生的 DOM 事件，还能作用于自定义的组件事件上。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.3.0 新增</span><br><span class="line"><span class="comment">&lt;!-- Vue 还为对应于 addEventListener中的passive选项提供了 .passive 修饰符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.passive 修饰符尤其能够提升移动端的性能。</p><blockquote><p>不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。<br>注意：.passive 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。<br><code>&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</code></p><p>在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>2.1.0 新增<br>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta<br>例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。<br>换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。<br>而单单释放 ctrl 也不会触发事件。<br>如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。<br>.exact 修饰符<br>2.5.0 新增<br>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>鼠标按钮修饰符<br>2.2.0 新增</p><ul><li>.left</li><li>.right</li><li>.middle</li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p><h2 id="为什么在-HTML-中监听事件？"><a href="#为什么在-HTML-中监听事件？" class="headerlink" title="为什么在 HTML 中监听事件？"></a>为什么在 HTML 中监听事件？</h2><p>这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。<br>但是因为所有的 VueJS 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。<br>实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</li></ol><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。</p><blockquote><p>Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p></blockquote><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-列表渲染</title>
    <link href="https://superq314.github.io/posts/cf3da349/"/>
    <id>https://superq314.github.io/posts/cf3da349/</id>
    <published>2022-10-13T14:35:49.000Z</published>
    <updated>2022-10-14T09:14:32.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h2><p>可以用 v-for 指令基于一个数组来渲染一个列表。<br>v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="language-xquery">&#123;&#123; <span class="type">item</span>.message &#125;</span><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">var example = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; message: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 v-for 块中，可以访问所有父作用域的 property。v-for 还支持一个可选的第二个参数，即当前项的索引。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">parentMessage</span> &#125;&#125;</span><span class="language-xml"> - </span><span class="template-variable">&#123;&#123; <span class="name">index</span> &#125;&#125;</span><span class="language-xml"> - </span><span class="template-variable">&#123;&#123; <span class="name">item.message</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var example = new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    parentMessage: &#x27;Parent&#x27;,</span></span><br><span class="line"><span class="language-xml">    items: [</span></span><br><span class="line"><span class="language-xml">      &#123; message: &#x27;Foo&#x27; &#125;,</span></span><br><span class="line"><span class="language-xml">      &#123; message: &#x27;Bar&#x27; &#125;</span></span><br><span class="line"><span class="language-xml">    ]</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以用 of 替代 in 作为分隔符，因为更接近 JavaScript 迭代器的语法：<br><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</code></p></blockquote><h2 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h2><p>也可以用 v-for 来遍历一个对象的 property。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;v-for-object&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">  &lt;li v-for=<span class="string">&quot;value in object&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="title">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  el: &#x27;#v-for-object&#x27;,</span><br><span class="line">  <span class="class"><span class="keyword">data</span>: &#123;</span></span><br><span class="line"><span class="class">    <span class="title">object</span>: &#123;</span></span><br><span class="line"><span class="class">      <span class="title">title</span>: &#x27;<span class="type">How</span> <span class="title">to</span> <span class="title">do</span> <span class="title">lists</span> <span class="title">in</span> <span class="type">Vue</span>&#x27;,</span></span><br><span class="line"><span class="class">      <span class="title">author</span>: &#x27;<span class="type">Jane</span> <span class="type">Doe</span>&#x27;,</span></span><br><span class="line"><span class="class">      <span class="title">publishedAt</span>: &#x27;2016-04-10&#x27;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">name</span> &#125;&#125;</span><span class="language-xml">: </span><span class="template-variable">&#123;&#123; <span class="name">value</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数作为索引：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">index</span> &#125;&#125;</span><span class="language-xml">. </span><span class="template-variable">&#123;&#123; <span class="name">name</span> &#125;&#125;</span><span class="language-xml">: </span><span class="template-variable">&#123;&#123; <span class="name">value</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。</p></blockquote><h2 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h2><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。<br>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key attribute：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>key的作用主要是为了高效的更新虚拟dom。<br>因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。</p><blockquote><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></blockquote><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。<br>变更方法：变更调用了这些方法的原始数组。<br>这些被包裹过的方法包括：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><h3 id="替换数组（非变更方法）"><a href="#替换数组（非变更方法）" class="headerlink" title="替换数组（非变更方法）"></a>替换数组（非变更方法）</h3><p>例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。<br>当使用非变更方法时，可以用新数组替换旧数组：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.<span class="built_in">filter</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p><h2 id="显示过滤-x2F-排序后的结果"><a href="#显示过滤-x2F-排序后的结果" class="headerlink" title="显示过滤&#x2F;排序后的结果"></a>显示过滤&#x2F;排序后的结果</h2><p>需求：显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。<br>方法：创建一个计算属性，用于返回过滤或排序后的数组。<br>例如：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span></span><span class="language-xquery">&#123;&#123; n &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: <span class="keyword">function</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> this.numbers<span class="built_in">.filter</span>(<span class="keyword">function</span> <span class="built_in">(number</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span><span class="built_in"> number</span> % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">for</span>=<span class="string">&quot;set in sets&quot;</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;n in even(set)&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  sets: <span class="string">[[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> <span class="params">(numbers)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> <span class="params">(number)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-v-for-里使用值范围"><a href="#在-v-for-里使用值范围" class="headerlink" title="在 v-for 里使用值范围"></a>在 v-for 里使用值范围</h2><p>v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">n</span> &#125;&#125;</span><span class="language-xml"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="在-lt-template-gt-上使用-v-for"><a href="#在-lt-template-gt-上使用-v-for" class="headerlink" title="在 &lt;template&gt; 上使用 v-for"></a>在 <code>&lt;template&gt;</code> 上使用 v-for</h2><p>类似于 v-if，可以利用带有 v-for 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">item.msg</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="v-for-与-v-if-一同使用"><a href="#v-for-与-v-if-一同使用" class="headerlink" title="v-for 与 v-if 一同使用"></a>v-for 与 v-if 一同使用</h2><blockquote><p>注意：不推荐在同一元素上使用 v-if 和 v-for。<br>当处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下：</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">todo</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的代码将只渲染未完成的 todo。<br>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;todos.length&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h2><p>在自定义组件上，你可以像在任何普通元素上一样使用 v-for。<br><code>&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt;</code><br>2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。<br>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in items&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:item=<span class="string">&quot;item&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:<span class="keyword">index</span>=<span class="string">&quot;index&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">&gt;&lt;/<span class="keyword">my</span>-component&gt;</span><br></pre></td></tr></table></figure><p>不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。<br>下面是一个简单的 todo 列表的完整例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;todo-list-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;addNewTodo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;new-todo&quot;</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;new-todo&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">&quot;E.g. Feed the cat&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">&quot;todo-item&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;(todo, index) in todos&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">&quot;todo.title&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">&quot;todos.splice(index, 1)&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的 is&#x3D;”todo-item” attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code>元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click=&quot;$emit(\&#x27;remove\&#x27;)&quot;&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  &#x27;</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attribute">el</span>: <span class="string">&#x27;#todo-list-example&#x27;</span>,</span><br><span class="line">  <span class="attribute">data</span>: &#123;</span><br><span class="line">    <span class="attribute">newTodoText</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attribute">todos</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 1,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Do the dishes&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 2,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Take out the trash&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 3,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Mow the lawn&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attribute">nextTodoId</span>: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attribute">methods</span>: &#123;</span><br><span class="line">    <span class="attribute">addNewTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> this.nextTodoId</span>++,</span><br><span class="line">        <span class="attribute">title</span>: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-表单输入绑定</title>
    <link href="https://superq314.github.io/posts/f6a53e88/"/>
    <id>https://superq314.github.io/posts/f6a53e88/</id>
    <published>2022-10-13T14:35:40.000Z</published>
    <updated>2022-10-14T09:14:18.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>可以用 v-model 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。<br>v-model 本质上是语法糖，本质：</p><ol><li>v-bind绑定一个value属性</li><li>v-on指令给当前元素绑定input事件</li></ol><p>&#x3D;&#x3D;&gt; 负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p><blockquote><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 data 选项中声明初始值。</p></blockquote><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: </span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space: pre-line;&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;add multiple lines&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在文本区域插值 (<code>&lt;textarea&gt;</code><code>&lt;/textarea&gt;</code>) 并不会生效，应用 v-model 来代替。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单个复选框，绑定到布尔值：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">checked</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>多个复选框，绑定到同一个数组：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mike&quot;</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: </span><span class="template-variable">&#123;&#123; <span class="name">checkedNames</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;...&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    checkedNames: []</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;One&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Two&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: </span><span class="template-variable">&#123;&#123; <span class="name">picked</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example-4&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    picked: &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h3><h4 id="单选时："><a href="#单选时：" class="headerlink" title="单选时："></a>单选时：</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="template-variable">&#123;&#123; <span class="name">selected</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;...&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    selected: &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><p>如果 v-model 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p><h4 id="多选时-绑定到一个数组-："><a href="#多选时-绑定到一个数组-：" class="headerlink" title="多选时 (绑定到一个数组)："></a>多选时 (绑定到一个数组)：</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">&quot;width: 50px;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="template-variable">&#123;&#123; <span class="name">selected</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example-6&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    selected: []</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="用-v-for-渲染的动态选项："><a href="#用-v-for-渲染的动态选项：" class="headerlink" title="用 v-for 渲染的动态选项："></a>用 v-for 渲染的动态选项：</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="language-xquery">&#123;&#123; <span class="keyword">option</span>.<span class="type">text</span> &#125;</span><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="language-xquery">&#123;&#123; selected &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: <span class="string">&#x27;One&#x27;</span>, value: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">      &#123; text: <span class="string">&#x27;Two&#x27;</span>, value: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">      &#123; text: <span class="string">&#x27;Three&#x27;</span>, value: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 v-bind 实现，并且这个 property 的值可以不是字符串。</p><h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  <span class="keyword">type</span>=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">  v-model=<span class="string">&quot;toggle&quot;</span></span><br><span class="line">  <span class="literal">true</span>-value=<span class="string">&quot;yes&quot;</span></span><br><span class="line">  <span class="literal">false</span>-value=<span class="string">&quot;no&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.toggle === <span class="string">&#x27;yes&#x27;</span></span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.toggle === <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 true-value 和 false-value attribute 并不会影响输入控件的 value attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。<br>如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p><h3 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;radio&quot;</span> v-model=<span class="string">&quot;pick&quot;</span> v-<span class="keyword">bind</span>:value=<span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm<span class="variable">.pick</span> === vm<span class="variable">.a</span></span><br></pre></td></tr></table></figure><h3 id="选择框的选项"><a href="#选择框的选项" class="headerlink" title="选择框的选项"></a>选择框的选项</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;&#123; number: 123 &#125;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line">// 当选中</span><br><span class="line">typeof vm.selected // =&gt; <span class="string">&#x27;object&#x27;</span></span><br><span class="line">vm.selected<span class="built_in">.number</span> // =&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>.lazy</p><ol><li>默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。</li><li>一旦有数据发生改变对应的data中的数据就会自动发生改变。</li><li>可以添加lazy修饰符，让数据在 change 事件之后进行更新：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.number</p><ol><li>默认情况下，在输入框中无论输入的是字母&#x2F;数字，都会被当做字符串类型进行处理。</li><li>number修饰符可以让在输入框中输入的内容自动转成数值类型。<br><code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code><br>这通常很有用，因为即使在 type&#x3D;”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。</li></ol><p>.trim<br>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：<br><code>&lt;input v-model.trim=&quot;msg&quot;&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-组件基础</title>
    <link href="https://superq314.github.io/posts/b1068101/"/>
    <id>https://superq314.github.io/posts/b1068101/</id>
    <published>2022-10-13T14:35:06.000Z</published>
    <updated>2022-10-14T09:32:01.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><p>1.组件化是vue.js中的重要思想<br>2.它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用<br>3.任何的应用都会被抽象成一颗组件树<br><img src="/image/%E7%BB%84%E4%BB%B6%E5%8C%96%E2%80%94%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/1665673037732.png" alt="1665673037732"><br>注册组件的基本步骤：<br>1.创建组件构造器<br>2.注册组件<br>3.使用组件<br>示例：<br>调用Vue.extend()方法创建组件构造器<br>调用Vue.component()方法，注册组件<br>在Vue实例的作用范围内使用组件</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>这里有一个 Vue 组件的示例：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(<span class="symbol">&#x27;button</span>-counter&#x27;, &#123;</span><br><span class="line">  data: <span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">&#123;</span></span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;`&lt;button v-on:click=<span class="string">&quot;count++&quot;</span>&gt;`You clicked me &#123;&#123; count &#125;&#125; times.`&lt;/button&gt;`&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。<br>我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(</span><span class="template-variable">&#123; el: &#x27;#components-demo&#x27; &#125;</span><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。<br>仅有的例外是像 el这样根实例特有的选项。</p><h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>将组件进行任意次数的复用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p><h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h3><p>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>: &#123;</span></span><br><span class="line"><span class="class">  <span class="title">count</span>: 0</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：<br>data: function () {<br>  return {<br>    count: 0<br>  }<br>}<br>如果 Vue 没有这条规则，点击一个按钮可能会影响到其它所有实例。</p><h2 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h2><p>通常一个应用会以一棵嵌套的组件树的形式来组织。<br>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。<br>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。<br>这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的：<br>Vue.component(‘my-component-name’, {<br>  &#x2F;&#x2F; … options …<br>})<br>全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><h2 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a>通过 Prop 向子组件传递数据</h2><p>Prop 是可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中：<br>Vue.component(‘blog-post’, {<br>  props: [‘title’],<br>  template: ‘<code>&lt;h3&gt;</code>组件化-组件基础<code>&lt;/h3&gt;</code>‘<br>})<br>一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。<br>一个 prop 被注册之后，你就可以像这样把数据作为一个自定义 attribute 传递进来：<br><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code><br><code>&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;</code><br><code>&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;</code><br>然而在一个典型的应用中，你可能在 data 里有一个博文的数组：<br>new Vue({<br>  el: ‘#blog-post-demo’,<br>  data: {<br>    posts: [<br>      { id: 1, title: ‘My journey with Vue’ },<br>      { id: 2, title: ‘Blogging with Vue’ },<br>      { id: 3, title: ‘Why Vue is so fun’ }<br>    ]<br>  }<br>})<br>并想要为每篇博文渲染一个组件：<br>&lt;blog-post<br>  v-for&#x3D;”post in posts”<br>  v-bind:key&#x3D;”post.id”<br>  v-bind:title&#x3D;”post.title”</p><blockquote></blog-post></blockquote><p>如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。</p><h2 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h2><p>当构建一个 <code>&lt;blog-post&gt;</code> 组件时，你的模板最终会包含的东西远不止一个标题：</p><h3>组件化-组件基础</h3>最最起码，你会包含这篇博文的正文：<h3>组件化-组件基础</h3><div v-html="content"></div>然而如果你在模板中尝试这样写，Vue 会显示一个错误，并解释道 every component must have a single root element (每个组件必须只有一个根元素)。你可以将模板的内容包裹在一个父元素内，来修复这个问题，例如：<div class="blog-post">  <h3>组件化-组件基础</h3>  <div v-html="content"></div></div>看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦：<blog-post  v-for="post in posts"  v-bind:key="post.id"  v-bind:title="post.title"  v-bind:content="post.content"  v-bind:publishedAt="post.publishedAt"  v-bind:comments="post.comments"></blog-post>所以是时候重构一下这个 <blog-post> 组件了，让它变成接受一个单独的 postprop：<blog-post  v-for="post in posts"  v-bind:key="post.id"  v-bind:post="post"></blog-post>Vue.component('blog-post', {  props: ['post'],  template: `    <div class="blog-post">      <h3></h3>      <div v-html="post.content"></div>    </div>  `})上述的这个和一些接下来的示例使用了 JavaScript 的模板字符串来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之。现在，不论何时为 post 对象添加一个新的 property，它都会自动地在 <blog-post>内可用。<h2 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h2><p>在我们开发 <code>&lt;blog-post&gt;</code> 组件时，它的一些功能可能要求我们和父级组件进行沟通。例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号。<br>在其父组件中，我们可以通过添加一个 postFontSize 数据 property 来支持这个功能：<br>new Vue({<br>  el: ‘#blog-posts-events-demo’,<br>  data: {<br>    posts: [&#x2F;* … *&#x2F;],<br>    postFontSize: 1<br>  }<br>})<br>它可以在模板中用来控制所有博文的字号：</p><div id="blog-posts-events-demo">  <div :style="{ fontSize: postFontSize + 'em' }">    <blog-post      v-for="post in posts"      v-bind:key="post.id"      v-bind:post="post"    ></blog-post>  </div></div>现在我们在每篇博文正文之前添加一个按钮来放大字号：Vue.component('blog-post', {  props: ['post'],  template: `    <div class="blog-post">      <h3></h3>      <button>        Enlarge text      </button>      <div v-html="post.content"></div>    </div>  `})问题是这个按钮不会做任何事：<button>  Enlarge text</button>当点击这个按钮时，我们需要告诉父级组件放大所有博文的文本。幸好 Vue 实例提供了一个自定义事件的系统来解决这个问题。1. 父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：<blog-post  ...  v-on:enlarge-text="postFontSize += 0.1"></blog-post>2. 子组件通过调用内建的 $emit 方法并传入事件名称来触发一个事件：<button v-on:click="$emit('enlarge-text')">  Enlarge text</button>有了这个 v-on:enlarge-text="postFontSize += 0.1" 监听器，父级组件就会接收该事件并更新 postFontSize 的值。<h3 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h3><p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 $emit 的第二个参数来提供这个值：<br><code>&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;</code><br>  Enlarge text<br><code>&lt;/button&gt;</code><br>然后当在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值：<br>&lt;blog-post<br>  …<br>  v-on:enlarge-text&#x3D;”postFontSize +&#x3D; $event”</p><blockquote></blog-post></blockquote><p>或者，如果这个事件处理函数是一个方法：<br>&lt;blog-post<br>  …<br>  v-on:enlarge-text&#x3D;”onEnlargeText”</p><blockquote></blog-post></blockquote><p>那么这个值将会作为第一个参数传入这个方法：<br>methods: {<br>  onEnlargeText: function (enlargeAmount) {<br>    this.postFontSize +&#x3D; enlargeAmount<br>  }<br>}</p><h3 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h3><p>自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：<br><code>&lt;input v-model=&quot;searchText&quot;&gt;</code><br>等价于：<br>&lt;input<br>  v-bind:value&#x3D;”searchText”<br>  v-on:input&#x3D;”searchText &#x3D; $event.target.value”</p><p>当用在组件上时，v-model 则会这样：<br>&lt;custom-input<br>  v-bind:value&#x3D;”searchText”<br>  v-on:input&#x3D;”searchText &#x3D; $event”</p><blockquote></custom-input></blockquote><p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p><ul><li>将其 value attribute 绑定到一个名叫 value 的 prop 上</li><li>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出<br>写成代码之后是这样的：<br>Vue.component(‘custom-input’, {<br>props: [‘value’],<br>template: <code>&lt;input v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;    &gt;</code><br>})<br>现在 v-model 就应该可以在这个组件上完美地工作起来了：<br><code>&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</code><br>到目前为止，关于组件自定义事件你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把自定义事件读完。</li></ul><h2 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h2><p>和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：<br><code>&lt;alert-box&gt;</code><br>  Something bad happened.<code>&lt;/alert-box&gt;</code><br>可能会渲染出这样的东西：<br>Error! Something bad happened.<br>幸好，Vue 自定义的 <code>&lt;slot&gt;</code> 元素让这变得非常简单：<br>Vue.component(‘alert-box’, {<br>  template: <code>  &lt;div class=&quot;demo-alert-box&quot;&gt;       &lt;strong&gt;Error!&lt;/strong&gt;       &lt;slot&gt;&lt;/slot&gt;     &lt;/div&gt;</code><br>})<br>如你所见，我们只要在需要的地方加入插槽就行了——就这么简单！</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：<br>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is attribute 来实现：</p><!-- 组件会在 `currentTabComponent` 改变时改变 --><p><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>在上述示例中，currentTabComponent 可以包括</p><ul><li>已注册组件的名字，或</li><li>一个组件的选项对象<br>注意：这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，若想让其如预期般工作，你需要使用 .prop 修饰器。</li></ul><h2 id="解析-DOM-模板时的注意事项"><a href="#解析-DOM-模板时的注意事项" class="headerlink" title="解析 DOM 模板时的注意事项"></a>解析 DOM 模板时的注意事项</h2><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。<br>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p><table>  <blog-post-row></blog-post-row></table>这个自定义组件 <blog-post-row> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：<table>  <tr is="blog-post-row"></tr></table>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：字符串 (例如：template: '...')单文件组件 (.vue)<script type="text/x-template">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-组件注册</title>
    <link href="https://superq314.github.io/posts/1944849e/"/>
    <id>https://superq314.github.io/posts/1944849e/</id>
    <published>2022-10-13T14:34:58.000Z</published>
    <updated>2022-10-14T09:32:04.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>组件注册<br>组件名<br>在注册一个组件的时候，需要一个名字。比如在全局注册的时候：<br>Vue.component(‘my-component-name’, { &#x2F;* … <em>&#x2F; })<br>该组件名就是 Vue.component 的第一个参数。<br>给予组件的名字可能依赖于打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。定义组件名<br>方式有两种：<br>1、使用 kebab-case<br>Vue.component(‘my-component-name’, { &#x2F;</em> … <em>&#x2F; })<br>当使用 kebab-case (短横线分隔命名) 定义一个组件时，必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。<br>2、使用 PascalCase<br>Vue.component(‘MyComponentName’, { &#x2F;</em> … *&#x2F; })<br>当使用 PascalCase (首字母大写命名) 定义一个组件时，在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的。</p><blockquote><p>注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>注册全局组件<br>用 Vue.component 来创建组件：<br>Vue.component(‘my-component-name’, {<br> &#x2F;&#x2F; … 选项 …<br>})<br>在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如：<br>Vue.component(‘component-a’, { &#x2F;* … <em>&#x2F; })<br>Vue.component(‘component-b’, { &#x2F;</em> … <em>&#x2F; })<br>Vue.component(‘component-c’, { &#x2F;</em> … *&#x2F; })<br>new Vue({ el: ‘#app’ })</p></blockquote><div id="app">  <component-a></component-a>  <component-b></component-b>  <component-c></component-c></div>在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。注册局部组件全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { /* ... */ }然后在 components 选项中定义想要使用的组件：new Vue({  el: '#app',  components: {    'component-a': ComponentA,    'component-b': ComponentB  }})对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。注意局部注册的组件在其子组件中不可用。> 例如，如果希望 ComponentA 在 ComponentB 中可用，则需要这样写：var ComponentA = { /* ... */ }var ComponentB = {  components: {    'component-a': ComponentA  },  // ...}或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：import ComponentA from './ComponentA.vue'export default {  components: {    ComponentA  },  // ...}注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是：用在模板中的自定义元素的名称包含了这个组件选项的变量名模块系统在模块系统中局部注册如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中：import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default {  components: {    ComponentA,    ComponentC  },  // ...}现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。所以会导致很多组件里都会有一个包含基础组件的长列表：import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default {  components: {    BaseButton,    BaseIcon,    BaseInput  }}而只是用于模板中的一小部分：<BaseInput  v-model="searchText"  @keydown.enter="search"/><BaseButton @click="search">  <BaseIcon name="search"/></BaseButton>如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context(  // 其组件目录的相对路径  './components',  // 是否查询其子目录  false,  // 匹配基础组件文件名的正则表达式  /Base[A-Z]\w+\.(vue|js)$/)<p>requireComponent.keys().forEach(fileName &#x3D;&gt; {<br>  &#x2F;&#x2F; 获取组件配置<br>  const componentConfig &#x3D; requireComponent(fileName)</p><p>  &#x2F;&#x2F; 获取组件的 PascalCase 命名<br>  const componentName &#x3D; upperFirst(<br>    camelCase(<br>      &#x2F;&#x2F; 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘&#x2F;‘)<br>        .pop()<br>        .replace(&#x2F;.\w+$&#x2F;, ‘’)<br>    )<br>  )</p><p>  &#x2F;&#x2F; 全局注册组件<br>  Vue.component(<br>    componentName,<br>    &#x2F;&#x2F; 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    &#x2F;&#x2F; 那么就会优先使用 <code>.default</code>，<br>    &#x2F;&#x2F; 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})<br>记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-处理边界情况</title>
    <link href="https://superq314.github.io/posts/363ae6cf/"/>
    <id>https://superq314.github.io/posts/363ae6cf/</id>
    <published>2022-10-13T14:34:46.000Z</published>
    <updated>2022-10-14T12:16:07.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素 &amp; 组件"></a>访问元素 &amp; 组件</h2><p>在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。</p><h3 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h3><p>在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。<br>例如，在这个根实例中：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line">new Vue(<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">  data:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    foo:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span>,</span><br><span class="line"><span class="symbol">  computed:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    bar:</span> function () <span class="punctuation">&#123;</span> <span class="comment">/* ... */</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span>,</span><br><span class="line"><span class="symbol">  methods:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    baz:</span> function () <span class="punctuation">&#123;</span> <span class="comment">/* ... */</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span>)</span><br></pre></td></tr></table></figure><p>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。<br>&#x2F;&#x2F; 获取根组件的数据this.$root.foo<br>&#x2F;&#x2F; 写入根组件的数据this.$root.foo &#x3D; 2<br>&#x2F;&#x2F; 访问根组件的计算属性this.$root.bar<br>&#x2F;&#x2F; 调用根组件的方法this.$root.baz()</p><blockquote><p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。<br>扩展到中大型应用来说，强烈推荐使用 Vuex 来管理应用的状态。</p></blockquote><h3 id="访问父级组件实例"><a href="#访问父级组件实例" class="headerlink" title="访问父级组件实例"></a>访问父级组件实例</h3><p>和 $root 类似，$parent property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。<br>另外在一些可能适当的时候，你需要特别地共享一些组件库。举个例子，在和 JavaScript API 进行交互而不渲染 HTML 的抽象组件内，诸如这些假设性的 Google 地图组件一样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;google-<span class="keyword">map</span>&gt;</span><br><span class="line">  &lt;google-<span class="keyword">map</span>-markers v-<span class="keyword">bind</span>:places=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/google-map-markers&gt;</span></span><br><span class="line"><span class="regexp">&lt;/g</span>oogle-<span class="keyword">map</span>&gt;</span><br></pre></td></tr></table></figure><p>这个 <code>&lt;google-map&gt;</code> 组件可以定义一个 map property，所有的子组件都需要访问它。在这种情况下 <code>&lt;google-map-markers&gt;</code> 可能想要通过类似 this.$parent.getMap 的方式访问那个地图，以便为其添加一组标记。你可以在这里查阅这种模式。<br>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 <code>&lt;google-map-region&gt;</code> 组件，当 <code>&lt;google-map-markers&gt;</code> 在其内部出现的时候，只会渲染那个区域内的标记：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;google-<span class="built_in">map</span>&gt;</span><br><span class="line">  &lt;google-<span class="built_in">map</span>-<span class="built_in">region</span> v-bind:shape=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span><br><span class="line">    &lt;google-<span class="built_in">map</span>-markers v-bind:places=<span class="string">&quot;iceCreamShops&quot;</span>&gt;&lt;/google-<span class="built_in">map</span>-markers&gt;</span><br><span class="line">  &lt;/google-<span class="built_in">map</span>-<span class="built_in">region</span>&gt;</span><br><span class="line">&lt;/google-<span class="built_in">map</span>&gt;</span><br></pre></td></tr></table></figure><p>那么在 <code>&lt;google-map-markers&gt;</code> 内部你可能发现自己需要一些类似这样的 hack：<br><code>var map = this.$parent.map || this.$parent.$parent.map</code><br>很快它就会失控。这也是我们针对需要向任意更深层级的组件提供上下文信息时推荐依赖注入的原因。</p><h3 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h3><p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。例如：<br><code>&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</code><br>现在在你已经定义了这个 ref 的组件里，你可以使用：<br><code>this.$refs.usernameInput</code><br>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 ref 提供对内部这个指定元素的访问，例如：<br><code>&lt;input ref=&quot;input&quot;&gt;</code><br>甚至可以通过其父级组件定义方法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 用来从父级组件聚焦输入框</span></span><br><span class="line">  focus: <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：<br><code>this.$refs.usernameInput.focus()</code><br>当 ref 和 v-for 一起使用的时候，你得到的 ref 将会是一个包含了对应数据源的这些子组件的数组。<br>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>在此之前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;google-<span class="built_in">map</span>&gt;</span><br><span class="line">  &lt;google-<span class="built_in">map</span>-<span class="built_in">region</span> v-bind:shape=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span><br><span class="line">    &lt;google-<span class="built_in">map</span>-markers v-bind:places=<span class="string">&quot;iceCreamShops&quot;</span>&gt;&lt;/google-<span class="built_in">map</span>-markers&gt;</span><br><span class="line">  &lt;/google-<span class="built_in">map</span>-<span class="built_in">region</span>&gt;</span><br><span class="line">&lt;/google-<span class="built_in">map</span>&gt;</span><br></pre></td></tr></table></figure><p>在这个组件里，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 getMap 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 $parent property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。<br>provide 选项允许我们指定我们想要提供给后代组件的数据&#x2F;方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 getMap 方法：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provide: <span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">&#123;</span></span><br><span class="line">    getMap: this.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的 property：<br><code>inject: [&#39;getMap&#39;]</code><br>你可以在这里看到完整的示例。相比 $parent 来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变&#x2F;移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。<br>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的 property</li><li>后代组件不需要知道被注入的 property 来自哪里<blockquote><p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个 property 是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。</p></blockquote></li></ul><h2 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h2><p>现在，你已经知道了 $emit 的用法，它可以被 v-on 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p><ul><li>通过 $on(eventName, eventHandler) 侦听一个事件</li><li>通过 $once(eventName, eventHandler) 一次性侦听一个事件</li><li>通过 $off(eventName, eventHandler) 停止侦听一个事件<br>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 一次性将这个日期选择器附加到一个输入框上<span class="regexp">//</span> 它会被挂载到 DOM 上。mounted: <span class="keyword">function</span> () &#123;</span><br><span class="line">  <span class="regexp">//</span> Pikaday 是一个第三方日期选择器的库</span><br><span class="line">  this.picker = new Pikaday(&#123;</span><br><span class="line">    field: this.<span class="variable">$refs</span>.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="regexp">//</span> 在组件被销毁之前，<span class="regexp">//</span> 也销毁这个日期选择器。beforeDestroy: <span class="keyword">function</span> () &#123;</span><br><span class="line">  this.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里有两个潜在的问题：<br>它需要在这个组件实例中保存这个 picker，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。<br>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。<br>你应该通过一个程序化的侦听器解决这两个问题：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="keyword">function</span> <span class="params">(refName)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意，如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。在这个例子中，我们推荐创建一个可复用的<code>&lt;input-datepicker&gt;</code> 组件。<br>注意 Vue 的事件系统不同于浏览器的 EventTarget API。<br>尽管它们工作起来是相似的，但是 $emit、$on, 和 $off 并不是 dispatchEvent、addEventListener 和 removeEventListener 的别名。<br>循环引用<br>递归组件<br>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事：<br>name: ‘unique-name-of-my-component’<br>当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。<br>Vue.component(‘unique-name-of-my-component’, {<br>&#x2F;&#x2F; …<br>})<br>稍有不慎，递归组件就可能导致无限循环：<br>name: ‘stack-overflow’,template: ‘<code>&lt;div&gt;&lt;stack-overflow&gt;``&lt;/stack-overflow&gt;&lt;/div&gt;</code>‘<br>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。<br>组件之间的循环引用<br>假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</li></ul><p>  <span></span>  <tree-folder-contents :children="folder.children"/></p>还有一个 <tree-folder-contents> 组件，模板是这样的：<ul>  <li v-for="child in children">    <tree-folder v-if="child.children" :folder="child"/>    <span v-else></span>  </li></ul>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代和祖先——一个悖论！当通过 Vue.component 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。然而，如果你使用一个模块系统依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误：Failed to mount component: template or render function not defined.为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。”在我们的例子中，把 <tree-folder> 组件设为了那个点。我们知道那个产生悖论的子组件是 <tree-folder-contents> 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它：beforeCreate: function () {  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default}或者，在本地注册组件的时候，你可以使用 webpack 的异步 import：components: {  TreeFolderContents: () => import('./tree-folder-contents.vue')}这样问题就解决了！模板定义的替代品内联模板当 inline-template 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。<my-component inline-template>  <div>    <p>These are compiled as the component's own template.</p>    <p>Not parent's transclusion content.</p>  </div></my-component>内联模板需要定义在 Vue 所属的 DOM 元素内。不过，inline-template 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 <template> 元素来定义模板。X-Template另一个定义模板的方式是在一个 <script> 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如：<script type="text/x-template" id="hello-world-template">  <p>Hello hello hello</p></script>Vue.component('hello-world', {  template: '#hello-world-template'})x-template 需要定义在 Vue 所属的 DOM 元素外。这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。控制更新感谢 Vue 的响应式系统，它始终知道何时进行更新 (如果你用对了的话)。不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。强制更新如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。通过 v-once 创建低开销的静态组件渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来，就像这样：Vue.component('terms-of-service', {  template: `    <div v-once>      <h1>Terms of Service</h1>      ... a lot of static content ...    </div>  `})再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-动态组件和异步组件</title>
    <link href="https://superq314.github.io/posts/5de961e9/"/>
    <id>https://superq314.github.io/posts/5de961e9/</id>
    <published>2022-10-13T14:34:34.000Z</published>
    <updated>2022-10-14T09:31:54.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态组件 &amp; 异步组件<br>在动态组件上使用 keep-alive<br>我们之前曾经在一个多标签的界面中使用 is attribute 来切换不同的组件：<br><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。例如我们来展开说一说这个多标签界面：<br>PostsArchive<br>Cat Ipsum <br>Hipster Ipsum <br>Cupcake Ipsum <br>Click on a blog title to the left to view it. <br>你会注意到，如果你选择了一篇文章，切换到 Archive 标签，然后再切换回 Posts，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 currentTabComponent 实例。<br>重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p><!-- 失活的组件将会被缓存！--><keep-alive><p>  <code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;``&lt;/keep-alive&gt;</code><br>来看看修改后的结果：<br>PostsArchive<br>Cat Ipsum <br>Hipster Ipsum <br>Cupcake Ipsum <br>Click on a blog title to the left to view it. <br>现在这个 Posts 标签保持了它的状态 (被选中的文章) 甚至当它未被渲染时也是如此。你可以在这个示例查阅到完整的代码。<br>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部&#x2F;全局注册。<br>你可以在 API 参考文档查阅更多关于 <code>&lt;keep-alive&gt;</code> 的细节。<br>异步组件<br>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：<br>Vue.component(‘async-example’, function (resolve, reject) {<br>  setTimeout(function () {<br>    &#x2F;&#x2F; 向 <code>resolve</code> 回调传递组件定义<br>    resolve({<br>      template: ‘<code>&lt;div&gt;</code>I am async!<code>&lt;/div&gt;</code>‘<br>    })<br>  }, 1000)<br>})<br>如你所见，这个工厂函数会收到一个 resolve 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：<br>Vue.component(‘async-webpack-example’, function (resolve) {<br>  &#x2F;&#x2F; 这个特殊的 <code>require</code> 语法将会告诉 webpack<br>  &#x2F;&#x2F; 自动将你的构建代码切割成多个包，这些包<br>  &#x2F;&#x2F; 会通过 Ajax 请求加载<br>  require([‘.&#x2F;my-async-component’], resolve)<br>})<br>你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：<br>Vue.component(<br>  ‘async-webpack-example’,<br>  &#x2F;&#x2F; 这个动态导入会返回一个 <code>Promise</code> 对象。<br>  () &#x3D;&gt; import(‘.&#x2F;my-async-component’)<br>)<br>当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：<br>new Vue({<br>  &#x2F;&#x2F; …<br>  components: {<br>    ‘my-component’: () &#x3D;&gt; import(‘.&#x2F;my-async-component’)<br>  }<br>})<br>如果你是一个 Browserify 用户同时喜欢使用异步组件，很不幸这个工具的作者明确表示异步加载“并不会被 Browserify 支持”，至少官方不会。Browserify 社区已经找到了一些变通方案，这些方案可能会对已存在的复杂应用有帮助。对于其它的场景，我们推荐直接使用 webpack，以拥有内置的头等异步支持。<br>处理加载状态<br>2.3.0+ 新增<br>这里的异步组件工厂函数也可以返回一个如下格式的对象：<br>const AsyncComponent &#x3D; () &#x3D;&gt; ({<br>  &#x2F;&#x2F; 需要加载的组件 (应该是一个 <code>Promise</code> 对象)<br>  component: import(‘.&#x2F;MyComponent.vue’),<br>  &#x2F;&#x2F; 异步组件加载时使用的组件<br>  loading: LoadingComponent,<br>  &#x2F;&#x2F; 加载失败时使用的组件<br>  error: ErrorComponent,<br>  &#x2F;&#x2F; 展示加载时组件的延时时间。默认值是 200 (毫秒)<br>  delay: 200,<br>  &#x2F;&#x2F; 如果提供了超时时间且组件加载也超时了，<br>  &#x2F;&#x2F; 则使用加载失败时使用的组件。默认值是：<code>Infinity</code><br>  timeout: 3000<br>})<br>注意如果你希望在 Vue Router 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-自定义组件</title>
    <link href="https://superq314.github.io/posts/272de8cd/"/>
    <id>https://superq314.github.io/posts/272de8cd/</id>
    <published>2022-10-13T14:34:21.000Z</published>
    <updated>2022-10-14T09:31:57.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自定义事件<br>事件名<br>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：<br>this.$emit(‘myEvent’)<br>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p><!-- 没有效果 --><p><code>&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code><br>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。<br>因此，我们推荐你始终使用 kebab-case 的事件名。<br>自定义组件的 v-model<br>2.2.0+ 新增<br>一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：<br>Vue.component(‘base-checkbox’, {<br>  model: {<br>    prop: ‘checked’,<br>    event: ‘change’<br>  },<br>  props: {<br>    checked: Boolean<br>  },<br>  template: <code>  &lt;input       type=&quot;checkbox&quot;       v-bind:checked=&quot;checked&quot;       v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;     &gt;</code><br>})<br>现在在这个组件上使用 v-model 的时候：<br><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code><br>这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 change事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。<br>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。<br>将原生事件绑定到组件<br>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符：<br><code>&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;</code><br>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：<br><code>&lt;label&gt;</code><br>  <br>  &lt;input<br>    v-bind&#x3D;”$attrs”<br>    v-bind:value&#x3D;”value”<br>    v-on:input&#x3D;”$emit(‘input’, $event.target.value)”</p></label>这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。为了解决这个问题，Vue 提供了一个 $listeners property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：{  focus: function (event) { /* ... */ }  input: function (value) { /* ... */ },}有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：Vue.component('base-input', {  inheritAttrs: false,  props: ['label', 'value'],  computed: {    inputListeners: function () {      var vm = this      // `Object.assign` 将所有的对象合并为一个新对象      return Object.assign({},        // 我们从父级添加所有的监听器        this.$listeners,        // 然后我们添加自定义监听器，        // 或覆写一些监听器的行为        {          // 这里确保组件配合 `v-model` 的工作          input: function (event) {            vm.$emit('input', event.target.value)          }        }      )    }  },  template: `    <label>            <input        v-bind="$attrs"        v-bind:value="value"        v-on="inputListeners"      >    </label>  `})现在 <base-input> 组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 <input> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 .native 监听器。.sync 修饰符2.3.0+ 新增在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：this.$emit('update:title', newTitle)然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：<text-document  v-bind:title="doc.title"  v-on:update:title="doc.title = $event"></text-document>为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：<text-document v-bind:title.sync="doc.title"></text-document>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 v-model。当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：<text-document v-bind.sync="doc"></text-document>这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-Prop</title>
    <link href="https://superq314.github.io/posts/56c3872d/"/>
    <id>https://superq314.github.io/posts/56c3872d/</id>
    <published>2022-10-13T14:34:09.000Z</published>
    <updated>2022-10-14T09:32:07.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Prop<br>Prop 的大小写 (camelCase vs kebab-case)<br>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：<br>Vue.component(‘blog-post’, {<br>  &#x2F;&#x2F; 在 JavaScript 中是 camelCase 的<br>  props: [‘postTitle’],<br>  template: ‘<code>&lt;h3&gt;</code><code>&lt;/h3&gt;</code>‘<br>})</p><!-- 在 HTML 中是 kebab-case 的 --><p><code>&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</code><br>重申一次，如果你使用字符串模板，那么这个限制就不存在了。<br>Prop 类型<br>到这里，我们只看到了以字符串数组形式列出的 prop：<br>props: [‘title’, ‘likes’, ‘isPublished’, ‘commentIds’, ‘author’]<br>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：<br>props: {<br>  title: String,<br>  likes: Number,<br>  isPublished: Boolean,<br>  commentIds: Array,<br>  author: Object,<br>  callback: Function,<br>  contactsPromise: Promise &#x2F;&#x2F; or any other constructor<br>}<br>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。<br>接下来是类型检查和其它 prop 验证。<br>传递静态或动态 Prop<br>给 prop 传入一个静态的值：<br><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code><br> prop 可以通过 v-bind 动态赋值，例如：</p><!-- 动态赋予一个变量的值 --><p><code>&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 动态赋予一个复杂表达式的值 --><p>&lt;blog-post<br>  v-bind:title&#x3D;”post.title + ‘ by ‘ + post.author.name”</p><blockquote></blog-post></blockquote><p>任何类型的值都可以传给一个 prop。<br>传入一个数字</p><!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个布尔值</p><!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--><p><code>&lt;blog-post is-published&gt;&lt;/blog-post&gt;</code></p><!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个数组</p><!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:comment-ids=&quot;post.commentIds&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个对象</p><!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p>&lt;blog-post<br>  v-bind:author&#x3D;”{<br>    name: ‘Veronica’,<br>    company: ‘Veridian Dynamics’<br>  }”</p><blockquote></blog-post></blockquote><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个对象的所有 property<br>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：<br>post: {<br>  id: 1,<br>  title: ‘My Journey with Vue’<br>}<br>下面的模板：<br><code>&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;</code><br>等价于：<br>&lt;blog-post<br>  v-bind:id&#x3D;”post.id”<br>  v-bind:title&#x3D;”post.title”</p><blockquote></blog-post></blockquote><p>单向数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样防止子组件意外变更父级组件的状态，从而导致应用的数据流向难以理解。<br>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>这里有两种常见的试图变更一个 prop 的情形：</p><ol><li>prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：<br>props: [‘initialCounter’],<br>data: function () {<br>return {<br>counter: this.initialCounter<br>}<br>}</li><li>这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：<br>props: [‘size’],<br>computed: {<br>normalizedSize: function () {<br>return this.size.trim().toLowerCase()<br>}<br>}<br>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。<br>Prop 验证<br>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。<br>为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：<br>Vue.component(‘my-component’, {<br>props: {<br>&#x2F;&#x2F; 基础的类型检查 (<code>null</code> 和 <code>undefined</code> 会通过任何类型验证)<br>propA: Number,<br>&#x2F;&#x2F; 多个可能的类型<br>propB: [String, Number],<br>&#x2F;&#x2F; 必填的字符串<br>propC: {<br>type: String,<br>required: true<br>},<br>&#x2F;&#x2F; 带有默认值的数字<br>propD: {<br>type: Number,<br>default: 100<br>},<br>&#x2F;&#x2F; 带有默认值的对象<br>propE: {<br>type: Object,<br>&#x2F;&#x2F; 对象或数组默认值必须从一个工厂函数获取<br>default: function () {<br>return { message: ‘hello’ }<br>}<br>},<br>&#x2F;&#x2F; 自定义验证函数<br>propF: {<br>validator: function (value) {<br>&#x2F;&#x2F; 这个值必须匹配下列字符串中的一个<br>return [‘success’, ‘warning’, ‘danger’].indexOf(value) !&#x3D;&#x3D; -1<br>}<br>}<br>}<br>})<br>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。<br>注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。<br>类型检查<br>type 可以是下列原生构造函数中的一个：<br>String<br>Number<br>Boolean<br>Array<br>Object<br>Date<br>Function<br>Symbol<br>额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数：<br>function Person (firstName, lastName) {<br>this.firstName &#x3D; firstName<br>this.lastName &#x3D; lastName<br>}<br>你可以使用：<br>Vue.component(‘blog-post’, {<br>props: {<br>author: Person<br>}<br>})<br>来验证 author prop 的值是否是通过 new Person 创建的。<br>非 Prop 的 Attribute<br>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。<br>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。<br>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上：<br><code>&lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;</code><br>然后这个 data-date-picker&#x3D;”activated” attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。<br>替换&#x2F;合并已有的 Attribute<br>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：<br><code>&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</code><br>为了给日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：<br>&lt;bootstrap-date-input<br>data-date-picker&#x3D;”activated”<br>class&#x3D;”date-picker-theme-dark”</li></ol><blockquote></bootstrap-date-input></blockquote><p>在这种情况下，我们定义了两个不同的 class 的值：<br>form-control，这是在组件的模板内设置好的<br>date-picker-theme-dark，这是从组件的父级传入的<br>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type&#x3D;”text” 就会替换掉 type&#x3D;”date” 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。<br>禁用 Attribute 继承<br>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如：<br>Vue.component(‘my-component’, {<br>  inheritAttrs: false,<br>  &#x2F;&#x2F; …<br>})<br>这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：<br>{<br>  required: true,<br>  placeholder: ‘Enter your username’<br>}<br>有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的：<br>Vue.component(‘base-input’, {<br>  inheritAttrs: false,<br>  props: [‘label’, ‘value’],<br>  template: <code>  &lt;label&gt;       &#123;&#123; label &#125;&#125;       &lt;input         v-bind=&quot;$attrs&quot;         v-bind:value=&quot;value&quot;         v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;       &gt;     &lt;/label&gt;</code><br>})<br>注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。<br>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：<br>&lt;base-input<br>  v-model&#x3D;”username”<br>  required<br>  placeholder&#x3D;”Enter your username”</p><blockquote></base-input></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-插槽slot</title>
    <link href="https://superq314.github.io/posts/68dc4785/"/>
    <id>https://superq314.github.io/posts/68dc4785/</id>
    <published>2022-10-13T14:33:44.000Z</published>
    <updated>2022-10-14T12:10:17.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>vue</code>中的代码<code>slot</code>是什么呢，它叫插槽，<code>&lt;slot&gt;</code>元素作为组件模板之中的内容分发插槽，传入内容后<code>&lt;slot&gt;</code>元素自身将被替换。<br><code>v-slot</code>用法：</p><ol><li>默认插槽</li><li>具名插槽</li><li>作用域插槽</li></ol><p><code>slot</code>以及<code>slot-scope</code>的用法：子组件编写，父组件编写</p><h2 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h2><p><code>Vue</code>实现了一套内容分发的<code>API</code>，这套<code>API</code>的设计灵感源自<code>Web Components</code>规范草案，将<code>&lt;slot&gt;</code>元素作为承载分发内容的出口。<br>它允许你像这样合成组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括<code>HTML</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span></span><br><span class="line">    Your Profile</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至其它的组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>&lt;navigation-link&gt;</code> 的 <code>template</code> 中没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>当你想在一个插槽中使用数据时，例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Logged in as </span><span class="template-variable">&#123;&#123; <span class="name">user.name</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 <code>&lt;navigation-link&gt;</code> 的作用域。<br>例如，<code>url</code>是访问不到的：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Clicking here will send you to: </span><span class="template-variable">&#123;&#123; <span class="name">url</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--这里的url会是undefined，因为其 (指该插槽的) 内容是传递给&lt;navigation-link&gt; 的而不是在 &lt;navigation-link&gt; 组件内部定义的。--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>作为一条规则，请记住：</p><ol><li>父级模板里的所有内容都是在父级作用域中编译的；</li><li>子模板里的所有内容都是在子作用域中编译的。</li></ol><h2 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h2><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：<br><code>&lt;submit-button&gt;&lt;/submit-button&gt;</code><br>后备内容“Submit”将会被渲染：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果我们提供内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;submit-button&gt;</span></span><br><span class="line">  <span class="attribute">Save</span></span><br><span class="line"><span class="section">&lt;/submit-button&gt;</span></span><br></pre></td></tr></table></figure><p>则这个提供的内容将会被渲染从而取代后备内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Save</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的<code>attribute：name</code>。这个 <code>attribute</code> 可以用来定义额外的插槽：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=&quot;<span class="symbol">container</span>&quot;&gt;</span><br><span class="line">  &lt;<span class="symbol">header</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span> <span class="symbol">name</span>=&quot;<span class="symbol">header</span>&quot;&gt;&lt;/<span class="symbol">slot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">header</span>&gt;</span><br><span class="line">  &lt;<span class="symbol">main</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span>&gt;&lt;/<span class="symbol">slot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">main</span>&gt;</span><br><span class="line">  &lt;<span class="symbol">footer</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span> <span class="symbol">name</span>=&quot;<span class="symbol">footer</span>&quot;&gt;&lt;/<span class="symbol">slot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">footer</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure><p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。<br>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。<br>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code> 中包裹默认插槽的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>任何一种写法都会渲染出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：<code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上 (只有一种例外情况)，这一点和已经废弃的 <code>slot attribute</code> 不同。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>自 <code>2.6.0</code> 起有所更新。已废弃的使用 <code>slot-scope attribute</code> 的语法在这里。<br>有时让插槽内容能够访问子组件中才有的数据是很有用的。<br>例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">user.lastName</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。<br>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 <code>attribute</code> 绑定上去：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">user.lastName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 <code>attribute</code> 被称为插槽 <code>prop</code>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 <code>prop</code> 的名字：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们选择将包含所有插槽 <code>prop</code> 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p><h3 id="独占默认插槽的缩写语法"><a href="#独占默认插槽的缩写语法" class="headerlink" title="独占默认插槽的缩写语法"></a>独占默认插槽的缩写语法</h3><p>在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 无效，会导致警告 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    slotProps is NOT available here</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="解构插槽-Prop"><a href="#解构插槽-Prop" class="headerlink" title="解构插槽 Prop"></a>解构插槽 Prop</h3><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="params">(slotProps)</span> &#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (单文件组件或现代浏览器)，你也可以使用 ES2015 解构来传入具体的插槽 prop，如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">person.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h2><p>2.6.0 新增<br>动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><p>2.6.0 新增<br>跟<code>v-on</code>和<code>v-bind</code>一样，<code>v-slot</code>也有缩写，即把参数之前的所有内容<code>(v-slot:)</code>替换为字符<code>#</code>。<br>例如，<code>v-slot:header</code>可以被重写为<code>#header</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="其它示例"><a href="#其它示例" class="headerlink" title="其它示例"></a>其它示例</h2><p>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 todo 作为一个插槽 prop 进行绑定：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    我们为每个 todo 准备了一个插槽，</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">v-bind:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这只是作用域插槽用武之地的冰山一角。想了解更多现实生活中的作用域插槽的用法，我们推荐浏览诸如 Vue Virtual Scroller、Vue Promised 和 Portal Vue 等库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue组件化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
</feed>
