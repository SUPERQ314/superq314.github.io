<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-09-23T07:39:18.722Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>compose和pipe函数</title>
    <link href="https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/compose%E5%92%8Cpipe%E5%87%BD%E6%95%B0/"/>
    <id>https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/compose%E5%92%8Cpipe%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-23T06:48:12.000Z</published>
    <updated>2022-09-23T07:39:18.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Compose函数</button></li><li class="tab"><button type="button" data-href="#super-2">Pipe函数</button></li><li class="tab"><button type="button" data-href="#super-3">链式调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>定义：为了便于连续执行方法，把调用传值整个过程封装成函数，即为compose函数。只需要告诉compose函数需要执行哪些方法，其会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// arguments</span></span><br><span class="line">    <span class="keyword">const</span> args = [].<span class="property">slice</span>.<span class="title function_">apply</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _result = num;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(var i = args.length - 1; i &gt;= 0; i—) &#123;</span></span><br><span class="line"><span class="comment">            _result = args[i](_result);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return _result; </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        <span class="keyword">return</span> args.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">res, cb</span>) =&gt;</span> <span class="title function_">cb</span>(res), num); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(addThree, addTwo, minusOne, multiplyTwo)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>和compose函数功能一样，执行方向相反</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>用promise组成链式调用（此处和面向对象的链式调用有所区别）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>reflect反射机制</title>
    <link href="https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/reflect%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/reflect%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-23T01:16:27.000Z</published>
    <updated>2022-09-23T10:24:55.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>MDN定义：<br>Reflect是一个内置的对象，用来提供方法去拦截JavaScript的操作。Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，你不能通过 <code>new</code>操作符去新建或者将其作为一个函数去调用Reflect对象。Reflect的所有属性和方法都是静态的。</p></blockquote><p>反射机制指的是程序在运行时能够获取自身的信息。js 中的 apply 就是反射机制。</p><p><strong>Reflect API 汇总</strong><br>Reflect 提供了一套用于操作对象的 API（静态方法）</p><table><thead><tr><th><strong>handler⽅法</strong></th><th><strong>默认设置调⽤</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>get</td><td>Reflect.get(target, name, receiver)</td><td>获得目标的身上某一特性的值</td></tr><tr><td>set</td><td>Reflect.set(target, name, value, receiver)</td><td>在目标上设定特性</td></tr><tr><td>has</td><td>Reflect.has(obj, name)</td><td>分辨一个目标是不是存有某一特性</td></tr><tr><td>deleteProperty</td><td>Reflect.deleteProperty(obj, name)</td><td>删掉目标上的特性</td></tr><tr><td>getProperty</td><td>Reflect.getPrototypeOf(obj)</td><td>获得特定目标原形的涵数</td></tr><tr><td>setProperty</td><td>Reflect.setPrototypeOf(obj, newProto)</td><td>设定或更改目标原形的涵数</td></tr><tr><td>isExtensible</td><td>Reflect.isExtensible(target)</td><td>分辨一个目标是不是可拓展（即是不是可以加上新的特性）</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions(target)</td><td>阻拦新特性加上到目标</td></tr><tr><td>getOwnPropertyDescriptor</td><td>Reflect.getOwnPropertyDescriptor(target, propertyKey)</td><td>获得给出特性的特性描述符</td></tr><tr><td>defineProperty</td><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>界定或改动一个目标的特性</td></tr><tr><td>ownKeys</td><td>Reflect.ownKeys()</td><td>回到由总体目标目标本身的特性键构成的二维数组</td></tr><tr><td>apply</td><td>Reflect.apply(func, thisArg, args)</td><td>对一个涵数开展启用实际操作，另外能够传到一个二维数组做为启用主要参数</td></tr><tr><td>construct</td><td>Reflect.construct(target, args)</td><td>对构造方法开展new实际操作，完成建立类的案例</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions()</td><td>阻拦新特性加上到目标</td></tr></tbody></table><p><strong>Reflect对象的作用&#x2F;优点</strong></p><ol><li>把实现反射机制的方法重新归结在一起并且简化操作，保持JS语意清晰和语法简单</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> k = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; [s]: <span class="number">1</span>, [k]: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// getOwnPropertyNames获取到String类型的key</span></span><br><span class="line"><span class="comment">// getOwnPropertySymbols获取到Symbol类型的key</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// 使用Reflect的话：</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o);</span><br></pre></td></tr></table></figure><ol start="2"><li>补充一些Object对象没有的方法（如Reflect.apply）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">…rest</span>)&#123;</span><br><span class="line">  consloe.<span class="title function_">log</span>(rest);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello:`</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="property">apply</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="attr">hello</span>: <span class="string">`小明`</span></span><br></pre></td></tr></table></figure><ol start="3"><li>让Object操作都变为函数行为，比如使用Reflect.has(obj, name)替换name in obj</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">`id`</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, <span class="string">`id`</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>proxy</title>
    <link href="https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/7newFeaturesofES/proxy/"/>
    <id>https://superq314.github.io/2022/09/23/frontEnd/3JavaScript/7newFeaturesofES/proxy/</id>
    <published>2022-09-23T01:14:37.000Z</published>
    <updated>2022-09-23T09:01:18.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Proxy是ES6中提供的新的API<br>proxy代理：在目标对象的前面设置一个拦截层，外界在访问这个对象的时候，必须经过拦截层。</p><blockquote><p>我们可以在拦截层做一些过滤或者是改写的操作。<br>语法<br><code>var proxy = new Proxy(target, handler);</code><br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中：</p></blockquote><ul><li>new Proxy() 表示生成一个 Proxy 实例</li><li>target 参数表示所要拦截的目标对象可以是一个object或者function</li><li>handler 参数也是一个对象，用来定制拦截行为;如果handler没有设置任何拦截，那就等同于直接通向原对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="Proxy" scheme="https://superq314.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>generator生成器</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/generator%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/generator%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2022-09-22T14:51:13.000Z</published>
    <updated>2022-09-23T07:38:59.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>生成器generator<br>　　生成器是一种返回迭代器的函数，通过function关键字后的星号(<em>)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格<br>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （iterator ）对象。<br>或者如果用的是 yield</em>（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行） 移交代码控制权<br>可以视作一个可以暂停和恢复执行的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">createIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>　　在这个示例中，createlterator()前的星号表明它是一个生成器；yield关键字也是ES6的新特性，可以通过它来指定调用迭代器的next()方法时的返回值及返回顺序。生成迭代器后，连续3次调用它的next()方法返回3个不同的值，分别是1、2和3。生成器的调用过程与其他函数一样，最终返回的是创建好的迭代器<br>　　生成器函数最有趣的部分是，每当执行完一条yield语句后函数就会自动停止执行。举个例子，在上面这段代码中，执行完语句yield 1之后，函数便不再执行其他任何语句，直到再次调用迭代器的next()方法才会继续执行yield 2语句。生成器函数的这种中止函数执行的能力有很多有趣的应用<br>　　使用yield关键字可以返回任何值或表达式，所以可以通过生成器函数批量地给迭代器添加元素。例如，可以在循环中使用yield关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在此示例中，给生成器函数createlterator()传入一个items数组，而在函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个yield语句循环都会停止；每次调用迭代器的next()方法，循环会继续运行并执行下一条yield语句<br>　　生成器函数是ES6中的一个重要特性，可以将其用于所有支持函数使用的地方</p><h2 id="【使用限制】"><a href="#【使用限制】" class="headerlink" title="【使用限制】"></a>【使用限制】</h2><p>　　yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从字面上看，yield关键字确实在createlterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误</p><h2 id="【生成器函数表达式】"><a href="#【生成器函数表达式】" class="headerlink" title="【生成器函数表达式】"></a>【生成器函数表达式】</h2><p>　　也可以通过函数表达式来创建生成器，只需在function关键字和小括号中间添加一个星号(*)即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在这段代码中，createlterator()是一个生成器函数表达式，而不是一个函数声明。由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间。此外，这个示例基本与前例相同，使用的也是for循环<br>　　[注意]不能用箭头函数来创建生成器</p><h2 id="【生成器对象的方法】"><a href="#【生成器对象的方法】" class="headerlink" title="【生成器对象的方法】"></a>【生成器对象的方法】</h2><p>　　由于生成器本身就是函数，因而可以将它们添加到对象中。例如，在ES5风格的对象字面量中，可以通过函数表达式来创建生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">createIterator</span>: <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">yield</span> items[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　也可以用ES6的函数方法的简写方式来创建生成器，只需在函数名前添加一个星号(*)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">yield</span> items[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　这些示例使用了不同于之前的语法，但它们的功能实际上是等价的。在简写版本中，由于不使用function关键字来定义createlterator()方法，因此尽管可以在星号和方法名之间留白，但还是将星号紧贴在方法名之前</p><h2 id="【状态机】生成器的一个常用功能是生成状态机"><a href="#【状态机】生成器的一个常用功能是生成状态机" class="headerlink" title="【状态机】生成器的一个常用功能是生成状态机"></a>【状态机】生成器的一个常用功能是生成状态机</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = <span class="title function_">state</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;C&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="应用场景：通过yield-实现非线性迭代"><a href="#应用场景：通过yield-实现非线性迭代" class="headerlink" title="应用场景：通过yield*实现非线性迭代"></a>应用场景：通过yield*实现非线性迭代</h2><p>yield关键字后面可以跟随另一个generator对象或其他可迭代对象。<br>可以利用这个特性实现非线性结构的遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘a1’</span><br><span class="line">  <span class="keyword">yield</span> ‘a2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘b1’</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">a</span>()</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">yield</span> ‘b2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="title function_">b</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b1 a1 a2 1 2 b2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>iterator迭代器</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-09-22T14:50:35.000Z</published>
    <updated>2022-09-23T07:38:58.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Iterator迭代器的本质</strong></p><pre><code>迭代器对象是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</code></pre><p><strong>Iterator迭代器语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。<br>只要拥有了该属性，就能够用迭代器的方式进行遍历。</p></blockquote><p><strong>数组的Symbol.iterator属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">// 获取数组中的迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>Iterator接口</strong><br>iterator必须实现next方法，该方法每次被调用时返回一个迭代器结果。<br>next()：被调用时返回一个iteratorResult对象<br>return()：被调用时返回一个iteratorResult对象，通常在调用者希望提前结束迭代时调用<br>throw()：被调用时返回一个iteratorResult对象，通常在调用者检测到错误时被调用</p><p><strong>Iterator迭代器协议</strong></p><pre><code>对象必须提供一个next()，执行该方法后 =&gt; 要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性    value属性：迭代未完成时，返回当前位置的元素；迭代完成后，返回迭代器返回值或者缺省    done属性：一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()    对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</code></pre><p><strong>遍历过程：</strong></p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><p><strong>Iterator迭代器的作用：</strong></p><ol><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of使用</li></ol><p><strong>原生具备 Iterator 接口的数据结构如下：</strong></p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 类数组对象</li><li>DOM中的NodeList 类数组对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/%E8%B7%A8%E5%9F%9F/</id>
    <published>2022-09-22T14:47:01.000Z</published>
    <updated>2022-09-23T07:39:01.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>跨域问题的解决方式<br>1、通过Jsonp<br>2、Document.domain + Iframe跨域<br>3、Iocation.hash + Iframe跨域<br>4、Window.name+Iframe跨域<br>5、PostMessage跨域<br>6、跨域资源共享（CORS）<br>7、nginx代理跨域<br>8、nodeJavaScripr中间代理跨域<br>9、WebSocket协议跨域</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/jQuery/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/jQuery/</id>
    <published>2022-09-22T14:46:36.000Z</published>
    <updated>2022-09-23T07:38:57.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jQuery<br>sass、less &#x3D;&gt; CSS预处理器<br>less：动态样式语言，给CSS赋予动态语言特性<br>动态语言特性：变量、继承、嵌套</p><p>跨域原因：<br>由于前后端分离 &#x3D;&gt; 前后端域名不一致 &#x3D;&gt; 出现跨越访问问题<br>同源策略 &#x3D;&gt; 只有协议 + 主机名 + 端口号相同（允许访问）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/ajax/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/ajax/</id>
    <published>2022-09-22T14:46:20.000Z</published>
    <updated>2022-09-23T07:38:59.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AJAX &#x3D;&#x3D;&gt; 创建快速动态网页 &#x3D;&#x3D;&gt; 网页异步更新<br>核心：XMLHttpRequest对象<br>创建过程：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest) &#123;xhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// code for IE5,IE6  </span></span><br><span class="line">  xhttp = <span class="keyword">new</span> <span class="type">ActiveXobject</span>(“Microsoft.XMLHTTP”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax使用过程（5个步骤）<br>1、创建XMLHTTPRequest对象<br>2、使用open方法创建http请求，并设置请求地址xhr.open(get&#x2F;post, url, asynchronous,true异步, false同步)<br>3、设置发送的数据，用send发送请求<br>4、注册事件（给Ajax设置事件）<br>5、获取响应并更新页面</p><p>AJAX的XMLHttpRequest对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">new XMLHttpRequest()</td><td>创建新的XMLHttpRequest对象</td></tr><tr><td align="center">abort()</td><td>取消当前请求</td></tr><tr><td align="center">getAllResponseHeaders()</td><td>返回头部信息</td></tr><tr><td align="center">getResponseHeader()</td><td>返回特定的头部信息</td></tr><tr><td align="center">open(method, url, async, user, psw)</td><td>method：规定请求类型GET或POST<br />url：文件位置<br />async：true(异步)或false(同步)<br />user：可选的用户名<br />psw：可选的密码</td></tr><tr><td align="center">send()</td><td>将请求发送到服务器，用于GET 请求</td></tr><tr><td align="center">send(string)</td><td>将请求发送到服务器，用于POST 请求</td></tr><tr><td align="center">setRequestHeader()</td><td>向要发送的报头添加标签&#x2F;值对</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>class的继承</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2022-09-22T14:38:38.000Z</published>
    <updated>2022-09-23T08:59:58.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>class的继承<br>JavaScript 实现继承是件麻烦事，构造函数继承有加上原型上的函数不能复用的问题；原型链继承又存在引用值属性的修改不独立的问题；组合继承又存在两次调用构造函数的问题，寄生组合继承，写起来又太麻烦了</p><p>class的继承围绕三点进行展开描述：extends实现继承，super()引用父类的构造函数，多重继承。<br>1、如何实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>通过关键字<span class="keyword">extends</span>实现继承。具体操作步骤如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitename</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">present</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我喜欢&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sitename</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">present</span>() + <span class="string">&#x27;, 它创建了 &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; 年。&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> noob = <span class="keyword">new</span> <span class="title class_">Runoob</span>(<span class="string">&quot;菜鸟教程&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>子类必须在constructor方法中调用super方法<br>为什么必须要调用super方法呢？<br>这是因为这里的继承是先塑造父类，再塑造子类。也就是先将父类的东西都拿过来之后，再进行子类的添加。而super负责的就是将父类的东西拿过来。所以必须先调用super。</li><li>调用super之后才能使用this。也就是说在子类构造函数constructor里面，super函数要放在最上面。<br>为什么要这样呢？<br>刚才提到过，class的继承是先将父类拿过来再进行子类的添加，之前在讲借用构造函数实现继承的时候也提到过，如果想要给自身添加属性和方法，需要在调用call或者apply之后添加。否则如果存在同名属性，后面的会覆盖前面的。这里其实也是同样的道理。<br>2、super<br>class里面的super有两种使用方式，一种是当方法用，一种是当对象用。</li><li>当方法用<br>当方法用就像上面提到的，在constructor里面调用，负责将父类的实例属性拿过来。这个时候，super里面的this指向的是子类。<br>为什么这样呢？其实和借用构造函数实现继承是一样的，子类继承超类的实例属性时，就是通过call或者apply在子类调用超类构造函数。这个时候，this自然指向的就是子类。<br>还要注意一点 的是，其实上面也提到了，当方法用的时候，super必须放到constructor构造函数的最上层</li><li>当对象用<br>上一点说了，当方法用是为了将父类的实例属性继承过来(其实就是复制一份过来)。实例属性是拿到了，但方法呢，比如说有时候子类的方法想要调用父类的某个方法，这个时候要如何做？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;speak&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">speak</span>() <span class="comment">// speak</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">a.<span class="title function_">sayName</span>()</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">speak</span>()</span><br></pre></td></tr></table></figure><p>这个时候，super作为对象的所用就体现出来了，通过它可以调用父类的方法(包括静态方法)。<br>注意，不同类型的方法要在不同类型的方法里面调用。有点绕，其实就是子类的静态方法里面通过super只能调用父类的静态方法，不能调用父类的原型方法。同理，子类的原型方法通过super也只能调用父类的原型方法，不能调用父类的静态方法。<br>有点像组合继承，super方法就是借用构造函数继承，继承实例属性，super对象就是原型链继承，继承原型上的属性和方法。也就是说super对象是无法访问父类的实例属性的。<br>那么还有一个问题，通过super调用父类的方法，那么该方法内的this指向的是谁呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857835921.png" alt="1663857835921"><br>结果就是，this指向的是当前类(子类)的实例。所以我们通过super对某个属性进行修改，修改的就是子类实例的属性。<br>3、多重继承<br>有些面向对象编程语言是支持多重继承(即一个子类继承多个父类)，如c++， py。java不支持多继承，但可以通过实现多接口或者内部类的方式实现类似的效果。es6的class继承本质上还是基于原型链的继承，所以也是不支持多继承的。但就像java那样，我们也可以通过其他方式达到相同或者类似的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;说话&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;19&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进食&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="comment">// 多重继承 一个子类继承多个父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">...mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        <span class="comment">// 拷贝实例属性</span></span><br><span class="line">        <span class="title function_">copyProperties</span>(<span class="variable language_">this</span>, <span class="keyword">new</span> <span class="title function_">mixin</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>, mixin) <span class="comment">// 拷贝静态属性</span></span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>.<span class="property"><span class="keyword">prototype</span></span>, mixin.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 拷贝原型属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mix</span>&#125;<span class="keyword">function</span> <span class="title function_">copyProperties</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="comment">// Reflect.ownKeys 返回所有属性key</span></span><br><span class="line">  <span class="comment">// Object.keys 返回属性key，不包括不可枚举属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;constructor&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;prototype&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// Object.getOwnPropertyDescriptor 返回指定对象上一个自有属性对应的属性描述符。</span></span><br><span class="line">      <span class="comment">// 自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性</span></span><br><span class="line">      <span class="comment">// 属性描述符指的是configurable、enumerable、writable、value这些</span></span><br><span class="line">      <span class="keyword">const</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, key)</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, desc)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;<span class="keyword">class</span> <span class="title class_">Other</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixin</span>(<span class="title class_">Animal</span>, <span class="title class_">Person</span>) &#123;&#125;<span class="keyword">const</span> oo = <span class="keyword">new</span> <span class="title class_">Other</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oo)</span><br></pre></td></tr></table></figure><p><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857864873.png" alt="1663857864873"><br>通过以上方式，也可以间接地实现类似多重继承的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="继承" scheme="https://superq314.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="class" scheme="https://superq314.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%B1%BB/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%B1%BB/</id>
    <published>2022-09-22T14:31:56.000Z</published>
    <updated>2022-09-23T09:01:49.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在es5中主要是通过构造函数方式和原型方式来定义一个类<br>在es6中可以通过class来定义类。<br>一个类只能拥有一个名为”constructor”构造函数，不能出现多个；<br>如果没有定义”constructor”构造函数，class会默认添加一个空的“constructor”构造函数。</p><h3 id="1、class类必须进行new调用，不能直接执行"><a href="#1、class类必须进行new调用，不能直接执行" class="headerlink" title="1、class类必须进行new调用，不能直接执行"></a>1、class类必须进行new调用，不能直接执行</h3><p>使用new调用类的构造函数会执行如下操作。<br>1.在内存中创建一个新对象；<br>2.这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性；<br>3.构造函数内部的this被赋值为这个新对象（即this指向新对象）；<br>4.执行构造函数内部的代码（给新对象添加属性）；<br>5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；</p><h3 id="2、class类不存在变量提升"><a href="#2、class类不存在变量提升" class="headerlink" title="2、class类不存在变量提升"></a>2、class类不存在变量提升</h3><h3 id="3、class类无法遍历其实例原型链上的属性和方法"><a href="#3、class类无法遍历其实例原型链上的属性和方法" class="headerlink" title="3、class类无法遍历其实例原型链上的属性和方法"></a>3、class类无法遍历其实例原型链上的属性和方法</h3><p>不可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest2</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// [ ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">// [&quot;constructor&quot;,&quot;newTest&quot;,&quot;newTest2&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="4、new-target属性"><a href="#4、new-target属性" class="headerlink" title="4、new.target属性"></a>4、new.target属性</h3><p>es6为new命令引入了一个new.target属性，它会返回new命令作用于的那个构造函数。<br>如果不是通过new调用或Reflect.construct()调用的，new.target会返回undefined</p><h3 id="5、class类有static静态方法"><a href="#5、class类有static静态方法" class="headerlink" title="5、class类有static静态方法"></a>5、class类有static静态方法</h3><p>static静态方法只能通过类调用，不会出现在实例上；<br>静态方法包含 this 关键字，这个 this 指的是类，而不是实例<br>static声明的静态属性和方法都可以被子类继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">baz</span>(); <span class="comment">// 此处的this指向类</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 不会出现在实例中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">bar</span>() <span class="comment">// undefined</span></span><br><span class="line">foo.<span class="title function_">baz</span>() <span class="comment">// world</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">bar</span>() <span class="comment">// this Foo hello </span></span><br></pre></td></tr></table></figure><p>getter 与 setter <br>在 class 内部可以使用 get 与 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (test) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = test || <span class="string">&#x27;默认值&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    get prop () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">test</span></span><br><span class="line">    &#125;</span><br><span class="line">    set prop (value) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setter prop value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 1</span></span><br><span class="line">p.<span class="property">prop</span> = <span class="string">&#x27;2&#x27;</span> <span class="comment">// setter prop value: 2</span></span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>默认严格模式<br>内部定义inside<br>立即执行<br>二次声明<br>实例无法调用static<br>static this指向类<br>继承包含static<br>Class内部只有静态方法，没有静态属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="class" scheme="https://superq314.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>尾调用</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/%E5%B0%BE%E8%B0%83%E7%94%A8/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/%E5%B0%BE%E8%B0%83%E7%94%A8/</id>
    <published>2022-09-22T13:59:27.000Z</published>
    <updated>2022-09-23T08:48:02.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>定义：在执行某个函数时，如果最后一步是一个函数调用，并且被调用函数的返回值直接被函数返回，被称为尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>();<span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下两种情况，都不属于尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line"><span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内存中形成一个”调用记录”，又称”调用帧”，保存调用位置和内部变量等信息。</p><ol><li>函数A内部调用函数B，那么在A的调用记录上方，会形成一个B的调用记录。</li><li>等到B运行结束，将结果返回到函数A，B的调用记录才会消失。</li><li>如果函数B内部还调用了函数C，那还有一个C的调用记录栈，以此类推。</li><li>所有的调用记录形成一个”调用栈”。<br><img src="/image/%E5%B0%BE%E8%B0%83%E7%94%A8/1663855333356.png" alt="1663855333356"><br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。<br>尾调用的要求</li><li>尾调用不需要访问当前stackframe中的变量，也就是没有闭包。</li><li>返回到尾调用处时，不用再做其他事情。</li><li>尾调用的返回值，直接返回给调用它所在函数的调用者。</li></ol><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p><blockquote><p>因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>arguments：返回调用时函数的参数。</li><li>func.caller：返回调用当前函数的那个函数。<br>严格模式下开启尾调用优化，函数的调用栈会改写，从而会禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="函数式编程" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="尾调用" scheme="https://superq314.github.io/tags/%E5%B0%BE%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>symbol</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/symbol/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/symbol/</id>
    <published>2022-09-22T13:47:38.000Z</published>
    <updated>2022-09-23T09:00:55.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Symbol<br>由于symbol值是唯一的，可以避免<strong>为对象添加属性时 属性名产生冲突</strong>。</p><p>共享Symbol<br>Symbol.for()：在不同的地方使用同一个symbol，用来当作不同对象的唯一标识符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">[uid]:<span class="string">&quot;12345&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[uid]);<span class="comment">// &quot;12345&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid);<span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid === uid2);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[uid2]);<span class="comment">// &quot;12345&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid2);<span class="comment">// Symbol(uid)</span></span><br></pre></td></tr></table></figure><p>SymbolkeyFor()：查找和某个symbol关联的key值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid));<span class="comment">// &quot;uid&quot;</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid2));<span class="comment">// &quot;uid&quot;</span></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="title class_">Symbol</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid3));<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ObjectgetOwnPropertySymbols()：查找对象的symbol属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;[id]:<span class="string">&#x27;123&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> symbols =0bject.<span class="title function_">getOwnPropertySymbols</span>(obiect);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbols.<span class="property">length</span>);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbols[<span class="number">0</span>]);<span class="comment">// Symbol(id)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[symbols[<span class="number">0</span>]]);<span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>es6的内置symbol<br>es6内置了11个symbol，叫well-known symbol,它们都是Symbol函数的属性，指向语言内部使用的方法或属性。通过它们可以更改语言的原生行为。<br><img src="/image/symbol/1663854576292.png" alt="1663854576292"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="Symbol" scheme="https://superq314.github.io/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>模板字面量</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/</id>
    <published>2022-09-22T13:43:51.000Z</published>
    <updated>2022-09-23T08:57:22.052Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>定义：允许嵌入表达式的字符串字面量，可以使用多行字符串和字符串插值功能。可以保留反引号内的空格和换行符。</p><blockquote><p>开始和结尾的空格换行符可以通过trim方法去除</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">hello world`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)<span class="comment">// \nhello world</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>())<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><blockquote><p>严格意义上来说，模板字面量不是字符串，而是一种特殊的JavaScript表达式。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line">tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiLineStr = <span class="string">&#x27;&#x27;</span> + </span><br><span class="line">  <span class="string">`&lt;pre&gt;&#x27; + </span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;sb&quot;</span>&gt;<span class="title class_">This</span> is&lt;/code&gt;<span class="string">` +</span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;sb&quot;</span>&gt;a string&lt;/code&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">  `    &lt;code class=&quot;sb&quot;&gt;with multiple&lt;/code&gt;&#x27;</span> + </span><br><span class="line">  <span class="string">`    &lt;code class=&quot;sb&quot;&gt;lines&lt;/code&gt;&#x27; + </span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;p&quot;</span>&gt;;&lt;/code&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">  `&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>支持所有合法的JavaScript表达式，包括函数调用等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;getName()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>插值表达式支持嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classes = <span class="string">`header <span class="subst">$&#123; isLargeScreen()</span></span></span><br><span class="line"><span class="subst"><span class="string">? <span class="string">``</span></span></span></span><br><span class="line"><span class="subst"><span class="string">: <span class="string">`icon-<span class="subst">$&#123;(isCollapsed? <span class="string">&#x27;expander`: &#x27;</span>collapser<span class="string">&#x27;)&#125;`&#125;`;</span></span></span></span></span></span><br></pre></td></tr></table></figure><h3 id="模板字面量-tagged-template"><a href="#模板字面量-tagged-template" class="headerlink" title="模板字面量:tagged template"></a>模板字面量:tagged template</h3><p>最前面可以跟一个函数，这个函数叫模板字符串的tag。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">literals, ...substitutions</span>) &#123;</span><br><span class="line">    <span class="comment">// return a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板字面量:tagged template示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="string">&#x27;Mike&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTag</span>(<span class="params">strings, personExp,ageExp</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// &quot;that &quot;</span></span><br><span class="line">    <span class="keyword">let</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// &quot; is a &quot;</span></span><br><span class="line">    <span class="comment">// 最后还有一项，不过它的值是空字符串 &#x27; &#x27;</span></span><br><span class="line">    <span class="comment">// let str2 =strings[2];</span></span><br><span class="line">    <span class="keyword">let</span> ageStr;</span><br><span class="line">    <span class="keyword">if</span> (ageExp &gt; <span class="number">99</span>) &#123;</span><br><span class="line">        ageStr = <span class="string">&#x27;centenarian&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ageStr = <span class="string">&#x27;youngster&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str0 + personExp + str1 + ageStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> output = myTag<span class="string">`that <span class="subst">$&#123;person&#125;</span> is a <span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// that Mike is a youngster</span></span><br></pre></td></tr></table></figure><h3 id="模板字面量-原始字符串值-raw-value"><a href="#模板字面量-原始字符串值-raw-value" class="headerlink" title="模板字面量:原始字符串值(raw value)"></a>模板字面量:原始字符串值(raw value)</h3><p>tag函数的第一个参数，还有一个raw属性，它的值是模板字符串被转义之前的值，也可以使用内置的 String.raw方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message1 =<span class="string">`Multiline\nstring`</span>;</span><br><span class="line"><span class="title class_">Let</span> message2 = <span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Multiline\nstring`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message1);<span class="comment">// &quot;Multiline</span></span><br><span class="line">                        <span class="comment">// string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message2);<span class="comment">// &quot;Multilinel\nstring&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="模板字面量" scheme="https://superq314.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Modules</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/Modules/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/Modules/</id>
    <published>2022-09-22T13:31:55.000Z</published>
    <updated>2022-09-23T09:02:18.704Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Modules语法-amp-特性"><a href="#Modules语法-amp-特性" class="headerlink" title="Modules语法&amp;特性"></a>Modules语法&amp;特性</h2><p>模块功能主要由两个命令构成：<code>export</code>和 <code>import</code>。<br>**<code>export</code>**命令：规定模块的对外接口<br>**<code>import</code>**命令：输入其他模块提供的功能</p><p>export命令</p><p>一个modules模块就是一个独立的文件。该文件内部的所有变量，外部无法获取到。</p><blockquote><p>如果希望外部能够读取模块内部的某个变量，就必须使用<strong>export</strong>关键字输出该变量。</p></blockquote><p>案例如下，一个JS文件使用<strong>export</strong>命令输出变量。</p><p>写法一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>上面代码是<strong>profile.js</strong>文件，保存了用户信息。</p><blockquote><p>ES6 将其视为一个模块，里面用<strong>export</strong>命令对外部输出了三个变量。</p></blockquote><p>写法二</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span>  &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure><p>在<strong>export</strong>命令后面，使用大括号指定所要输出的一组变量。</p><blockquote><p>与写法一（直接放置在<strong>var</strong>语句前）等价</p></blockquote><blockquote><p>但是应该优先考虑使用写法二。</p></blockquote><blockquote><p>因为可以在脚本尾部，直接知道输出了哪些变量。</p></blockquote><p><strong>as</strong>关键字重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<strong>export</strong>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<strong>import</strong>命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>import</strong>命令，用于加载<strong>profile.js</strong>文件，并从中输入变量。</p><p><strong>import</strong>命令接受一对大括号，里面指定要从其他模块导入的变量名。</p><p>大括号里面的变量名，必须与被导入模块（<strong>profile.js</strong>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<strong>import</strong>命令要使用<strong>as</strong>关键字，将输入的变量重命名。</p><p><code>import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;</code></p><p><img src="/image/Modules/1663853855311.png" alt="1663853855311"></p><p><img src="/image/Modules/1663853861302.png" alt="1663853861302"></p><p><img src="/image/Modules/1663853869366.png" alt="1663853869366"></p><p><img src="/image/Modules/1663853876561.png" alt="1663853876561"></p><p><img src="/image/Modules/1663853881292.png" alt="1663853881292"></p><p><img src="/image/Modules/1663853886119.png" alt="1663853886119"></p><h2 id="Modules特性"><a href="#Modules特性" class="headerlink" title="Modules特性"></a>Modules特性</h2><ul><li>以接口方式曝露，采用引用的方式;</li><li>Module中也可以import</li><li>模块中this是无意义，且模块单独一作用域，外部不可见</li><li>同一个模块被引用多次，只执行一次</li></ul><h2 id="Modules加载机制"><a href="#Modules加载机制" class="headerlink" title="Modules加载机制"></a>Modules加载机制</h2><p>1、异步加载 async</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对于type=module的时候，默认异步加载 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载完成，渲染引擎就会中断渲染立即执行。此外，执行完成后，再恢复渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、延迟加载 defer</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.is&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Modules错误范例和正确实践"><a href="#Modules错误范例和正确实践" class="headerlink" title="Modules错误范例和正确实践"></a>Modules错误范例和正确实践</h2><p>Modules正确实践</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a, b&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>错误案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="Modules模块" scheme="https://superq314.github.io/tags/Modules%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>内容布局方式-rem适配布局</title>
    <link href="https://superq314.github.io/2022/09/16/frontEnd/2CSS/%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/"/>
    <id>https://superq314.github.io/2022/09/16/frontEnd/2CSS/%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/</id>
    <published>2022-09-16T02:31:18.000Z</published>
    <updated>2022-09-23T08:23:31.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rem适配布局——[混合布局]<br>rem是CSS的长度单位，相当于元素对的font-size的相对值<br>假如</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size: 20px; </span><br><span class="line">&#125;</span><br><span class="line">=<span class="language-ruby">=&gt; 1rem = 20px</span></span><br></pre></td></tr></table></figure><p>rem会随着设备的大小变化而发生相应的改变<br>解决了流式布局和flex布局不能变化高度的问题</p><ol><li>rem + 媒体查询技术<br>&#x3D;&#x3D;&gt; 实现元素大小动态变化</li><li>rem + flexible.is（淘宝技术）<br>将页面的一行分成10份，可以快速布局<br>&#x3D;&#x3D;&gt; 实现元素大小动态变化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="CSS" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS/"/>
    
    
    <category term="rem适配布局" scheme="https://superq314.github.io/tags/rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Html-标签粗解</title>
    <link href="https://superq314.github.io/2022/09/16/frontEnd/1Html/Html-%E6%A0%87%E7%AD%BE%E7%B2%97%E8%A7%A3/"/>
    <id>https://superq314.github.io/2022/09/16/frontEnd/1Html/Html-%E6%A0%87%E7%AD%BE%E7%B2%97%E8%A7%A3/</id>
    <published>2022-09-16T01:57:22.000Z</published>
    <updated>2022-09-23T07:29:38.010Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>&lt;a&gt;&lt;/a&gt;</code><br>作用：</p><ul><li>另一个文档</li><li>文档内部</li><li>Email地址</li><li>电话号码</li></ul><p>属性</p><ul><li>href</li><li>target</li><li>download</li><li>hreflang</li><li>rel</li><li>rev</li><li>type</li><li>referrerpolicy</li></ul><p>target中属性值</p><ul><li>_self</li><li>_blank</li><li>_parent</li><li>_top</li></ul><p>举例：<br>创建锚点<br><code>&lt;a href=&quot;#&quot;&gt;×××&lt;/a&gt;</code><br>链接Email地址<br><code>&lt;a href=&quot;mailto:1078857679@qq.com&quot;&gt;×××&lt;/a&gt;</code><br>链接电话<br><code>&lt;a href=&quot;tel:15651005256&quot;&gt;×××&lt;/a&gt;</code><br>文件下载<br><code>&lt;a href=&quot;/keyboard-shortcuts.pdf&quot; download&gt;×××&lt;/a&gt;</code><br><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code></p><ul><li>引用内容</li><li>属性<ul><li>cite<br><code>&lt;em&gt;&lt;/em&gt;</code><br>强调，需要用户着重阅读的内容</li></ul></li><li>默认斜体</li><li>可以嵌套<br><code>&lt;strong&gt;&lt;/strong&gt;</code><br>严重&#x2F;重要&#x2F;紧急的内容</li><li>标题、警告、注意事项、指示性内容</li><li>默认粗体</li><li>可以嵌套<br><code>&lt;span&gt;&lt;/span&gt;</code><br>无任何特殊含义</li><li>行内容器</li><li>样式<br><code>&lt;img&gt;</code><br>图像<br>属性</li><li>src</li><li>alt</li><li>width</li><li>height</li><li>srcset    宽度描述符</li><li>sizes<br>插入图片<br>picture容器 + source<br>source属性</li><li>srcset</li><li>type</li><li>sizes</li><li>media<br>图片热点<br>area属性</li><li>download</li><li>hreflang</li><li>rel</li><li>target</li><li>type</li><li>referrerpolicy<br><code>&lt;video&gt;&lt;/video&gt;</code><br>视频、影片、带字幕的音频<br>属性</li><li>src</li><li>width</li><li>height</li><li>poster</li><li>preload</li><li>autoplay</li><li>loop</li><li>muted</li><li>controls</li><li>crossorigin<br>内嵌标签<br>source</li><li>src</li><li>type<br>track</li><li>kind<ul><li>subtitles</li><li>captions</li><li>descriptions</li><li>chapters</li><li>metadata</li></ul></li><li>srcset</li><li>srclang</li><li>label</li><li>default<br><code>&lt;audio&gt;&lt;/audio&gt;</code><br>音频<br>属性</li><li>src</li><li>preload</li><li>autoplay</li><li>loop</li><li>muted</li><li>controls</li><li>crossorigin<br><code>&lt;iframe&gt;&lt;/iframe&gt;</code><br>内嵌的浏览上下文<br>另一个HTML页面嵌入到当前页面中<br>属性</li><li>src</li><li>width</li><li>height</li><li>name</li><li>sandbox<ul><li>allow-forms</li><li>allow-pointer-lock</li><li>allow-popups</li><li>allow-presentation</li><li>allow-same-origin</li><li>allow-scripts</li><li>allow-top-navigation<br><code>&lt;form&gt;&lt;/form&gt;</code><br>label<br>input<br>fieldset<br>select<br>textarea<br>button<br>output<br>object<br>meter<br>progressimg</li></ul></li><li>label<br>表单控件的标题</li><li>select<br>列表选择器</li><li>不加      默认单选</li><li>multiple  多选模式配置</li><li>size&#x3D;”4”  单选（四选一）</li></ul><p>状态禁用<br>选择器禁用<code>&lt;select disabled&gt;</code><br>选项禁用<code>&lt;option disabled&gt;</code><br>选项组禁用<code>&lt;optgroup disabled&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Html" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html/"/>
    
    
    <category term="Html" scheme="https://superq314.github.io/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="https://superq314.github.io/2022/09/14/frontEnd/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://superq314.github.io/2022/09/14/frontEnd/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-14T05:11:25.000Z</published>
    <updated>2022-09-23T10:25:35.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="语义话的目的是什么？"><a href="#语义话的目的是什么？" class="headerlink" title="语义话的目的是什么？"></a>语义话的目的是什么？</h3><p>语义化的主要目的可以概括为用正确的标签做正确的事</p><p>HTMl语义化可以让页面的内容结构化，以便于浏览器解析和搜索引擎解析，<br>并且提高了代码的可读性便于代码维护，</p><h3 id="HTML5新增元素"><a href="#HTML5新增元素" class="headerlink" title="HTML5新增元素"></a>HTML5新增元素</h3><p>Canvas绘图以及SVG绘图。<br>拖放（Drag and drop）API<br>语义化标签（header、nav、footer、article、section）<br>音频、视频（audio、video）API<br>地理定位（Geolocation）<br>本地离线存储（localStorage）,长期存储数据，关闭浏览器后不丢失。<br>会话储存（sessionStorage）,数据在关闭浏览器后自动删除。<br>表单控件（calendar、date、time、email、url、search）</p><h3 id="cookie与sessionStorage和localStorage的区别"><a href="#cookie与sessionStorage和localStorage的区别" class="headerlink" title="cookie与sessionStorage和localStorage的区别"></a>cookie与sessionStorage和localStorage的区别</h3><ul><li>保存方式<ul><li>cookie存放在客户的浏览器上。</li><li>session都在客户端中保存，不参与服务器通讯。</li></ul></li><li>生命周期<ul><li>cookie可设置失效时间</li><li>localStorage除非手动清除否则永久保存</li><li>sessionStorage关闭当前页面或浏览器后失效</li></ul></li><li>存储的大小<ul><li>cookie 4kb左右</li><li>session 5M</li></ul></li><li>易用性<ul><li>cookie需自己封装</li><li>session可以接受原生接口</li></ul></li></ul><p>因为cookie每次请求都会携带在http请求中,所以它的主要用来识别用户登录,localStorage可以用来跨页面传参,sessionStorage可以用来保留一些临时数据。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS有哪些基本的选择器，执行先后顺序？"><a href="#CSS有哪些基本的选择器，执行先后顺序？" class="headerlink" title="CSS有哪些基本的选择器，执行先后顺序？"></a>CSS有哪些基本的选择器，执行先后顺序？</h3><p>id选择器 &#x3D;&gt; #myId {}<br>类选择器 &#x3D;&gt; .myClass {}<br>标签选择器 &#x3D;&gt; p,h1 {}<br>后代选择器 &#x3D;&gt; div h1 {}<br>子选择器 &#x3D;&gt; div&gt;h1 {}<br>兄弟选择器(所有的兄弟) &#x3D;&gt; ul~h1 {}<br>相邻兄弟选择器 &#x3D;&gt; ul+h1 {}<br>属性选择器 &#x3D;&gt; li[name&#x3D;’sss’] {}<br>伪类选择器 &#x3D;&gt; h1:hover {}<br>伪元素选择器 &#x3D;&gt; h1::before{}<br>通配符选择器* &#x3D;&gt; * {}</p><p>!important&gt;内联样式（非选择器）&gt;ID选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器（*）</p><h3 id="垂直水平居中方式有哪些？"><a href="#垂直水平居中方式有哪些？" class="headerlink" title="垂直水平居中方式有哪些？"></a>垂直水平居中方式有哪些？</h3><h3 id="常用布局方式有哪些？什么是盒模型？"><a href="#常用布局方式有哪些？什么是盒模型？" class="headerlink" title="常用布局方式有哪些？什么是盒模型？"></a>常用布局方式有哪些？什么是盒模型？</h3><h3 id="常用的块元素与行内元素有哪些？有什么特征"><a href="#常用的块元素与行内元素有哪些？有什么特征" class="headerlink" title="常用的块元素与行内元素有哪些？有什么特征"></a>常用的块元素与行内元素有哪些？有什么特征</h3><p>块元素：div、h1~h6、ul、li、table、p、br、form。<br>特征：独占一行，换行显示，可以设置宽高，可以嵌套块和行</p><p>行内元素：span、a、img、textarea、select、option、input。<br>特征：只有在行内显示，内容撑开宽、高，不可以设置宽、高（img、input、textarea等除外）。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>父级div定义overflow:hidden（如果父级元素有定位元素超出父级，超出部分会隐藏，）<br>给浮动元素父级增加标签（由于新增标签会造成不必要的渲染，不建议使用）<br>伪元素清除浮动：给浮动元素父级增加 .clearfix::after（content: ‘’; display: table;<br>clear: both;）（不会新增标签，不会有其他影响，）</p><h3 id="CSS3新特征"><a href="#CSS3新特征" class="headerlink" title="CSS3新特征"></a>CSS3新特征</h3><p>圆角（border-radius）<br>阴影（box-shadow）<br>文字特效(text-shadow)<br>线性渐变（gradient）<br>变换(transform)<br>更多的CSS选择器<br>更多背景设置（background）<br>色彩模式（rgba）<br>伪元素（::selection）<br>媒体查询（@media）<br>多栏布局（column）<br>图片边框（border-image）</p><h3 id="CSS中有哪些长度单位？"><a href="#CSS中有哪些长度单位？" class="headerlink" title="CSS中有哪些长度单位？"></a>CSS中有哪些长度单位？</h3><p>绝对长度单位：px<br>百分比: %<br>相对父元素字体大小单位: em<br>相对于根元素字体大小的单位: rem<br>相对于视口<em>宽度的百分比（100vw即视窗宽度的100%）: vw<br>相对于视口</em>高度的百分比（100vh即视窗高度的100%）: vh</p><h3 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h3><h3 id="display-none和visibility-hidden的区别"><a href="#display-none和visibility-hidden的区别" class="headerlink" title="display:none和visibility:hidden的区别"></a>display:none和visibility:hidden的区别</h3><p>display:none：隐藏元素，在文档布局中不在给它分配空间（从文档中移除），会引起回流（重排）<br>visibility:hidden: 隐藏元素，但是在文档布局中仍保留原来的空间（还在文档中），不会引起回流（重绘）</p><h3 id="用CSS-实现三角形"><a href="#用CSS-实现三角形" class="headerlink" title="用CSS 实现三角形"></a>用CSS 实现三角形</h3><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><h3 id="什么是重绘，重排？如何解决？"><a href="#什么是重绘，重排？如何解决？" class="headerlink" title="什么是重绘，重排？如何解决？"></a>什么是重绘，重排？如何解决？</h3><h4 id="重绘（repaint-x2F-redraw）"><a href="#重绘（repaint-x2F-redraw）" class="headerlink" title="重绘（repaint&#x2F;redraw）"></a>重绘（repaint&#x2F;redraw）</h4><p>某个dom节点的颜色，背景颜色变了，字体大小，只影响自己，不影响其他元素。</p><p>注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p><h4 id="重排（回流-x2F-reflow-x2F-重构）"><a href="#重排（回流-x2F-reflow-x2F-重构）" class="headerlink" title="重排（回流&#x2F;reflow&#x2F;重构）"></a>重排（回流&#x2F;reflow&#x2F;重构）</h4><p>某个dom节点的宽高，布局，隐藏等发生改变，不仅自身发生了改变，而且其他元素也会受到影响随之发生改变。每个页面最少一次回流，就是页面第一次加载的时候。</p><h4 id="触发重排的原因"><a href="#触发重排的原因" class="headerlink" title="触发重排的原因"></a>触发重排的原因</h4><p>页面初始化渲染（无可避免）<br>添加或删除可见的DOM元素<br>元素尺寸的改变——大小，外边距；边框<br>浏览器窗口尺寸的变化<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变<br>读取某些元素属性：（offsetLeft&#x2F;Top&#x2F;Height&#x2F;Width,　clientTop&#x2F;Left&#x2F;Width&#x2F;Height,　scrollTop&#x2F;Left&#x2F;Width&#x2F;Height,　width&#x2F;height,　getComputedStyle(), currentStyle(IE))</p><blockquote><p>1.重绘不一定重排，但是重排一定会重绘<br>2.重绘和重排的成本都是非常高的，要尽量减少dom的增删改</p></blockquote><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>不要直接操作样式，先设置好class，然后修改DOM的className;<br>position:absolute 与flex 不会导致重排<br>不要把DOM 节点的属性放在一个循环当成循环的变量；<br>需要动画的元素脱离文档流；<br>不使用table 布局，<br>尽量不修改影响范围比较大的DOM;<br>如果要多次添加DOM,先使用  document.createDocumentFragment() 创建一个盒子，完盒子里面先添加子元素，添加完成在插入元素中；</p><h3 id="transition-都有哪些过度属性？"><a href="#transition-都有哪些过度属性？" class="headerlink" title="transition 都有哪些过度属性？"></a>transition 都有哪些过度属性？</h3><h3 id="link和-import的区别？"><a href="#link和-import的区别？" class="headerlink" title="link和@import的区别？"></a>link和@import的区别？</h3><p>link属于html标签，而@import是css提供的。<br>页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载的。<br>兼容性问题：@import只在IE5以上才能识别，而link是html标签，无兼容性问题。<br>权重问题:@import的权重要高于link。<br>DOM操作:DOM可以操作link中的样式，而不可以操作@import中的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html 文件 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- link 方式，推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @import 方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@import</span> url(style.css);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用的动画库有哪些？"><a href="#常用的动画库有哪些？" class="headerlink" title="常用的动画库有哪些？"></a>常用的动画库有哪些？</h3><h3 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h3><h3 id="href与src的区别"><a href="#href与src的区别" class="headerlink" title="href与src的区别"></a>href与src的区别</h3><h3 id="如何让-CSS-只在当前组件中起作用？"><a href="#如何让-CSS-只在当前组件中起作用？" class="headerlink" title="如何让 CSS 只在当前组件中起作用？"></a>如何让 CSS 只在当前组件中起作用？</h3><p>将当前组件的 <code>&lt;style&gt;</code>修改为 <code>&lt;style scoped&gt;</code>。</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><h3 id="call、apply、bind-作用和区别（改变this指向）"><a href="#call、apply、bind-作用和区别（改变this指向）" class="headerlink" title="call、apply、bind 作用和区别（改变this指向）"></a>call、apply、bind 作用和区别（改变this指向）</h3><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><h3 id="JS基本数据类型"><a href="#JS基本数据类型" class="headerlink" title="JS基本数据类型"></a>JS基本数据类型</h3><h3 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h3><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li>语法更加简洁、清晰，&#x3D;&gt;()</li><li>箭头函数是匿名函数，不能作为构造函数，不能使用new</li><li>箭头函数不能使用arguments，而用reat参数…解决</li><li>箭头函数没有自己的this,会捕获其所在的上下文的this值,并且不能通过call()和apply()来改变其this</li><li>箭头函数没有原型</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><h3 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h3><p>常见的：<br>    原型链继承<br>    借用构造函数继承<br>    原型链 + 借用构造函数的组合继承（使用 call 或 applay 方法）<br>    ES6中class 的继承（class可以通过extends关键字实现继承）</p><h3 id="简述一下你理解的面向对象"><a href="#简述一下你理解的面向对象" class="headerlink" title="简述一下你理解的面向对象"></a>简述一下你理解的面向对象</h3><p>面向对象是基于万物皆对象这个哲学观点. 把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性和方法，也就是把一类事物的算法和数据结构封装在一个类之中,程序就是多个对象和互相之间的通信组成的。</p><p><strong>面向对象具有封装性,继承性,多态性。</strong></p><p>封装：隐蔽了对象内部不需要暴露的细节,使得内部细节的变动跟外界脱离,只依靠接口进行通信.封装性降低了编程的复杂性。<br>继承：使得新建一个类变得容易,一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。<br>多态：继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应,极大地提高了代码的通用性.。</p><h3 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别</h3><h3 id="数组有哪些方法？"><a href="#数组有哪些方法？" class="headerlink" title="数组有哪些方法？"></a>数组有哪些方法？</h3><h3 id="数组去重（笔试一般都会有）"><a href="#数组去重（笔试一般都会有）" class="headerlink" title="数组去重（笔试一般都会有）"></a>数组去重（笔试一般都会有）</h3><h3 id="JS中new操作符有什么用？"><a href="#JS中new操作符有什么用？" class="headerlink" title="JS中new操作符有什么用？"></a>JS中new操作符有什么用？</h3><p>创建临时对象，并将this指向临时对象<br>将构造函数的原型属性和方法挂载到新对象的__proto__(原型指针)上<br>return 临时对象</p><h3 id="JS获取HTML-DOM元素的方法"><a href="#JS获取HTML-DOM元素的方法" class="headerlink" title="JS获取HTML DOM元素的方法"></a>JS获取HTML DOM元素的方法</h3><p>通过ID获取（getElementById）<br>通过name属性（getElementsByName）<br>通过标签名（getElementsByTagName）<br>通过类名（getElementsByClassName）<br>获取html的方法（document.documentElement）<br>获取body的方法（document.body）<br>通过选择器获取一个元素（querySelector）<br>通过选择器获取一组元素（querySelectorAll）</p><h3 id="事件捕获和事件冒泡"><a href="#事件捕获和事件冒泡" class="headerlink" title="事件捕获和事件冒泡"></a>事件捕获和事件冒泡</h3><ul><li>事件捕获和事件冒泡主要解决了页面事件流的问题。页面的事件流经过了三个阶段，分别是事件捕获、目标阶段和事件冒泡阶段。</li><li>事件捕获是由外向内；而事件冒泡则是由内向外。</li><li>event.stopPropagation() 可以阻止事件流的进一步传播。</li><li>采用事件代理的方式，能够节省内存消耗，对于动态改变子元素的时候，也非常有利，避免了很多麻烦的步骤，比如重新绑定事件。（把子元素的事件委托给父元素来处理）</li></ul><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>定义：虚拟DOM就是普通的js对象。用来描述真实dom结构的js对象，因为它不是真实的dom，所以才叫做虚拟dom。<br>作用：虚拟dom可以很好地跟踪当前dom状态，因为它会根据当前数据生成一个描述当前dom结构的虚拟dom，然后数据发生变化时，有生成一个新的虚拟dom，而两个虚拟dom恰好保存了变化前后的状态。然后通过diff算法，计算出当前两个虚拟dom之间的差异，得出一个更好的替换方案。</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>冒泡排序：比较所有相邻元素,如果第一个比第二个大，则交换它们。<br>选择排序：找到数组中的最小值，选中它并将其放置在第一位。<br>插入排序：从第二个数开始往前比，比它大就往后排。<br>归并排序：把数组劈成两半，再递归地对数组进行“分”操作，直到分成一个个单独的数。<br>快速排序：从数组中任意选择一个基准，所有比基准小的元素放到基准前面，比基准大的元素放到基准的后面。</p><h3 id="数组操作方法会改变原数组"><a href="#数组操作方法会改变原数组" class="headerlink" title="数组操作方法会改变原数组"></a>数组操作方法会改变原数组</h3><p>会改变：push()，pop(),shift(),unshift() ,splice(),sort(),reverse()。<br>不变：concat(),split(),slice()。</p><h3 id="JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用"><a href="#JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用" class="headerlink" title="JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用"></a>JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用</h3><h3 id="JS有几种方法判断变量的类型？"><a href="#JS有几种方法判断变量的类型？" class="headerlink" title="JS有几种方法判断变量的类型？"></a>JS有几种方法判断变量的类型？</h3><p>typeof：</p><pre><code>判断基本数据类型，对于引用数据类型除了function返回’function‘，其余全部返回’object’。</code></pre><p>instanceof：</p><pre><code>区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined, null, symbol检测不出来。</code></pre><p>instanceof的实现原理：</p><pre><code>验证当前类的原型prototype是否会出现在实例的原型链__proto__上，只要在它的原型链上，则结果都为true。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，找到返回true，未找到返回false。</code></pre><p>constructor：</p><pre><code>检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。</code></pre><p>Object.prototype.toString.call()：</p><pre><code>适用于所有类型的判断检测，检测方法是Object.prototype.toString.call(数据) 返回的是该数据类型的字符串。(举例：字符串返回的是[object String])</code></pre><p>Object.prototype.toString.call原理：</p><pre><code>Object.prototype.toString 表示一个返回对象类型的字符串，call()方法可以改变this的指向，那么把Object.prototype.toString()方法指向不同的数据类型上面，返回不同的结果</code></pre><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p>null和undefined 区别为：undefined是表示变量声明过但并未赋过值，它是所有未赋值变量默认值；null表示一个变量将来可能指向一个对象，一般用于主动释放指向对象的引用。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>（1）undefined：是所有没有赋值变量的默认值，自动赋值<br>（2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址</p><h4 id="null与undefined的异同点是什么呢？"><a href="#null与undefined的异同点是什么呢？" class="headerlink" title="null与undefined的异同点是什么呢？"></a>null与undefined的异同点是什么呢？</h4><p>共同点： 都是原始类型，保存在栈中变量本地<br>不同点：<br>（1）undefined——表示变量声明过但并未赋过值。<br>它是所有未赋值变量默认值。<br>例如：var a; &#x2F;&#x2F;a自动被赋值为undefined<br>（2）null——表示一个变量将来可能指向一个对象。<br>一般用于主动释放指向对象的引用。</p><h4 id="何时使用null"><a href="#何时使用null" class="headerlink" title="何时使用null?"></a>何时使用null?</h4><p>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null</p><h3 id="什么是跨域？及跨域解决方法"><a href="#什么是跨域？及跨域解决方法" class="headerlink" title="什么是跨域？及跨域解决方法"></a>什么是跨域？及跨域解决方法</h3><h3 id="防抖和节流的使用及区别"><a href="#防抖和节流的使用及区别" class="headerlink" title="防抖和节流的使用及区别"></a>防抖和节流的使用及区别</h3><h3 id="栈内存和堆内存的区别与原理"><a href="#栈内存和堆内存的区别与原理" class="headerlink" title="栈内存和堆内存的区别与原理"></a>栈内存和堆内存的区别与原理</h3><h3 id="深拷贝和浅拷贝的区别和与原理"><a href="#深拷贝和浅拷贝的区别和与原理" class="headerlink" title="深拷贝和浅拷贝的区别和与原理"></a>深拷贝和浅拷贝的区别和与原理</h3><h3 id="webpack是怎么打包的，babel又是什么"><a href="#webpack是怎么打包的，babel又是什么" class="headerlink" title="webpack是怎么打包的，babel又是什么"></a>webpack是怎么打包的，babel又是什么</h3><p>Webpack：把所有依赖打包成一个 bundle.js文件，通过代码分割成单元片段并按需加载。Webpack是以公共JS的形式来书写脚本的，但对AMD&#x2F;CMD的支持也很全面，方便旧项目进行代码迁移。<br>把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p><p>babel将es6、es7、es8等语法转换成浏览器可识别的es5或es3语法。</p><h3 id="git-和-svn的区别"><a href="#git-和-svn的区别" class="headerlink" title="git 和 svn的区别"></a>git 和 svn的区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，首先要从中央服务器哪里得到最新的版本，干完活后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作（如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了）</p><p>Git是分布式版本控制系统，没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h3 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h3><p>webSocket： 可以让服务器主动向客户端发送消息，适合开发聊天室，多人游戏等协作应用。</p><p>WebSocket协议是基于TCP的一种新的网络协议。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h3 id="require和import区别"><a href="#require和import区别" class="headerlink" title="require和import区别"></a>require和import区别</h3><ul><li><p>调用时间</p><p>require运行时调用，理论上可以运用在代码任何地，甚至不需要赋值给某个变量之后再使用。<br>lmport是编译时候调用，必须放在文件开头，而且使用格式也是确定的。</p></li><li><p>遵循规范</p><p>require 是 AMD规范引入方式<br>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p></li><li><p>本质<br>require是赋值过程，其实require 的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。<br>import是解构过程。</p></li></ul><p>通过require 引入基础数据类型时，属于复制该变量。<br>通过require 引入复杂数据类型时，数据浅拷贝该对象。<br>出现模块之间的循环引用时,会输出已经执行的模块,而未执行的模块不输出(比较复杂）。CommonJS模块默认export的是一个对象，即使导出的是基础数据类型。</p><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。<br>使用import取代require()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;moduleA&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.<span class="property">func1</span>;</span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.<span class="property">func2</span>;</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用export取代module.exports。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">React</span> = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Breadcrumbs</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;nav /&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Breadcrumbs</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Breadcrumbs</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;nav /&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Breadcrumbs</span>;</span><br></pre></td></tr></table></figure><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>原因：JavaScript是单线程，所有任务需要排队，前一个任务结束，才会执行后一个任务。</p><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务：不进入主线程、而进入”任务队列”的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>同步和异步任务分别进入不同的执行环境， 先执行同步任务，把异步任务放入循环队列当中挂起，等待同步任务执行完，再执行队列中的异步任务。异步任务先执行微观任务，再执行宏观任务。一直这样循环，反复执行。</p><p>微任务：Promise.then、catch、finally、async&#x2F;await。<br>宏任务：整体代码 Script、UI 渲染、setTimeout、setInterval、Dom事件、ajax事件。</p><h3 id="宏任务、微任务是怎么执行的？"><a href="#宏任务、微任务是怎么执行的？" class="headerlink" title="宏任务、微任务是怎么执行的？"></a>宏任务、微任务是怎么执行的？</h3><p>执行顺序：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。</p><h3 id="什么是单页面应用（SPA）"><a href="#什么是单页面应用（SPA）" class="headerlink" title="什么是单页面应用（SPA）"></a>什么是单页面应用（SPA）</h3><p>一个系统只加载一次资源，之后的操作交互、数据交互是通过路由、ajax来进行，页面并没有刷新。<br>在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。</p><p>优点：<br>前后端分离<br>良好的交互体验——用户不用刷新页面，页面显示流畅<br>减轻服务器压力——服务器只出数据<br>共用一套后端代码——多个客户端可共用一套后端代码<br>加载速度快,内容的改变不需要重新加载整个页面,对服务器压力小<br>缺点：<br>SEO难度高——数据渲染在前端进行<br>页面初次加载比较慢,页面复杂提高很多<br>多页面： 一个应用多个页面,页面跳转时整个页面都刷新,每次都请求一个新的页面<br>有点:SEO效果好</p><p>缺点： 页面切换慢,每次切换页面需要选择性的重新加载公共资源</p><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><p>渐进增强（Progressive Enhancement）： 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。<br>优雅降级（Graceful Degradation）： 一开始就构建站点的完整功能，然后针对浏览器测试和修复。</p><p>在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的。</p><p>二者区别：<br>1、优雅降级和渐进增强只是看待同种事物的两种观点。<br>2、优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。<br>3、渐进增强观点则认为应关注于内容本身。</p><h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><p>新增块级作用域let定义变量和const定义常量<br>变量的解构赋值<br>模板字符串 （‘${}’）<br>默认参数（key&#x3D;value）<br>箭头函数（&#x3D;&gt;）<br>扩展运算符（…）<br>模块（import&#x2F;export）<br>类（class&#x2F;extends）<br>Promise<br>Proxy<br>Symbol</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>含义： 异步编程的一种解决方案，用来解决回调地狱。<br>三种状态： pending（进行中）、fulfilled（已成功）和rejected（已失败） （Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。）</p><p>resolved函数作用：将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved）。<br>reject函数的作用：将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected）。</p><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<br>then: Promise 实例添加状态改变时的回调函数。可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。</p><p>缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h3 id="MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？"><a href="#MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？" class="headerlink" title="MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？"></a>MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？</h3><p>MVC</p><ul><li>Model(模型)：负责从数据库中取数据</li><li>View(视图)：负责展示数据的地方</li><li>Controller(控制器)：用户交互的地方，例如点击事件</li><li>思想：Controller将Model的数据展示在View上</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4636ebbfa25049179c27a6b5ab8bb308~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>MVVM</p><ul><li>VM：也就是View-Model，做了两件事达到了数据的双向绑定<ul><li>一、将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</li><li>二、将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li></ul></li><li>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac31b27392b4b0e90ca2f67c64c59c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>区别</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><h3 id="如何理解-Vue-是一个渐进式框架？"><a href="#如何理解-Vue-是一个渐进式框架？" class="headerlink" title="如何理解 Vue 是一个渐进式框架？"></a>如何理解 Vue 是一个渐进式框架？</h3><p>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的 <code>ref</code>可以做到这点</p><h3 id="Vue的优点？Vue的缺点？"><a href="#Vue的优点？Vue的缺点？" class="headerlink" title="Vue的优点？Vue的缺点？"></a>Vue的优点？Vue的缺点？</h3><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p><p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h3 id="Vue和React的异同点？"><a href="#Vue和React的异同点？" class="headerlink" title="Vue和React的异同点？"></a>Vue和React的异同点？</h3><p>相同点：</p><ul><li>使用虚拟dom</li><li>组件化开发</li><li>单向数据流(父子组件之间，不建议子修改父传递的数据)</li><li>支持服务端渲染</li></ul><p>不同点：</p><ul><li>React的JSX，Vue的template</li><li>数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)</li><li>React单向绑定，Vue双向绑定</li><li>React的Redux，Vue的Vuex</li></ul><h3 id="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><a href="#Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？" class="headerlink" title="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"></a>Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</h3><ul><li>jQuery直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可</li><li>在操作DOM频繁的场景里，jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能</li><li>Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</li><li>Vue集成的一些库，大大提高开发效率，比如Vuex，Router等</li></ul><h3 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h3><p>通过数据劫持结合发布—订阅模式，通过Object.defineProperty()为各个属性定义get、set方法，在数据发生改变时给订阅者发布消息，触发相应的事件回调。</p><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892fde0e56324868921d0e924c84858a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><ul><li><p>beforeCreate</p><p>创建前。此时，组件实例刚刚创建，还未进行数据观测和事件配置，拿不到任何数据。</p></li><li><p>created</p><p>创建完成。vue 实例已经完成了数据观测，属性和方法的计算(比如props、methods、data、computed和watch此时已经拿得到)，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求，页面的初始化。</p></li><li><p>beforeMount</p><p>挂载前。挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM）。编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p></li><li><p>mounted</p><p>挂载完成。也就是模板中的HTML渲染到HTML页面中，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求，mounted只会执行一次。</p></li><li><p>beforeUpdate</p><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，不会触发附加地重渲染过程。</p></li><li><p>updated</p><p>更新后。在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用，</p></li><li><p>beforeDestroy</p><p>销毁前。在实例销毁之前调用，实例仍然完全可用。（一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件）</p></li><li><p>destroyed</p><p>销毁后。在实例销毁之后调用，调用后，vue实列指示的所有东西都会解绑，所有的事件监听器会被移除。<br>其他：</p></li><li><p>activated</p><p>在keep-alive组件激活时调用</p></li><li><p>deactivated</p><p>在keep-alive组件停用时调用</p></li></ul><h3 id="vuex的有哪些属性？用处是什么？"><a href="#vuex的有哪些属性？用处是什么？" class="headerlink" title="vuex的有哪些属性？用处是什么？"></a>vuex的有哪些属性？用处是什么？<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9566927e955c4d0ba19df942534e5b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></h3><h3 id="为什么使用虚拟DOM-常问"><a href="#为什么使用虚拟DOM-常问" class="headerlink" title="为什么使用虚拟DOM(常问)"></a>为什么使用虚拟DOM(常问)</h3><p>创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。<br>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。<br>虚拟dom由于本质是一个js对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。<br>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</p><h3 id="v-if-和-v-show的作用和区别"><a href="#v-if-和-v-show的作用和区别" class="headerlink" title="v-if 和 v-show的作用和区别"></a>v-if 和 v-show的作用和区别</h3><ul><li><code>v-if</code>：通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</li><li><code>v-show</code>：通过控制dom元素的css样式来实现显隐，不会销毁</li><li>频繁或者大数量显隐使用 <code>v-show</code>，否则使用 <code>v-if</code></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">无论v-<span class="built_in">show</span>的值为<span class="literal">true</span>或者<span class="literal">false</span>,元素都会存在于html页面中; 而v-<span class="keyword">if</span>的值为<span class="literal">true</span>时,元素才会存在于html页面中。</span><br><span class="line">v-<span class="built_in">show</span>指令是通过修改元素的<span class="built_in">display</span>属性来实现的。</span><br><span class="line">v-<span class="keyword">if</span>是动态地向DOM树内添加或者删除DOM元素,v-<span class="built_in">show</span>是通过设置DOM元素的<span class="built_in">display</span>样式属性控制显隐的。</span><br><span class="line">v-<span class="keyword">if</span>是<span class="string">&quot;真正的&quot;</span>条件渲染,因为它会确保在奇幻过程中条件快内的事件监听器和子组件适当的销毁和重建。</span><br><span class="line">v-<span class="keyword">if</span>也是惰性的,如果在初始渲染时条件为假,则什么也不做,直到条件第一次变为真时,才开始渲染条件块。</span><br><span class="line">v-<span class="built_in">show</span>不管初始条件是什么,元素总会背渲染,并且只是简单地基于css进行切换。</span><br><span class="line">一般来说,v-<span class="keyword">if</span>有更高的切换开销,而v-<span class="built_in">show</span>则有更高的初始渲染开销</span><br></pre></td></tr></table></figure><p>因此,如果需要非常频繁地切换,使用v-show比较好,如果在运行时条件不会改变时,用v-if比较好</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">切换时生命周期函数的执行</span><br><span class="line">v-<span class="keyword">if</span></span><br><span class="line">初始渲染</span><br><span class="line">初始值为<span class="keyword">false</span>时,不会渲染(所谓惰性),生命周期函数不会执行</span><br><span class="line">初始值为<span class="keyword">true</span>时,组件开始渲染,依次执行beforCreate,created,beforeMount,mounted等生命周期</span><br><span class="line"></span><br><span class="line">切换时</span><br><span class="line">从<span class="keyword">false</span>到<span class="keyword">true</span>:依次执行beforeCreate,created,beforeMount,moynted</span><br><span class="line">从<span class="keyword">true</span>到<span class="keyword">false</span>:依次执行beforeDestroy,destroyed</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">show</span></span><br><span class="line">初始渲染</span><br><span class="line">无论初始状态为<span class="keyword">true</span>还是<span class="keyword">false</span>,组件都会渲染,依次执行beforeCreate,created,beforeMount,mounted</span><br><span class="line"></span><br><span class="line">切换</span><br><span class="line">基于css进行切换,对生命周期函数无影响.</span><br></pre></td></tr></table></figure><h3 id="Vue-2-x-模板中的指令是如何解析实现的？"><a href="#Vue-2-x-模板中的指令是如何解析实现的？" class="headerlink" title="Vue 2.x 模板中的指令是如何解析实现的？"></a>Vue 2.x 模板中的指令是如何解析实现的？</h3><h3 id="简要说明-Vue-2-x-的全链路运作机制？"><a href="#简要说明-Vue-2-x-的全链路运作机制？" class="headerlink" title="简要说明 Vue 2.x 的全链路运作机制？"></a>简要说明 Vue 2.x 的全链路运作机制？</h3><h3 id="Vue-里实现跨组件通信的方式有哪些？"><a href="#Vue-里实现跨组件通信的方式有哪些？" class="headerlink" title="Vue 里实现跨组件通信的方式有哪些？"></a>Vue 里实现跨组件通信的方式有哪些？</h3><h3 id="Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？"><a href="#Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？" class="headerlink" title="Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？"></a>Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？</h3><h3 id="用过vue的哪些组件？"><a href="#用过vue的哪些组件？" class="headerlink" title="用过vue的哪些组件？"></a>用过vue的哪些组件？</h3><p>1、vue-route<br>2、axios<br>3、vuex<br>4、Element UI<br>5、swiper<br>6、vue-echarts<br>7、vue-video-player<br>8、vue-photo-preview等等</p><h3 id="相同的路由组件如何重新渲染？"><a href="#相同的路由组件如何重新渲染？" class="headerlink" title="相同的路由组件如何重新渲染？"></a>相同的路由组件如何重新渲染？</h3><blockquote><p>开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">MyComponent</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/b&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">MyComponent</span></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>如果依然想重新渲染，怎么办呢？可以使用 <code>key</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">&quot;$route.path&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="vue-router-的路由模式有？"><a href="#vue-router-的路由模式有？" class="headerlink" title="vue-router 的路由模式有？"></a>vue-router 的路由模式有？</h3><p>1、hash模式，用URL hash值来做路由，支持所有浏览器；该模式实现的路由，在通过链接后面添加““#”+路由名字”，触发 <code>hashchange</code>事件，实现路由切换<br>2、history模式，由h5提供的history对象实现，依赖H5 History API和服务器配置，通过 <code>pushState</code>和 <code>replaceState</code>切换url，实现路由切换，需要后端配合<br>3、abstract模式，支持所有JS运行环境，如Node服务器端，如果发现没有浏览器的API，路由会自动强制进入该模式。</p><h3 id="组件之间如何传值"><a href="#组件之间如何传值" class="headerlink" title="组件之间如何传值"></a>组件之间如何传值</h3><ul><li>Vue父子 组件之间传值<ul><li>子组件通过 <code>props</code>来接受数据</li><li>子组件通过 <code>$emit</code>来触发父组件的自定义事件（即传值）</li></ul></li><li>组件中可以使用 <code>$parent</code>和 <code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li><li>使用 <code>$attrs</code>和 <code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li><li>使用 <code>$refs</code>获取组件实例，进而获取数据</li><li>使用 <code>Vuex</code>进行状态管理</li><li>使用 <code>eventBus</code>进行跨组件触发事件，进而传递数据</li><li>使用 <code>provide</code>和 <code>inject</code>，官方建议我们不要用这个，我在看 <code>ElementUI</code>源码时发现大量使用</li><li>使用浏览器本地缓存，例如 <code>localStorage</code></li></ul><h3 id="路由之间如何传参"><a href="#路由之间如何传参" class="headerlink" title="路由之间如何传参"></a>路由之间如何传参</h3><ul><li>通过router-link路由导航跳转传递<br><code>&lt;router-link to=</code>&#x2F;a&#x2F;${id}<code>&gt;routerlink传参&lt;/router-link&gt;</code></li><li>跳转时使用push方法拼接携带参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">`/getlist/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>通过路由属性中的name来确定匹配的路由，通过params来传递参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Getlist&#x27;</span>,</span><br><span class="line">   <span class="attr">params</span>: &#123;</span><br><span class="line">     <span class="attr">id</span>: id</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ul><li>使用path来匹配路由，然后通过query来传递参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"> <span class="attr">path</span>: <span class="string">&#x27;/getlist&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：query有点像ajax中的get请求，而params像post请求。</p></blockquote><p>params在地址栏中不显示参数，刷新页面，参数丢失,<br>其余方法在地址栏中显示传递的参数，刷新页面，参数不丢失。</p><h3 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h3><p>原理：Vuex是专门为vue.js应用程序设计的状态管理工具。</p><p>1、state   保存vuex中的数据源，通过this.$store.state获取</p><p>2、getters用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来</p><p>3、mutations  是修改store中的值得唯一方式&#x2F;&#x2F;this.$store.commit(‘add’)</p><p>4、action 官方建议提交一个actions，在actions中提交mutations再去修改状态值。this.$store.dispatch(‘add’)</p><p>5、modules 模块化</p><h3 id="如何解决vuex页面刷新数据丢失问题？"><a href="#如何解决vuex页面刷新数据丢失问题？" class="headerlink" title="如何解决vuex页面刷新数据丢失问题？"></a>如何解决vuex页面刷新数据丢失问题？</h3><p>原因：因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被清空。<br>解决方法：将vuex中的数据直接保存到浏览器缓存中。（一般是用sessionStorage）</p><h3 id="computed和watch的区别？"><a href="#computed和watch的区别？" class="headerlink" title="computed和watch的区别？"></a>computed和watch的区别？</h3><p>computed值有缓存、触发条件是依赖值发生更改、 watch无缓存支持异步、监听数据变化</p><p>computed： 是计算属性，依赖其它属性值，并且computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p><p>watch： 更多的是观察的作用，支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><ul><li><code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是 <code>多个变量</code>凑在一起计算出 <code>一个变量</code>，并且 <code>computed</code>具有 <code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行 <code>异步操作</code></li><li><code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是 <code>一个变量</code>的变化决定 <code>多个变量</code>的变化，<code>watch</code>可以进行 <code>异步操作</code></li><li>简单记就是：一般情况下 <code>computed</code>是 <code>多对一</code>，<code>watch</code>是 <code>一对多</code></li></ul><h3 id="computed如何实现传参？"><a href="#computed如何实现传参？" class="headerlink" title="computed如何实现传参？"></a>computed如何实现传参？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div&gt;&#123;&#123; <span class="title function_">total</span>(<span class="number">3</span>) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">total</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> n * <span class="variable language_">this</span>.<span class="property">num</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="watch有哪些属性，分别有什么用？"><a href="#watch有哪些属性，分别有什么用？" class="headerlink" title="watch有哪些属性，分别有什么用？"></a>watch有哪些属性，分别有什么用？</h3><p>当我们监听一个基本数据类型时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    value () &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们监听一个引用数据类型时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;</span><br><span class="line">       handler () &#123; <span class="comment">// 执行回调</span></span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 是否进行深度监听</span></span><br><span class="line">       <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// 是否初始执行handler函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch的immediate属性有什么用？"><a href="#watch的immediate属性有什么用？" class="headerlink" title="watch的immediate属性有什么用？"></a>watch的immediate属性有什么用？</h3><blockquote><p>比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">searchInputValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>immediate</code>完全可以这么写，当它为 <code>true</code>时，会初始执行一次</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">searchInputValue</span>:&#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="string">&#x27;getList&#x27;</span>,</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch监听一个对象时，如何排除某些属性的监听"><a href="#watch监听一个对象时，如何排除某些属性的监听" class="headerlink" title="watch监听一个对象时，如何排除某些属性的监听"></a>watch监听一个对象时，如何排除某些属性的监听</h3><blockquote><p>下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">params</span>)</span><br><span class="line">      .<span class="title function_">filter</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> ![<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>].<span class="title function_">includes</span>(_)) <span class="comment">// 排除对c，d属性的监听</span></span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span> vm.<span class="property">params</span>[_], handler, &#123;</span><br><span class="line">          <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="route和router的区别"><a href="#route和router的区别" class="headerlink" title="route和router的区别"></a>route和router的区别</h3><p>route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。<br>router:是路由实例对象，包括了路由跳转方法，钩子函数等。</p><h3 id="vue中数据变了但是视图不跟新怎么解决？"><a href="#vue中数据变了但是视图不跟新怎么解决？" class="headerlink" title="vue中数据变了但是视图不跟新怎么解决？"></a>vue中数据变了但是视图不跟新怎么解决？</h3><p>vue不能检测以下变动的数组：</p><p>1、当你利用索引直接设置一个项时，vm.items[indexOfItem] &#x3D; newValue<br>2、当你修改数组的长度时，例如： vm.items.length &#x3D; newLength</p><p>对象属性的添加或删除</p><p>由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>解决办法：</p><p>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上<br>Vue.set(vm.someObject, ‘b’, 2) 或者 this.$set(this.someObject,‘b’,2) （这也是全局 Vue.set 方法的别名）</p><p>异步更新队列</p><p>在最新的项目中遇到了这种情况，数据第一次获取到了，也渲染了，但是第二次之后数据只有在再一次渲染页面的时候更新，并不能实时更新。</p><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>解决办法：</p><p>可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用</p><h3 id="vue中data为什么是函数而不是对象？"><a href="#vue中data为什么是函数而不是对象？" class="headerlink" title="vue中data为什么是函数而不是对象？"></a>vue中data为什么是函数而不是对象？</h3><p>vue组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的.</p><p>基于这一理念，组件每复用一次，data数据就会被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响。</p><p>如果data是对象的话，每当被复用是，复用的对象和源对象都会指向同一个内存地址（浅拷贝），互相之间相互影响，所以要是函数</p><h3 id="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"><a href="#vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）" class="headerlink" title="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"></a>vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）</h3><p>首先了解父子组件生命周期执行顺序<br>加载渲染数据过程<br>父组件 beforeCreate<br>父组件 created<br>父组件 beforeMount<br>子组件 beforeCreate<br>子组件 created<br>子组件 beforeMount<br>子组件 mounted<br>父组件 mounted</p><p>原因：因为生命周期只会执行一次，数据是要等到异步请求以后才能拿到，那么子组件的mounted钩子执行的时候，还没有拿到父组件传递过来的数据，但是又必须要打印出来结果，那这样的话，就只能去打印props中的默认值空字符串了，所以打印的结果是一个空字符串。</p><p>解决办法：</p><p>1、使用v-if控制组件渲染的时机</p><p>初始还没拿到后端接口的异步数据的时候，不让组件渲染，等拿到的时候再去渲染组件。使用v-if&#x3D;”变量”去控制，初始让这个变量为false，这样的话，子组件就不会去渲染，等拿到数据的时候，再让这个变量变成true，</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">isTrue</span>:<span class="literal">false</span> <span class="comment">// 初始为false</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">monted</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$post</span>.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>.<span class="title function_">getData</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(res.<span class="property">result</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">isTrue</span> = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用watch监听数据的变化</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">tableData</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    <span class="attr">default</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">   <span class="title function_">tableData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3、使用VueX</p><h3 id="Vue-路由跳转方式"><a href="#Vue-路由跳转方式" class="headerlink" title="Vue 路由跳转方式"></a>Vue 路由跳转方式</h3><p>router-link 标签跳转<br>this.$router.push()<br>this.$router.replace()<br>this.$router.go(n)：（0：当前页，-1上一页，+1下一页，n代表整数）</p><h3 id="Vue-中-for循环为什么加-key？"><a href="#Vue-中-for循环为什么加-key？" class="headerlink" title="Vue 中 for循环为什么加 key？"></a>Vue 中 for循环为什么加 key？</h3><p>为了性能优化， 因为vue是虚拟DOM，更新DOM时用diff算法对节点进行一一比对，比如有很多li元素，要在某个位置插入一个li元素，但没有给li上加key，那么在进行运算的时候，就会将所有li元素重新渲染一遍，但是如果有key，那么它就会按照key一一比对li元素，只需要创建新的li元素，插入即可，不需要对其他元素进行修改和重新渲染。<br>key也不能是li元素的index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了。</p><h3 id="vue路由守卫有哪些？"><a href="#vue路由守卫有哪些？" class="headerlink" title="vue路由守卫有哪些？"></a>vue路由守卫有哪些？</h3><p>路由守卫分为三种 ——分别是：全局路由守卫、组件路由守卫、独享路由守卫。</p><p>全局守卫<br>全局守卫又分为全局前置守卫、和后置守卫</p><ol><li>router.beforeEach((to,from,next)&#x3D;&gt;{})</li></ol><p>回调函数中的参数，to：进入到哪个路由去，from：从哪个路由离开，next：函数，决定是否展示你要看到的路由页面。</p><p>从名字全局前置守卫不难理解，它是全局的，即对 整个单页应用（SPA） 中的所有路由都生效，所以当定义了全局的前置守卫，在进入每一个路由之前都会调用这个回调，那么如果你在回调中对路由的跳转条件判断出错，简单点就是死循环…因为你遗漏了某种路由跳转的情况，守卫会一直执行。所以在使用全局前置守卫的时候一定要判断清楚可能会出现的路由跳转的情况。</p><p>2.router.afterEach((to, from) &#x3D;&gt; {}）</p><p>只有两个参数，to：进入到哪个路由去，from：从哪个路由离。</p><p>理解了全局前置守卫，那么全局后置守卫也就那么一回事。全局后置守卫是整个单页应用中每一次路由跳转后都会执行其中的回调。所以多用于路由跳转后的相应页面操作，并不像全局前置守卫那样会在回调中进行页面的重定向或跳转。</p><p>组件内的守卫<br>组件路由守卫分为到达这个组件时，离开这个组件时</p><ol><li>beforeRouteEnter:(to,from,next)&#x3D;&gt;{}——到达</li></ol><p>to，from参数与上面使用方法一致。next回调函数略有不同。<br>1<br>2.beforeRouteUpdate:(to,from,next)&#x3D;&gt;{}——更新</p><ol start="3"><li>beforeRouteLeave:(to,from,next)&#x3D;&gt;{}——离开</li></ol><p>点击其他组件时，判断是否确认离开。确认执行next()；取消执行next(false)，留在当前页面。<br>1<br>路由独享的守卫</p><ol><li>beforeEnter:(to,from,next)&#x3D;&gt;{}</li></ol><p>与全局路由守卫用法一致，但是只能针对一个页面使用<br>1</p><h3 id="vue常⽤的修饰符"><a href="#vue常⽤的修饰符" class="headerlink" title="vue常⽤的修饰符"></a>vue常⽤的修饰符</h3><p>.stop:等统⼀JavaScript中的event.stopPropagation(),防⽌事件冒泡<br>.prevent:等同于JavaScript中的event。preventDefault(),防⽌执⾏预设的⾏为(如果事件可<br>取消，则取消该事件，⽽不停⽌事件的进⼀步传播)；<br>.capture:与事件冒泡的⽅向相反，事件捕获由外到内<br>.self:只会触发⾃⼰范围内的事件，不包含⼦元素；<br>.once:只会触发⼀次。</p><h3 id="vue的两个核⼼点"><a href="#vue的两个核⼼点" class="headerlink" title="vue的两个核⼼点"></a>vue的两个核⼼点</h3><p>数据驱动：ViewModel，保证数据和视图的⼀致性<br>组件系统：应⽤类UI可以看做全部是由组件树构成的</p><h3 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了empty&#x2F;undefined其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值</p><h3 id="vue常⽤的UI组件库"><a href="#vue常⽤的UI组件库" class="headerlink" title="vue常⽤的UI组件库"></a>vue常⽤的UI组件库</h3><p>Mint UI，element，VUX</p><h3 id="简单介绍一下-Element-UI-的框架设计？"><a href="#简单介绍一下-Element-UI-的框架设计？" class="headerlink" title="简单介绍一下 Element UI 的框架设计？"></a>简单介绍一下 Element UI 的框架设计？</h3><h3 id="Vue首页白屏是什么问题引起的？如何解决呢？"><a href="#Vue首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="Vue首页白屏是什么问题引起的？如何解决呢？"></a>Vue首页白屏是什么问题引起的？如何解决呢？</h3><h3 id="为什么data是个函数并且返回一个对象呢？"><a href="#为什么data是个函数并且返回一个对象呢？" class="headerlink" title="为什么data是个函数并且返回一个对象呢？"></a>为什么data是个函数并且返回一个对象呢？</h3><p><code>data</code>之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行 <code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的 <code>数据污染</code>。</p><h3 id="如何获取data中某一个数据的初始状态？"><a href="#如何获取data中某一个数据的初始状态？" class="headerlink" title="如何获取data中某一个数据的初始状态？"></a>如何获取data中某一个数据的初始状态？</h3><blockquote><p>在开发中，有时候需要拿初始状态去计算。例如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">howMuch</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 计算出num增加了多少，那就是1000 - 初始值</span></span><br><span class="line">        <span class="comment">// 可以通过this.$options.data().xxx来获取初始值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> - <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="title function_">data</span>().<span class="property">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Vue的修饰符"><a href="#Vue的修饰符" class="headerlink" title="Vue的修饰符"></a>Vue的修饰符</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1c911988f74cea91da79af3c6049c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="截屏2021-07-11 下午9.56.53.png"></p><h3 id="Vue的内部指令"><a href="#Vue的内部指令" class="headerlink" title="Vue的内部指令"></a>Vue的内部指令</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39d348e686b449e8931f5a85802e3c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="动态指令和参数使用过吗？"><a href="#动态指令和参数使用过吗？" class="headerlink" title="动态指令和参数使用过吗？"></a>动态指令和参数使用过吗？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;aButton @[someEvent]=<span class="string">&quot;handleSomeEvent()&quot;</span> :[someProps]=<span class="string">&quot;1000&quot;</span> /&gt;...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">someEvent</span>: someCondition ? <span class="string">&quot;click&quot;</span> : <span class="string">&quot;dbclick&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">someProps</span>: someCondition ? <span class="string">&quot;num&quot;</span> : <span class="string">&quot;price&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">handleSomeEvent</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// handle some event</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="如何设置动态class，动态style？"><a href="#如何设置动态class，动态style？" class="headerlink" title="如何设置动态class，动态style？"></a>如何设置动态class，动态style？</h3><ul><li><p>动态class对象：</p><p><code>&lt;div :class=&quot;&#123; &#39;is-active&#39;: true, &#39;red&#39;: isRed &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态class数组：</p><p><code>&lt;div :class=&quot;[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style对象：</p><p><code>&lt;div :style=&quot;&#123; color: textColor, fontSize: &#39;18px&#39; &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style数组：</p></li></ul><p><code>&lt;div :style=&quot;[&#123; color: textColor, fontSize: &#39;18px&#39; &#125;, &#123; fontWeight: &#39;300&#39; &#125;]&quot;&gt;&lt;/div&gt;</code></p><h3 id="为什么v-if和v-for不建议用在同一标签？"><a href="#为什么v-if和v-for不建议用在同一标签？" class="headerlink" title="为什么v-if和v-for不建议用在同一标签？"></a>为什么v-if和v-for不建议用在同一标签？</h3><p>在Vue2中，<code>v-for</code>优先级是高于 <code>v-if</code>的，咱们来看例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in [1, 2, 3, 4, 5, 6, 7]&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;item !== 3&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的写法是 <code>v-for</code>和 <code>v-if</code>同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">computed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">list</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。"><a href="#State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。" class="headerlink" title="* State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。"></a>* State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</h3><ul><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="不需要响应式的数据应该怎么处理？"><a href="#不需要响应式的数据应该怎么处理？" class="headerlink" title="不需要响应式的数据应该怎么处理？"></a>不需要响应式的数据应该怎么处理？</h3><p>在我们的Vue开发中，会有一些数据，从始至终都 <code>未曾改变过</code>，这种 <code>死数据</code>，既然 <code>不改变</code>，那也就 <code>不需要对他做响应式处理</code>了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的 <code>死数据</code>，如果都进行响应式处理，那会消耗大量性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：将数据定义在data之外</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list1</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list2</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list3</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list4</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list5</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法二：Object.freeze()</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">list1</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list2</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list3</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list4</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list5</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="headerlink" title="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"></a>对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3><ul><li>原因：<code>Object.defineProperty</code>没有对对象的新属性进行属性劫持</li><li>对象新属性无法更新视图：使用 <code>Vue.$set(obj, key, value)</code>，组件中 <code>this.$set(obj, key, value)</code></li><li>删除属性无法更新视图：使用 <code>Vue.$delete(obj, key)</code>，组件中 <code>this.$delete(obj, key)</code></li></ul><h3 id="直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？"><a href="#直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？" class="headerlink" title="直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？"></a>直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？</h3><ul><li>原因：Vue没有对数组进行 <code>Object.defineProperty</code>的属性劫持，所以直接arr[index] &#x3D; xxx是无法更新视图的</li><li>使用数组的splice方法，<code>arr.splice(index, 1, item)</code></li><li>使用 <code>Vue.$set(arr, index, value)</code></li></ul><h3 id="为什么不建议用index做key，为什么不建议用随机数做key？"><a href="#为什么不建议用index做key，为什么不建议用随机数做key？" class="headerlink" title="为什么不建议用index做key，为什么不建议用随机数做key？"></a>为什么不建议用index做key，为什么不建议用随机数做key？</h3><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in list&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;&#123;&#123;item.<span class="property">name</span>&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">list</span>: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;124&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小花&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;125&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小明&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">现在我执行 </span><br><span class="line">list.<span class="title function_">unshift</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;122&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小明&lt;<span class="regexp">/div&gt;  &lt;div key=&quot;0&quot;&gt;小林&lt;/</span>div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                         <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能</span><br><span class="line"></span><br><span class="line">现在我们使用id来做key，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;123&quot;</span>&gt;小明&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">现在我执行 list.<span class="title function_">unshift</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;122&#x27;</span> &#125;)，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;122&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">                           &lt;div key=<span class="string">&quot;122&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果</span><br></pre></td></tr></table></figure><p>用 <code>index</code>和用 <code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，很 <code>渣男</code>，也很消耗性能，所以，拒绝 <code>渣男</code>，选择 <code>老实人</code></p><h3 id="nextTick的原理"><a href="#nextTick的原理" class="headerlink" title="nextTick的原理"></a>nextTick的原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callbacks = []; <span class="comment">//回调函数</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pending = <span class="literal">false</span>; <span class="comment">//把标志还原为false</span></span><br><span class="line">    <span class="comment">// 依次执行回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        callbacks[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> timerFunc; <span class="comment">//先采用微任务并按照优先级优雅降级的方式实现异步刷新</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果支持promise</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(flushCallbacks);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// MutationObserver 主要是监听dom变化 也是一个异步方法</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks);</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">        <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前面都不支持 判断setImmediate</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setImmediate</span>(flushCallbacks);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 最后降级采用setTimeout</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    callbacks.<span class="title function_">push</span>(cb);</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">timerFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextTick的用处"><a href="#nextTick的用处" class="headerlink" title="nextTick的用处"></a>nextTick的用处</h3><p>我举个例子，在vue中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><p>我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是 <code>异步更新</code>的策略，通俗点说就是，<code>同一事件循环内</code>多次修改，会 <code>统一</code>进行一次 <code>视图更新</code>，这样才能节省性能嘛</p><p>看懂了上面，那你应该也看得懂下面的例子了吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;testDiv&quot;</span>&gt;&#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 这里是啥呢</span></span><br></pre></td></tr></table></figure><p>答案是“小林”，前面说了，Vue是 <code>异步更新</code>，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 林三心</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue的SSR是什么？有什么好处？"><a href="#Vue的SSR是什么？有什么好处？" class="headerlink" title="Vue的SSR是什么？有什么好处？"></a>Vue的SSR是什么？有什么好处？</h3><ul><li><code>SSR</code>就是服务端渲染</li><li>基于 <code>nodejs serve</code>服务环境开发，所有 <code>html</code>代码在服务端渲染</li><li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码</li><li><code>SSR</code>首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好</li></ul><h3 id="Vue响应式是怎么实现的？"><a href="#Vue响应式是怎么实现的？" class="headerlink" title="Vue响应式是怎么实现的？"></a>Vue响应式是怎么实现的？</h3><p>整体思路：数据劫持+观察者模式</p><p>对象内部通过 <code> defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 <code>dep</code>属性，存放他所依赖的 <code> watcher</code>（依赖收集），当属性变化后会通知自己对应的 <code> watcher</code> 去更新(派发更新)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; arrayMethods &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./array&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="variable language_">this</span>,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            value.<span class="property">__proto__</span> = arrayMethods</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">walk</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> key = keys[i]</span><br><span class="line">            <span class="keyword">const</span> value = data[key]</span><br><span class="line">            <span class="title function_">defineReactive</span>(data, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">observeArray</span>(<span class="params">items</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">observe</span>(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childOb = <span class="title function_">observe</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">                        <span class="title function_">dependArray</span>(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === value) <span class="keyword">return</span></span><br><span class="line">            <span class="title function_">observe</span>(newVal)</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dependArray</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        e = value[i]</span><br><span class="line"></span><br><span class="line">        e &amp;&amp; e.<span class="property">__ob__</span> &amp;&amp; e.<span class="property">__ob__</span>.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.js</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    arrayMethods[method] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = arrayProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> inserted</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">                inserted = args</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">                inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line"></span><br><span class="line">        ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为什么只对对象劫持，而要对数组进行方法重写？"><a href="#为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="为什么只对对象劫持，而要对数组进行方法重写？"></a>为什么只对对象劫持，而要对数组进行方法重写？</h3><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p><h3 id="Vue-set方法的原理"><a href="#Vue-set方法的原理" class="headerlink" title="Vue.set方法的原理"></a>Vue.set方法的原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 判断谁大谁小</span></span><br><span class="line">        target.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(target.<span class="property">length</span>, key)</span><br><span class="line">        <span class="comment">// 执行splice</span></span><br><span class="line">        target.<span class="title function_">splice</span>(key, <span class="number">1</span>, val)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此对象没有不是响应式对象，直接设置并返回</span></span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> target.<span class="property"><span class="keyword">prototype</span></span>) || !ob) &#123;</span><br><span class="line">        target[key] = val</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，新增属性，并响应式处理</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(target, key, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-delete方法的原理？"><a href="#Vue-delete方法的原理？" class="headerlink" title="Vue.delete方法的原理？"></a>Vue.delete方法的原理？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">del</span> (target, key) &#123;</span><br><span class="line">    <span class="comment">// 判断是否为数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 执行splice</span></span><br><span class="line">        target.<span class="title function_">splice</span>(key, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象本身就没有这个属性，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，删除这个属性</span></span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是响应式对象，不是的话，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!ob) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 是的话，删除后要通知视图更新</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果子组件改变props里的数据会发生什么"><a href="#如果子组件改变props里的数据会发生什么" class="headerlink" title="如果子组件改变props里的数据会发生什么"></a>如果子组件改变props里的数据会发生什么</h3><ul><li>改变的props数据是基本类型</li></ul><blockquote><p>如果修改的是基本类型，则会报错</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047859eda3bf47a5930dd0b28e842017~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="0458e2ff1538ee85d42953cec9a94ca.png"></p><ul><li>改变的props数据是引用类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">item</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不报错，并且父级数据会跟着变</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">name</span> = <span class="string">&#x27;sanxin&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 会报错，跟基础类型报错一样</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span> = <span class="string">&#x27;sss&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="props怎么自定义验证"><a href="#props怎么自定义验证" class="headerlink" title="props怎么自定义验证"></a>props怎么自定义验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="comment">// 返回值为false则验证不通过，报错</span></span><br><span class="line">          <span class="keyword">return</span> [</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">          ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="审查元素时发现data-v-xxxxx，这是啥？"><a href="#审查元素时发现data-v-xxxxx，这是啥？" class="headerlink" title="审查元素时发现data-v-xxxxx，这是啥？"></a>审查元素时发现data-v-xxxxx，这是啥？</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff63f90f2d924ff6b20622a2d05ba367~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><blockquote><p>这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p></blockquote><h3 id="vue的hook的使用"><a href="#vue的hook的使用" class="headerlink" title="vue的hook的使用"></a>vue的hook的使用</h3><ul><li>同一组件中使用</li></ul><blockquote><p>这是我们常用的使用定时器的方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="attr">timer</span>:<span class="literal">null</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//具体执行内容</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">beforeDestory</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//具体执行代码</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">      &#125;,<span class="number">1000</span>);</span><br><span class="line">      <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7.2 父子组件使用</li></ul><blockquote><p>如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;rl-child @childMounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;childMounted&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用hook的话可以更方便：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;rl-child @<span class="attr">hook</span>:mounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="provide和inject是响应式的吗？"><a href="#provide和inject是响应式的吗？" class="headerlink" title="provide和inject是响应式的吗？"></a>provide和inject是响应式的吗？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="comment">// keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型</span></span><br><span class="line">      <span class="attr">keyName</span>: <span class="variable language_">this</span>.<span class="property">changeValue</span> <span class="comment">// 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]</span></span><br><span class="line">   <span class="comment">// keyName: &#x27;test&#x27; value 如果是基本类型，就无法实现响应式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;改变后的名字-李四&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后代组件</span></span><br><span class="line">  <span class="attr">inject</span>:[<span class="string">&#x27;keyName&#x27;</span>]</span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">keyName</span>) <span class="comment">// 改变后的名字-李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue的el属性和-mount优先级？"><a href="#Vue的el属性和-mount优先级？" class="headerlink" title="Vue的el属性和$mount优先级？"></a>Vue的el属性和$mount优先级？</h3><blockquote><p>比如下面这种情况，Vue会渲染到哪个节点上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#ggg&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这是官方的一张图，可以看出 <code>el</code>和 <code>$mount</code>同时存在时，<code>el优先级</code> &gt; <code>$mount</code></p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6331091cb145459e0b543c76e9bfc6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="自定义v-model"><a href="#自定义v-model" class="headerlink" title="自定义v-model"></a>自定义v-model</h3><blockquote><p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="attr">default</span>: &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算变量时，methods和computed哪个好？"><a href="#计算变量时，methods和computed哪个好？" class="headerlink" title="计算变量时，methods和computed哪个好？"></a>计算变量时，methods和computed哪个好？</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">howMuch1</span>()&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">howMuch2</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">index</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data: () &#123;</span></span><br><span class="line"><span class="language-xml">    return &#123;</span></span><br><span class="line"><span class="language-xml">         index: 0</span></span><br><span class="line"><span class="language-xml">       &#125;</span></span><br><span class="line"><span class="language-xml">     &#125;</span></span><br><span class="line"><span class="language-xml">methods: &#123;</span></span><br><span class="line"><span class="language-xml">    howMuch1() &#123;</span></span><br><span class="line"><span class="language-xml">        return this.num + this.price</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">computed: &#123;</span></span><br><span class="line"><span class="language-xml">    howMuch2() &#123;</span></span><br><span class="line"><span class="language-xml">        return this.num + this.price</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>computed</code>会好一些，因为computed会有 <code>缓存</code>。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。</p></blockquote><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="react的生命周期"><a href="#react的生命周期" class="headerlink" title="react的生命周期"></a>react的生命周期</h3><p>生命周期是什么？<br>react 实例的生命周期，就是react实例从初始化，更新，到销毁的过程</p><p>react实例生命周期经历三个阶段<br>初始化阶段：完成从react组件创建到首次渲染的过程</p><p>更新阶段：当调用setState函数时，会引起组件的重新渲染</p><p>销毁阶段：完成组件的销毁</p><p>三个阶段分别对应的构造函数有<br>初始化阶段：<br>constructor<br>构造函数里，可以做状态的初始化，接收props的传值<br>componentWillMount： 在渲染前调用，相当于vue中的beforeMount</p><p>render<br>渲染函数，不要在这里修改数据。 vue中也有render函数。</p><p>componentDidMount<br>渲染完毕，在第一次渲染后调用。</p><p>运行中阶段（更新）<br>当组件的 props 或 state 发生变化时会触发更新（严谨的说，是只要调用了setState（）或者改变了props时）。组件更新的生命周期调用顺序如下：</p><p>shouldComponentUpdate<br>是否更新？ 需要返回true或者false。如果是false，那么组件就不会继续更新了。</p><p>componentWillUpdate<br>即将更新。<br>componentWillReceiveProps(nextProps)： 在组件接收到一个新的 prop (更新后)时被调用。<br>这个方法在初始化render时不会被调用。nextProps 是props的新值，而 this.props是旧值。</p><p>render<br>不要在这里修改数据</p><p>componentDidUpdate<br>在组件完成更新后立即调用。在初始化时不会被调用。 相当于vue中的updated</p><p>销毁阶段（卸载）<br>componentWillUnmount()<br>即将卸载，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p><h3 id="为什么虚拟DOM-会提高性能"><a href="#为什么虚拟DOM-会提高性能" class="headerlink" title="为什么虚拟DOM 会提高性能"></a>为什么虚拟DOM 会提高性能</h3><p> 首先，（虚拟DOM是什么） 虚拟DOM就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&quot;p&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: <span class="string">&quot;width:200px;height: 100px;&quot;</span>,</span><br><span class="line">    <span class="attr">innerHTML</span>: <span class="string">&quot;我是p&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其次，操作虚拟DOM，就是在操作javascript对象，所以，并不会引起页面的重绘和重排。而操作真实DOM是会引起页面的重绘和重排的。</p><h3 id="React的diff原理"><a href="#React的diff原理" class="headerlink" title="React的diff原理"></a>React的diff原理</h3><p>传统diff算法<br>需要遍历整棵树的节点然后进行比较，是一个深度递归的过程，运算复杂度常常是O(n^3)</p><p>react diff的优化策略<br>DOM节点跨层级的操作不做优化，因为很少这么做，这是针对的tree层级的策略；<br>对于同一个类的组件，会生成相似的树形结构，对于不同类的组件，生成不同的树形结构，这是针对conponent层级的策略；<br>对于同一级的子节点，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；</p><h3 id="调用setState之后，发生了什么？"><a href="#调用setState之后，发生了什么？" class="headerlink" title="调用setState之后，发生了什么？"></a>调用setState之后，发生了什么？</h3><p>合并state<br>把传入setState（）里的参数对象和当前的state进行（属性）合并。 触发调和过程<br>（Reconciliation）</p><p>重新渲染组件<br>React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面<br>React 会自动计算出新的树与老树的节点差异（用diff算法），然后根据差异对界面进行最小化重<br>渲染</p><h3 id="state和props的区别"><a href="#state和props的区别" class="headerlink" title="state和props的区别"></a>state和props的区别</h3><p>state是组件的状态，也叫组件内部的数据</p><p>props是组件的属性，也可以认为是外部给组件传入的数据</p><h3 id="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"><a href="#React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？" class="headerlink" title="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"></a>React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？</h3><p>setState是异步的。</p><p>如果要拿到修改后的状态，需要使用回调函数的方式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态后想做一些事情：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  属性名:属性值</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//一般是用于在setState之后做一些操作</span></span><br><span class="line">  <span class="comment">//this.state == 修改之后的state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为什么不能直接用以下办法更新state"><a href="#为什么不能直接用以下办法更新state" class="headerlink" title="为什么不能直接用以下办法更新state"></a>为什么不能直接用以下办法更新state</h3><p>this.state.msg &#x3D; “hello”;</p><p>因为，这样不会引起组件的重新渲染，所以，数据修改后没法 呈现在页面上。</p><p>而调用setState()函数，会引起组件的重新渲染，这样更新的数据就会呈现在页面上。</p><h3 id="React-Class-组件有哪些周期函数？分别有什么作用？"><a href="#React-Class-组件有哪些周期函数？分别有什么作用？" class="headerlink" title="React Class 组件有哪些周期函数？分别有什么作用？"></a>React Class 组件有哪些周期函数？分别有什么作用？</h3><h3 id="React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？"><a href="#React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？" class="headerlink" title="React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？"></a>React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？</h3><h3 id="React-Class-组件和-React-Hook-的区别有哪些？"><a href="#React-Class-组件和-React-Hook-的区别有哪些？" class="headerlink" title="React Class 组件和 React Hook 的区别有哪些？"></a>React Class 组件和 React Hook 的区别有哪些？</h3><h3 id="React-中高阶函数和自定义-Hook-的优缺点？"><a href="#React-中高阶函数和自定义-Hook-的优缺点？" class="headerlink" title="React 中高阶函数和自定义 Hook 的优缺点？"></a>React 中高阶函数和自定义 Hook 的优缺点？</h3><h3 id="简要说明-React-Hook-中-useState-和-useEffect-的运行原理？"><a href="#简要说明-React-Hook-中-useState-和-useEffect-的运行原理？" class="headerlink" title="简要说明 React Hook 中 useState 和 useEffect 的运行原理？"></a>简要说明 React Hook 中 useState 和 useEffect 的运行原理？</h3><h3 id="React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"><a href="#React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？" class="headerlink" title="React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"></a>React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？</h3><h3 id="React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？"><a href="#React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？" class="headerlink" title="React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？"></a>React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？</h3><h3 id="React-的-useEffect-是如何监听数组依赖项的变化的？"><a href="#React-的-useEffect-是如何监听数组依赖项的变化的？" class="headerlink" title="React 的 useEffect 是如何监听数组依赖项的变化的？"></a>React 的 useEffect 是如何监听数组依赖项的变化的？</h3><h3 id="React-Hook-和闭包有什么关联关系？"><a href="#React-Hook-和闭包有什么关联关系？" class="headerlink" title="React Hook 和闭包有什么关联关系？"></a>React Hook 和闭包有什么关联关系？</h3><h3 id="React-中-useState-是如何做数据初始化的？"><a href="#React-中-useState-是如何做数据初始化的？" class="headerlink" title="React 中 useState 是如何做数据初始化的？"></a>React 中 useState 是如何做数据初始化的？</h3><h3 id="列举你常用的-React-性能优化技巧？"><a href="#列举你常用的-React-性能优化技巧？" class="headerlink" title="列举你常用的 React 性能优化技巧？"></a>列举你常用的 React 性能优化技巧？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="面试" scheme="https://superq314.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>VScode快捷键</title>
    <link href="https://superq314.github.io/2022/09/13/VScode/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://superq314.github.io/2022/09/13/VScode/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2022-09-13T06:35:15.000Z</published>
    <updated>2022-09-23T10:32:52.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>col1</th><th>col2</th></tr></thead><tbody><tr><td>单词跳跃</td><td>Alt</td></tr><tr><td>单词选中</td><td>Alt+shift</td></tr><tr><td>注释</td><td>ctrl+’&#x2F;‘</td></tr><tr><td>代码块注释</td><td>Alt+shift+’A’</td></tr><tr><td>tab对齐</td><td>Alt+shift+’F’</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="VScode" scheme="https://superq314.github.io/categories/VScode/"/>
    
    
  </entry>
  
  <entry>
    <title>前沿知识</title>
    <link href="https://superq314.github.io/2022/09/13/frontEnd/%E5%89%8D%E6%B2%BF%E7%9F%A5%E8%AF%86/"/>
    <id>https://superq314.github.io/2022/09/13/frontEnd/%E5%89%8D%E6%B2%BF%E7%9F%A5%E8%AF%86/</id>
    <published>2022-09-13T06:25:30.000Z</published>
    <updated>2022-09-23T10:25:45.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态网页技术</p><ul><li>JSP</li><li>ASP</li><li>PHP</li></ul><p>MVC template：分层技术</p><p>平台兼容</p><p>&#x3D;&#x3D;&gt; prototype、jQuery、MooTools、Dojo、modernizer</p><p>UI组件化</p><p>&#x3D;&#x3D;&gt; Bindows、YUII、jQuery UI、Ext、Bootstrap、Semantic UI</p><p>分层模块化</p><p>&#x3D;&#x3D;&gt; JavaScript MVC、BackBone、Knockout、Vue、EmberJS、Angular、React</p><p>相对地址：</p><pre><code>当前目录./上一级目录../下一级./imgs</code></pre><p>绝对地址</p><p>引用地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器输入url回车之后发生了什么</title>
    <link href="https://superq314.github.io/2022/09/10/computerBasics/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://superq314.github.io/2022/09/10/computerBasics/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-09-10T11:23:12.000Z</published>
    <updated>2022-09-23T07:24:25.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="url基本格式"><a href="#url基本格式" class="headerlink" title="url基本格式"></a>url基本格式</h2><p><a href="http://user:pass@www.example.jp/dir/index.html?uid=1#ch1">http://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</a></p><blockquote><p>http:&#x2F;&#x2F;&#x3D;&#x3D;&gt;     协议，方案名（可忽略），<br>user:pass    &#x3D;&#x3D;&gt;     登录信息（认证）（可忽略）<br>@<a href="http://www.example.jp/">www.example.jp</a>&#x3D;&#x3D;&gt;     服务器地址（可忽略），表明服务器的ip&#x2F;域名与当前HTML所属的一致<br>:80&#x3D;&#x3D;&gt;     服务器的端口号（可忽略）1、http协议&#x3D;&gt;80端口号2、https协议&#x3D;&gt;443端口号<br>&#x2F;dir&#x2F;index.html&#x3D;&#x3D;&gt;     带层次的文件路径<br>?uid&#x3D;1&#x3D;&#x3D;&gt;     查询字符串<br>#ch1&#x3D;&#x3D;&gt;     片段标识符（用于页面内跳转）</p></blockquote><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ul><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li><li>URL 解析</li><li>地址解析：</li></ul><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p>HSTS</p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。</p><p>其他操作</p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p>检查缓存</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter.png"></p><h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><p>基本步骤</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_baisc_process.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">浏览器缓存</button></li><li class="tab"><button type="button" data-href="#super-2">操作系统缓存</button></li><li class="tab"><button type="button" data-href="#super-3">路由器缓存</button></li><li class="tab"><button type="button" data-href="#super-4">ISP DNS 缓存</button></li><li class="tab"><button type="button" data-href="#super-5">根域名服务器查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>路由器也有自己的缓存。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_dns.png"></p><blockquote><p>根域名服务器：维基百科<br>需要注意的点</p></blockquote><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h2><p>TCP&#x2F;IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_tcp.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">应用层：发送 HTTP 请求</button></li><li class="tab"><button type="button" data-href="#super-2">传输层：TCP 传输报文</button></li><li class="tab"><button type="button" data-href="#super-3">网络层：IP 协议查询 Mac 地址</button></li><li class="tab"><button type="button" data-href="#super-4">链路层：以太网协议</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够準确地还原报文信息。<br>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP&#x2F;IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP&#x2F;IP 中，它位于网络层。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">以太网协议</button></li><li class="tab"><button type="button" data-href="#super-2">Mac 地址</button></li><li class="tab"><button type="button" data-href="#super-3">广播</button></li><li class="tab"><button type="button" data-href="#super-4">服务器接受请求</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方回应是单播。</p><blockquote><p>相关知识点：</p><ol><li>ARP 攻击</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>接受过程就是把以上步骤逆转过来，参见上图。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>大致流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_1.png"></p><p>HTTPD</p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p>处理请求</p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p>重定向</p><p>假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：详见这篇文章</p></blockquote><p>URL 重写</p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="浏览器接受响应"><a href="#浏览器接受响应" class="headerlink" title="浏览器接受响应"></a>浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h2 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h2><p>浏览器内核</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_broswer.png"></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p>基本流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_2.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">HTML 解析</button></li><li class="tab"><button type="button" data-href="#super-2">CSS 解析</button></li><li class="tab"><button type="button" data-href="#super-3">渲染树</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 解码（encoding）</button></li><li class="tab"><button type="button" data-href="#super-2">2. 预解析（pre-parsing）</button></li><li class="tab"><button type="button" data-href="#super-3">3.1 符号化（Tokenization）</button></li><li class="tab"><button type="button" data-href="#super-4">3.2 构建树（tree construction）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_html.png"></p><p>浏览器容错进制</p><p>你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p>事件</p><p>当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p>CSS 匹配规则</p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。</p></blockquote><p>计算</p><p>通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。</p><p>级联</p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li>!important</li></ol><p>然后得出一个权重值，取最高的那个。</p><p>渲染阻塞</p><p>当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">佈局与绘製</button></li><li class="tab"><button type="button" data-href="#super-2">合并渲染层</button></li><li class="tab"><button type="button" data-href="#super-3">回流与重绘</button></li><li class="tab"><button type="button" data-href="#super-4">JavaScript 编译执行</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>把以上绘制的所有图片合并，最终输出一张图片。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>回流 (reflow)</p><p>当浏览器发现某个部分发现变化影响了佈局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p>重绘 (repaint)</p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li>display:none 会触发回流，而 visibility:hidden 只会触发重绘。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>大致流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_3.png"></p><p>可以分为三个阶段：</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">词法分析</button></li><li class="tab"><button type="button" data-href="#super-2">预编译</button></li><li class="tab"><button type="button" data-href="#super-3">执行</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将var a &#x3D; 2，，分成var、a、&#x3D;、2这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p>创建执行上下文</p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>JS 线程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_7.png"></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p>注：浏览器对同一域名的併发连接数是有限的，通常为 6 个。</p><p>宏任务</p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p>微任务</p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：Promise，process.nextTick。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822185002.png"></p><p>代码例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="组成原理" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="组成原理" scheme="https://superq314.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
