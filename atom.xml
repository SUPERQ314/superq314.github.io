<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-09-22T14:51:29.655Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>generator生成器</title>
    <link href="https://superq314.github.io/2022/09/22/generator%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/09/22/generator%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2022-09-22T14:51:13.000Z</published>
    <updated>2022-09-22T14:51:29.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>生成器generator<br>　　生成器是一种返回迭代器的函数，通过function关键字后的星号(<em>)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格<br>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （iterator ）对象。<br>或者如果用的是 yield</em>（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行） 移交代码控制权<br>可以视作一个可以暂停和恢复执行的函数。<br>&#x2F;&#x2F; 生成器function* createIterator() {<br>    yield 1;<br>    yield 2;<br>    yield 3;<br>}<br>&#x2F;&#x2F; 生成器能像正规函数那样被调用，但会返回一个迭代器<br>let iterator &#x3D; createIterator();<br>console.log(iterator.next().value); &#x2F;&#x2F; 1<br>console.log(iterator.next().value); &#x2F;&#x2F; 2<br>console.log(iterator.next().value); &#x2F;&#x2F; 3<br>　　在这个示例中，createlterator()前的星号表明它是一个生成器；yield关键字也是ES6的新特性，可以通过它来指定调用迭代器的next()方法时的返回值及返回顺序。生成迭代器后，连续3次调用它的next()方法返回3个不同的值，分别是1、2和3。生成器的调用过程与其他函数一样，最终返回的是创建好的迭代器<br>　　生成器函数最有趣的部分是，每当执行完一条yield语句后函数就会自动停止执行。举个例子，在上面这段代码中，执行完语句yield 1之后，函数便不再执行其他任何语句，直到再次调用迭代器的next()方法才会继续执行yield 2语句。生成器函数的这种中止函数执行的能力有很多有趣的应用<br>　　使用yield关键字可以返回任何值或表达式，所以可以通过生成器函数批量地给迭代器添加元素。例如，可以在循环中使用yield关键字<br>function *createIterator(items) {<br>    for (let i &#x3D; 0; i &lt; items.length; i++) {<br>        yield items[i];<br>    }<br>}<br>let iterator &#x3D; createIterator([1, 2, 3]);<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 1, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 2, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 3, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: undefined, done: true }”<br>&#x2F;&#x2F; 之后的所有调用<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: undefined, done: true }”<br>　　在此示例中，给生成器函数createlterator()传入一个items数组，而在函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个yield语句循环都会停止；每次调用迭代器的next()方法，循环会继续运行并执行下一条yield语句<br>　　生成器函数是ES6中的一个重要特性，可以将其用于所有支持函数使用的地方<br>【使用限制】<br>　　yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误<br>function <em>createIterator(items) {<br>    items.forEach(function(item) {<br>        &#x2F;&#x2F; 语法错误<br>        yield item + 1;<br>    });<br>}<br>　　从字面上看，yield关键字确实在createlterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误<br>【生成器函数表达式】<br>　　也可以通过函数表达式来创建生成器，只需在function关键字和小括号中间添加一个星号(</em>)即可<br>let createIterator &#x3D; function *(items) {<br>    for (let i &#x3D; 0; i &lt; items.length; i++) {<br>        yield items[i];<br>    }<br>};<br>let iterator &#x3D; createIterator([1, 2, 3]);<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 1, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 2, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: 3, done: false }”<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: undefined, done: true }”<br>&#x2F;&#x2F; 之后的所有调用<br>console.log(iterator.next()); &#x2F;&#x2F; “{ value: undefined, done: true }”<br>　　在这段代码中，createlterator()是一个生成器函数表达式，而不是一个函数声明。由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间。此外，这个示例基本与前例相同，使用的也是for循环<br>　　[注意]不能用箭头函数来创建生成器<br>【生成器对象的方法】<br>　　由于生成器本身就是函数，因而可以将它们添加到对象中。例如，在ES5风格的对象字面量中，可以通过函数表达式来创建生成器<br>var o &#x3D; {<br>    createIterator: function <em>(items) {<br>            for (let i &#x3D; 0; i &lt; items.length; i++) {<br>                yield items[i];<br>            }<br>        }<br>};<br>let iterator &#x3D; o.createIterator([1, 2, 3]);<br>　　也可以用ES6的函数方法的简写方式来创建生成器，只需在函数名前添加一个星号(</em>)<br>var o &#x3D; {<br>    <em>createIterator(items) {<br>            for (let i &#x3D; 0; i &lt; items.length; i++) {<br>                yield items[i];<br>            }<br>        }<br>};<br>let iterator &#x3D; o.createIterator([1, 2, 3]);<br>　　这些示例使用了不同于之前的语法，但它们的功能实际上是等价的。在简写版本中，由于不使用function关键字来定义createlterator()方法，因此尽管可以在星号和方法名之间留白，但还是将星号紧贴在方法名之前<br>【状态机】<br>　　生成器的一个常用功能是生成状态机<br>let state &#x3D; function</em>(){<br>    while(1){<br>        yield ‘A’;<br>        yield ‘B’;<br>        yield ‘C’;<br>    }<br>}</p><p>let status &#x3D; state();<br>console.log(status.next().value);&#x2F;&#x2F;‘A’<br>console.log(status.next().value);&#x2F;&#x2F;‘B’<br>console.log(status.next().value);&#x2F;&#x2F;‘C’<br>console.log(status.next().value);&#x2F;&#x2F;‘A’<br>console.log(status.next().value);&#x2F;&#x2F;‘B’</p><p>应用场景：通过yield*实现非线性迭代</p><p>yield关键字后面可以跟随另一个generator对象或其他可迭代对象。<br>可以利用这个特性实现非线性结构的遍历</p><p>function* a(){<br>  yield ‘a1’<br>  yield ‘a2’<br>}<br>function* b(){<br>  yield ‘b1’<br>  yield* a()<br>  yield* [1, 2]<br>  yield ‘b2’<br>}<br>for(let item of b()){<br>  console.log(item)<br>}</p><p>&#x2F;&#x2F; b1 a1 a2 1 2 b2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>iterator迭代器</title>
    <link href="https://superq314.github.io/2022/09/22/iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/09/22/iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-09-22T14:50:35.000Z</published>
    <updated>2022-09-22T14:51:13.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>iterator迭代器<br>迭代器本质<br>迭代器对象是一种接口；本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。<br>【迭代器协议】<br>对象必须提供一个next()，执行该方法要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代。<br>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性</p><ul><li>value属性：迭代未完成时，返回当前位置的元素；迭代完成后，返回迭代器返回值或者缺省</li><li>done属性：一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()<br>对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。<br>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。<br>Iterator 的作用：<br>1.为各种数据结构，提供一个统一的、简便的访问接口<br>2.使得数据结构的成员能够按某种次序排列<br>3.主要供 for … of 使用<br>实现Iterator接口的原生对象<br>原生具备 Iterator 接口的数据结构如下。<br>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 类数组对象<br>DOM中的NodeList 类数组对象<br>数组的Symbol.iterator属性<br>const arr &#x3D; [1,2];<br>const arrayIterator &#x3D; arr<a href="">Symbol.iterator</a>;&#x2F;&#x2F;返回一个迭代器对象<br>console.log(arrayIterator);&#x2F;&#x2F; Array Iterator {}<br>console.log(arrayIterator.next());&#x2F;&#x2F; { value: 1, done: false }<br>console.log(arrayIterator.next());&#x2F;&#x2F; { value: 2, done: false }<br>console.log(arrayIterator.next());&#x2F;&#x2F; { value: undefined, done: true }</li></ul><p>Iterator接口<br>iterator必须实现next方法，该方法每次被调用时返回一个迭代器结果。<br>next()：被调用时返回一个iteratorResult对象<br>return()：被调用时返回一个iteratorResult对象，通常在调用者希望提前结束迭代时调用<br>throw()：被调用时返回一个iteratorResult对象，通常在调用者检测到错误时被调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://superq314.github.io/2022/09/22/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://superq314.github.io/2022/09/22/%E8%B7%A8%E5%9F%9F/</id>
    <published>2022-09-22T14:47:01.000Z</published>
    <updated>2022-09-22T14:48:39.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>跨域问题的解决方式<br>1、通过Jsonp<br>2、Document.domain + Iframe跨域<br>3、Iocation.hash + Iframe跨域<br>4、Window.name+Iframe跨域<br>5、PostMessage跨域<br>6、跨域资源共享（CORS）<br>7、nginx代理跨域<br>8、nodeJavaScripr中间代理跨域<br>9、WebSocket协议跨域</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://superq314.github.io/2022/09/22/jQuery/"/>
    <id>https://superq314.github.io/2022/09/22/jQuery/</id>
    <published>2022-09-22T14:46:36.000Z</published>
    <updated>2022-09-22T14:48:09.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jQuery<br>sass、less &#x3D;&gt; CSS预处理器<br>less：动态样式语言，给CSS赋予动态语言特性<br>动态语言特性：变量、继承、嵌套</p><p>跨域原因：<br>由于前后端分离 &#x3D;&gt; 前后端域名不一致 &#x3D;&gt; 出现跨越访问问题<br>同源策略 &#x3D;&gt; 只有协议 + 主机名 + 端口号相同（允许访问） </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="https://superq314.github.io/2022/09/22/ajax/"/>
    <id>https://superq314.github.io/2022/09/22/ajax/</id>
    <published>2022-09-22T14:46:20.000Z</published>
    <updated>2022-09-22T14:47:57.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AJAX &#x3D;&#x3D;&gt; 创建快速动态网页 &#x3D;&#x3D;&gt; 网页异步更新<br>核心：XMLHttpRequest对象<br>创建过程：<br>var xhttp;<br>if (window.XMLHttpRequest) {xhttp &#x3D; new XMLHttpRequest;}<br>else {<br>  &#x2F;&#x2F; code for IE5,IE6<br>  xhttp &#x3D; new ActiveXobject(“Microsoft.XMLHTTP”);<br>}</p><p>Ajax使用过程（5个步骤）<br>1、创建XMLHTTPRequest对象<br>2、使用open方法创建http请求，并设置请求地址xhr.open(get&#x2F;post, url, asynchronous,true异步, false同步)<br>3、设置发送的数据，用send发送请求<br>4、注册事件（给Ajax设置事件）<br>5、获取响应并更新页面</p><p>AJAX的XMLHttpRequest对象方法<br>方法描述<br>new XMLHttpRequest()创建新的XMLHttpRequest对象<br>abort()取消当前请求<br>getAllResponseHeaders()返回头部信息<br>getResponseHeader()返回特定的头部信息<br>open(method, url, async, user, psw)<br>规定请求method:请求类型<br>GET或POST<br>url:文件位置<br>async:true(异步)或false(同步)<br>user:可选的用户名<br>psw:可选的密码</p><p>send()将请求发送到服务器，用于GET 请求<br>send(string)将请求发送到服务器，用于POST 请求<br>setRequestHeader()向要发送的报头添加标签&#x2F;值对</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>class的继承</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2022-09-22T14:38:38.000Z</published>
    <updated>2022-09-22T14:45:03.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>class的继承<br>JavaScript 实现继承是件麻烦事，构造函数继承有加上原型上的函数不能复用的问题；原型链继承又存在引用值属性的修改不独立的问题；组合继承又存在两次调用构造函数的问题，寄生组合继承，写起来又太麻烦了</p><p>class的继承围绕三点进行展开描述：extends实现继承，super()引用父类的构造函数，多重继承。<br>1、如何实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>通过关键字<span class="keyword">extends</span>实现继承。具体操作步骤如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitename</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">present</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我喜欢&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sitename</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">present</span>() + <span class="string">&#x27;, 它创建了 &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; 年。&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> noob = <span class="keyword">new</span> <span class="title class_">Runoob</span>(<span class="string">&quot;菜鸟教程&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>子类必须在constructor方法中调用super方法<br>为什么必须要调用super方法呢？<br>这是因为这里的继承是先塑造父类，再塑造子类。也就是先将父类的东西都拿过来之后，再进行子类的添加。而super负责的就是将父类的东西拿过来。所以必须先调用super。</li><li>调用super之后才能使用this。也就是说在子类构造函数constructor里面，super函数要放在最上面。<br>为什么要这样呢？<br>刚才提到过，class的继承是先将父类拿过来再进行子类的添加，之前在讲借用构造函数实现继承的时候也提到过，如果想要给自身添加属性和方法，需要在调用call或者apply之后添加。否则如果存在同名属性，后面的会覆盖前面的。这里其实也是同样的道理。<br>2、super<br>class里面的super有两种使用方式，一种是当方法用，一种是当对象用。</li><li>当方法用<br>当方法用就像上面提到的，在constructor里面调用，负责将父类的实例属性拿过来。这个时候，super里面的this指向的是子类。<br>为什么这样呢？其实和借用构造函数实现继承是一样的，子类继承超类的实例属性时，就是通过call或者apply在子类调用超类构造函数。这个时候，this自然指向的就是子类。<br>还要注意一点 的是，其实上面也提到了，当方法用的时候，super必须放到constructor构造函数的最上层</li><li>当对象用<br>上一点说了，当方法用是为了将父类的实例属性继承过来(其实就是复制一份过来)。实例属性是拿到了，但方法呢，比如说有时候子类的方法想要调用父类的某个方法，这个时候要如何做？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;speak&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">speak</span>() <span class="comment">// speak</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">a.<span class="title function_">sayName</span>()</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">speak</span>()</span><br></pre></td></tr></table></figure>这个时候，super作为对象的所用就体现出来了，通过它可以调用父类的方法(包括静态方法)。<br>注意，不同类型的方法要在不同类型的方法里面调用。有点绕，其实就是子类的静态方法里面通过super只能调用父类的静态方法，不能调用父类的原型方法。同理，子类的原型方法通过super也只能调用父类的原型方法，不能调用父类的静态方法。<br>有点像组合继承，super方法就是借用构造函数继承，继承实例属性，super对象就是原型链继承，继承原型上的属性和方法。也就是说super对象是无法访问父类的实例属性的。<br>那么还有一个问题，通过super调用父类的方法，那么该方法内的this指向的是谁呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857835921.png" alt="1663857835921"><br>结果就是，this指向的是当前类(子类)的实例。所以我们通过super对某个属性进行修改，修改的就是子类实例的属性。<br>3、多重继承<br>有些面向对象编程语言是支持多重继承(即一个子类继承多个父类)，如c++， py。java不支持多继承，但可以通过实现多接口或者内部类的方式实现类似的效果。es6的class继承本质上还是基于原型链的继承，所以也是不支持多继承的。但就像java那样，我们也可以通过其他方式达到相同或者类似的效果。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;说话&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;19&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进食&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="comment">// 多重继承 一个子类继承多个父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">...mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        <span class="comment">// 拷贝实例属性</span></span><br><span class="line">        <span class="title function_">copyProperties</span>(<span class="variable language_">this</span>, <span class="keyword">new</span> <span class="title function_">mixin</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>, mixin) <span class="comment">// 拷贝静态属性</span></span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>.<span class="property"><span class="keyword">prototype</span></span>, mixin.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 拷贝原型属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mix</span>&#125;<span class="keyword">function</span> <span class="title function_">copyProperties</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="comment">// Reflect.ownKeys 返回所有属性key</span></span><br><span class="line">  <span class="comment">// Object.keys 返回属性key，不包括不可枚举属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;constructor&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;prototype&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// Object.getOwnPropertyDescriptor 返回指定对象上一个自有属性对应的属性描述符。</span></span><br><span class="line">      <span class="comment">// 自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性</span></span><br><span class="line">      <span class="comment">// 属性描述符指的是configurable、enumerable、writable、value这些</span></span><br><span class="line">      <span class="keyword">const</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, key)</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, desc)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;<span class="keyword">class</span> <span class="title class_">Other</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixin</span>(<span class="title class_">Animal</span>, <span class="title class_">Person</span>) &#123;&#125;<span class="keyword">const</span> oo = <span class="keyword">new</span> <span class="title class_">Other</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oo)</span><br></pre></td></tr></table></figure><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857864873.png" alt="1663857864873"><br>通过以上方式，也可以间接地实现类似多重继承的效果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%B1%BB/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/class%E7%B1%BB/</id>
    <published>2022-09-22T14:31:56.000Z</published>
    <updated>2022-09-22T14:37:24.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在es5中主要是通过构造函数方式和原型方式来定义一个类<br>在es6中可以通过class来定义类。<br>一个类只能拥有一个名为”constructor”构造函数，不能出现多个；<br>如果没有定义”constructor”构造函数，class会默认添加一个空的“constructor”构造函数。</p><h3 id="1、class类必须进行new调用，不能直接执行"><a href="#1、class类必须进行new调用，不能直接执行" class="headerlink" title="1、class类必须进行new调用，不能直接执行"></a>1、class类必须进行new调用，不能直接执行</h3><p>使用new调用类的构造函数会执行如下操作。<br>1.在内存中创建一个新对象；<br>2.这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性；<br>3.构造函数内部的this被赋值为这个新对象（即this指向新对象）；<br>4.执行构造函数内部的代码（给新对象添加属性）；<br>5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；</p><h3 id="2、class类不存在变量提升"><a href="#2、class类不存在变量提升" class="headerlink" title="2、class类不存在变量提升"></a>2、class类不存在变量提升</h3><h3 id="3、class类无法遍历其实例原型链上的属性和方法"><a href="#3、class类无法遍历其实例原型链上的属性和方法" class="headerlink" title="3、class类无法遍历其实例原型链上的属性和方法"></a>3、class类无法遍历其实例原型链上的属性和方法</h3><p>不可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest2</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// [ ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">// [&quot;constructor&quot;,&quot;newTest&quot;,&quot;newTest2&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="4、new-target属性"><a href="#4、new-target属性" class="headerlink" title="4、new.target属性"></a>4、new.target属性</h3><p>es6为new命令引入了一个new.target属性，它会返回new命令作用于的那个构造函数。<br>如果不是通过new调用或Reflect.construct()调用的，new.target会返回undefined</p><h3 id="5、class类有static静态方法"><a href="#5、class类有static静态方法" class="headerlink" title="5、class类有static静态方法"></a>5、class类有static静态方法</h3><p>static静态方法只能通过类调用，不会出现在实例上；<br>静态方法包含 this 关键字，这个 this 指的是类，而不是实例<br>static声明的静态属性和方法都可以被子类继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">baz</span>(); <span class="comment">// 此处的this指向类</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 不会出现在实例中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">bar</span>() <span class="comment">// undefined</span></span><br><span class="line">foo.<span class="title function_">baz</span>() <span class="comment">// world</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">bar</span>() <span class="comment">// this Foo hello </span></span><br></pre></td></tr></table></figure><p>getter 与 setter <br>在 class 内部可以使用 get 与 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (test) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = test || <span class="string">&#x27;默认值&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    get prop () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">test</span></span><br><span class="line">    &#125;</span><br><span class="line">    set prop (value) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setter prop value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 1</span></span><br><span class="line">p.<span class="property">prop</span> = <span class="string">&#x27;2&#x27;</span> <span class="comment">// setter prop value: 2</span></span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>默认严格模式<br>内部定义inside<br>立即执行<br>二次声明<br>实例无法调用static<br>static this指向类<br>继承包含static<br>Class内部只有静态方法，没有静态属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>尾调用</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/%E5%B0%BE%E8%B0%83%E7%94%A8/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/2functionalProgramming/functionalProgramming/%E5%B0%BE%E8%B0%83%E7%94%A8/</id>
    <published>2022-09-22T13:59:27.000Z</published>
    <updated>2022-09-22T14:03:23.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>定义：在执行某个函数时，如果最后一步是一个函数调用，并且被调用函数的返回值直接被函数返回，被称为尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>();<span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下两种情况，都不属于尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line"><span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内存中形成一个”调用记录”，又称”调用帧”，保存调用位置和内部变量等信息。</p><ol><li>函数A内部调用函数B，那么在A的调用记录上方，会形成一个B的调用记录。</li><li>等到B运行结束，将结果返回到函数A，B的调用记录才会消失。</li><li>如果函数B内部还调用了函数C，那还有一个C的调用记录栈，以此类推。</li><li>所有的调用记录形成一个”调用栈”。<br><img src="/image/%E5%B0%BE%E8%B0%83%E7%94%A8/1663855333356.png" alt="1663855333356"><br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。<br>尾调用的要求</li><li>尾调用不需要访问当前stackframe中的变量，也就是没有闭包。</li><li>返回到尾调用处时，不用再做其他事情。</li><li>尾调用的返回值，直接返回给调用它所在函数的调用者。</li></ol><p></p><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p><blockquote><p>因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>arguments：返回调用时函数的参数。</li><li>func.caller：返回调用当前函数的那个函数。<br>严格模式下开启尾调用优化，函数的调用栈会改写，从而会禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>symbol</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/symbol/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/symbol/</id>
    <published>2022-09-22T13:47:38.000Z</published>
    <updated>2022-09-22T13:50:12.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Symbol<br>由于symbol值是唯一的，可以避免<strong>为对象添加属性时 属性名产生冲突</strong>。</p><p>共享Symbol<br>Symbol.for()：在不同的地方使用同一个symbol，用来当作不同对象的唯一标识符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">[uid]:<span class="string">&quot;12345&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[uid]);<span class="comment">// &quot;12345&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid);<span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid === uid2);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[uid2]);<span class="comment">// &quot;12345&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uid2);<span class="comment">// Symbol(uid)</span></span><br></pre></td></tr></table></figure><p>SymbolkeyFor()：查找和某个symbol关联的key值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid));<span class="comment">// &quot;uid&quot;</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid2));<span class="comment">// &quot;uid&quot;</span></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="title class_">Symbol</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(uid3));<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ObjectgetOwnPropertySymbols()：查找对象的symbol属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;[id]:<span class="string">&#x27;123&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> symbols =0bject.<span class="title function_">getOwnPropertySymbols</span>(obiect);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbols.<span class="property">length</span>);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbols[<span class="number">0</span>]);<span class="comment">// Symbol(id)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object[symbols[<span class="number">0</span>]]);<span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>es6的内置symbol<br>es6内置了11个symbol，叫well-known symbol,它们都是Symbol函数的属性，指向语言内部使用的方法或属性。通过它们可以更改语言的原生行为。<br><img src="/image/symbol/1663854576292.png" alt="1663854576292"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模板字面量</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/</id>
    <published>2022-09-22T13:43:51.000Z</published>
    <updated>2022-09-22T13:47:13.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>定义：允许嵌入表达式的字符串字面量，可以使用多行字符串和字符串插值功能。可以保留反引号内的空格和换行符。</p><blockquote><p>开始和结尾的空格换行符可以通过trim方法去除</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">hello world`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)<span class="comment">// \nhello world</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>())<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><blockquote><p>严格意义上来说，模板字面量不是字符串，而是一种特殊的JavaScript表达式。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line">tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiLineStr = <span class="string">&#x27;&#x27;</span> + </span><br><span class="line">  <span class="string">`&lt;pre&gt;&#x27; + </span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;sb&quot;</span>&gt;<span class="title class_">This</span> is&lt;/code&gt;<span class="string">` +</span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;sb&quot;</span>&gt;a string&lt;/code&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">  `    &lt;code class=&quot;sb&quot;&gt;with multiple&lt;/code&gt;&#x27;</span> + </span><br><span class="line">  <span class="string">`    &lt;code class=&quot;sb&quot;&gt;lines&lt;/code&gt;&#x27; + </span></span><br><span class="line"><span class="string">  `</span>    &lt;code <span class="keyword">class</span>=<span class="string">&quot;p&quot;</span>&gt;;&lt;/code&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">  `&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>支持所有合法的JavaScript表达式，包括函数调用等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;getName()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>插值表达式支持嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classes = <span class="string">`header <span class="subst">$&#123; isLargeScreen()</span></span></span><br><span class="line"><span class="subst"><span class="string">? <span class="string">``</span></span></span></span><br><span class="line"><span class="subst"><span class="string">: <span class="string">`icon-<span class="subst">$&#123;(isCollapsed? <span class="string">&#x27;expander`: &#x27;</span>collapser<span class="string">&#x27;)&#125;`&#125;`;</span></span></span></span></span></span><br></pre></td></tr></table></figure><h3 id="模板字面量-tagged-template"><a href="#模板字面量-tagged-template" class="headerlink" title="模板字面量:tagged template"></a>模板字面量:tagged template</h3><p>最前面可以跟一个函数，这个函数叫模板字符串的tag。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">literals, ...substitutions</span>) &#123;</span><br><span class="line">    <span class="comment">// return a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板字面量:tagged template示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="string">&#x27;Mike&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTag</span>(<span class="params">strings, personExp,ageExp</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// &quot;that &quot;</span></span><br><span class="line">    <span class="keyword">let</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// &quot; is a &quot;</span></span><br><span class="line">    <span class="comment">// 最后还有一项，不过它的值是空字符串 &#x27; &#x27;</span></span><br><span class="line">    <span class="comment">// let str2 =strings[2];</span></span><br><span class="line">    <span class="keyword">let</span> ageStr;</span><br><span class="line">    <span class="keyword">if</span> (ageExp &gt; <span class="number">99</span>) &#123;</span><br><span class="line">        ageStr = <span class="string">&#x27;centenarian&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ageStr = <span class="string">&#x27;youngster&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str0 + personExp + str1 + ageStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> output = myTag<span class="string">`that <span class="subst">$&#123;person&#125;</span> is a <span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// that Mike is a youngster</span></span><br></pre></td></tr></table></figure><h3 id="模板字面量-原始字符串值-raw-value"><a href="#模板字面量-原始字符串值-raw-value" class="headerlink" title="模板字面量:原始字符串值(raw value)"></a>模板字面量:原始字符串值(raw value)</h3><p>tag函数的第一个参数，还有一个raw属性，它的值是模板字符串被转义之前的值，也可以使用内置的 String.raw方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message1 =<span class="string">`Multiline\nstring`</span>;</span><br><span class="line"><span class="title class_">Let</span> message2 = <span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Multiline\nstring`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message1);<span class="comment">// &quot;Multiline</span></span><br><span class="line">                        <span class="comment">// string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message2);<span class="comment">// &quot;Multilinel\nstring&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Modules</title>
    <link href="https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/Modules/"/>
    <id>https://superq314.github.io/2022/09/22/frontEnd/3JavaScript/7newFeaturesofES/Modules/</id>
    <published>2022-09-22T13:31:55.000Z</published>
    <updated>2022-09-22T13:39:40.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Modules语法-amp-特性"><a href="#Modules语法-amp-特性" class="headerlink" title="Modules语法&amp;特性"></a>Modules语法&amp;特性</h2><p>模块功能主要由两个命令构成：<code>export</code>和 <code>import</code>。<br>**<code>export</code>**命令：规定模块的对外接口<br>**<code>import</code>**命令：输入其他模块提供的功能</p><p>export命令</p><p>一个modules模块就是一个独立的文件。该文件内部的所有变量，外部无法获取到。</p><blockquote><p>如果希望外部能够读取模块内部的某个变量，就必须使用<strong>export</strong>关键字输出该变量。</p></blockquote><p>案例如下，一个JS文件使用<strong>export</strong>命令输出变量。</p><p>写法一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>上面代码是<strong>profile.js</strong>文件，保存了用户信息。</p><blockquote><p>ES6 将其视为一个模块，里面用<strong>export</strong>命令对外部输出了三个变量。</p></blockquote><p>写法二</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span>  &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure><p>在<strong>export</strong>命令后面，使用大括号指定所要输出的一组变量。</p><blockquote><p>与写法一（直接放置在<strong>var</strong>语句前）等价</p></blockquote><blockquote><p>但是应该优先考虑使用写法二。</p></blockquote><blockquote><p>因为可以在脚本尾部，直接知道输出了哪些变量。</p></blockquote><p><strong>as</strong>关键字重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<strong>export</strong>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<strong>import</strong>命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>import</strong>命令，用于加载<strong>profile.js</strong>文件，并从中输入变量。</p><p><strong>import</strong>命令接受一对大括号，里面指定要从其他模块导入的变量名。</p><p>大括号里面的变量名，必须与被导入模块（<strong>profile.js</strong>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<strong>import</strong>命令要使用<strong>as</strong>关键字，将输入的变量重命名。</p><p><code>import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;</code></p><p><img src="/image/Modules/1663853855311.png" alt="1663853855311"></p><p><img src="/image/Modules/1663853861302.png" alt="1663853861302"></p><p><img src="/image/Modules/1663853869366.png" alt="1663853869366"></p><p><img src="/image/Modules/1663853876561.png" alt="1663853876561"></p><p><img src="/image/Modules/1663853881292.png" alt="1663853881292"></p><p><img src="/image/Modules/1663853886119.png" alt="1663853886119"></p><h2 id="Modules特性"><a href="#Modules特性" class="headerlink" title="Modules特性"></a>Modules特性</h2><ul><li>以接口方式曝露，采用引用的方式;</li><li>Module中也可以import</li><li>模块中this是无意义，且模块单独一作用域，外部不可见</li><li>同一个模块被引用多次，只执行一次</li></ul><h2 id="Modules加载机制"><a href="#Modules加载机制" class="headerlink" title="Modules加载机制"></a>Modules加载机制</h2><p>1、异步加载 async</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对于type=module的时候，默认异步加载 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载完成，渲染引擎就会中断渲染立即执行。此外，执行完成后，再恢复渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、延迟加载 defer</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.is&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Modules错误范例和正确实践"><a href="#Modules错误范例和正确实践" class="headerlink" title="Modules错误范例和正确实践"></a>Modules错误范例和正确实践</h2><p>Modules正确实践</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a, b&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>错误案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内容布局方式-rem适配布局</title>
    <link href="https://superq314.github.io/2022/09/16/frontEnd/2CSS/%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/"/>
    <id>https://superq314.github.io/2022/09/16/frontEnd/2CSS/%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/</id>
    <published>2022-09-16T02:31:18.000Z</published>
    <updated>2022-09-20T02:32:34.560Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rem适配布局——[混合布局]<br>rem是CSS的长度单位，相当于元素对的font-size的相对值<br>假如</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size: 20px; </span><br><span class="line">&#125;</span><br><span class="line">=<span class="language-ruby">=&gt; 1rem = 20px</span></span><br></pre></td></tr></table></figure><p>rem会随着设备的大小变化而发生相应的改变<br>解决了流式布局和flex布局不能变化高度的问题</p><ol><li>rem + 媒体查询技术<br>&#x3D;&#x3D;&gt; 实现元素大小动态变化</li><li>rem + flexible.is（淘宝技术）<br>将页面的一行分成10份，可以快速布局<br>&#x3D;&#x3D;&gt; 实现元素大小动态变化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Html-标签粗解</title>
    <link href="https://superq314.github.io/2022/09/16/frontEnd/1Html/Html-%E6%A0%87%E7%AD%BE%E7%B2%97%E8%A7%A3/"/>
    <id>https://superq314.github.io/2022/09/16/frontEnd/1Html/Html-%E6%A0%87%E7%AD%BE%E7%B2%97%E8%A7%A3/</id>
    <published>2022-09-16T01:57:22.000Z</published>
    <updated>2022-09-16T02:29:34.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>&lt;a&gt;&lt;/a&gt;</code><br>作用：</p><ul><li>另一个文档</li><li>文档内部</li><li>Email地址</li><li>电话号码</li></ul><p>属性</p><ul><li>href</li><li>target</li><li>download</li><li>hreflang</li><li>rel</li><li>rev</li><li>type</li><li>referrerpolicy</li></ul><p>target中属性值</p><ul><li>_self</li><li>_blank</li><li>_parent</li><li>_top</li></ul><p>举例：<br>创建锚点<br><code>&lt;a href=&quot;#&quot;&gt;×××&lt;/a&gt;</code><br>链接Email地址<br><code>&lt;a href=&quot;mailto:1078857679@qq.com&quot;&gt;×××&lt;/a&gt;</code><br>链接电话<br><code>&lt;a href=&quot;tel:15651005256&quot;&gt;×××&lt;/a&gt;</code><br>文件下载<br><code>&lt;a href=&quot;/keyboard-shortcuts.pdf&quot; download&gt;×××&lt;/a&gt;</code><br><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code></p><ul><li>引用内容</li><li>属性<ul><li>cite<br><code>&lt;em&gt;&lt;/em&gt;</code><br>强调，需要用户着重阅读的内容</li></ul></li><li>默认斜体</li><li>可以嵌套<br><code>&lt;strong&gt;&lt;/strong&gt;</code><br>严重&#x2F;重要&#x2F;紧急的内容</li><li>标题、警告、注意事项、指示性内容</li><li>默认粗体</li><li>可以嵌套<br><code>&lt;span&gt;&lt;/span&gt;</code><br>无任何特殊含义</li><li>行内容器</li><li>样式<br><code>&lt;img&gt;</code><br>图像<br>属性</li><li>src</li><li>alt</li><li>width</li><li>height</li><li>srcset    宽度描述符</li><li>sizes<br>插入图片<br>picture容器 + source<br>source属性</li><li>srcset</li><li>type</li><li>sizes</li><li>media<br>图片热点<br>area属性</li><li>download</li><li>hreflang</li><li>rel</li><li>target</li><li>type</li><li>referrerpolicy<br><code>&lt;video&gt;&lt;/video&gt;</code><br>视频、影片、带字幕的音频<br>属性</li><li>src</li><li>width</li><li>height</li><li>poster</li><li>preload</li><li>autoplay</li><li>loop</li><li>muted</li><li>controls</li><li>crossorigin<br>内嵌标签<br>source</li><li>src</li><li>type<br>track</li><li>kind<ul><li>subtitles</li><li>captions</li><li>descriptions</li><li>chapters</li><li>metadata</li></ul></li><li>srcset</li><li>srclang</li><li>label</li><li>default<br><code>&lt;audio&gt;&lt;/audio&gt;</code><br>音频<br>属性</li><li>src</li><li>preload</li><li>autoplay</li><li>loop</li><li>muted</li><li>controls</li><li>crossorigin<br><code>&lt;iframe&gt;&lt;/iframe&gt;</code><br>内嵌的浏览上下文<br>另一个HTML页面嵌入到当前页面中<br>属性</li><li>src</li><li>width</li><li>height</li><li>name</li><li>sandbox<ul><li>allow-forms</li><li>allow-pointer-lock</li><li>allow-popups</li><li>allow-presentation</li><li>allow-same-origin</li><li>allow-scripts</li><li>allow-top-navigation<br><code>&lt;form&gt;&lt;/form&gt;</code><br>label<br>input<br>fieldset<br>select<br>textarea<br>button<br>output<br>object<br>meter<br>progressimg</li></ul></li><li>label<br>表单控件的标题</li><li>select<br>列表选择器</li><li>不加      默认单选</li><li>multiple  多选模式配置</li><li>size&#x3D;”4”  单选（四选一）</li></ul><p>状态禁用<br>选择器禁用<select disabled><br>选项禁用<option disabled><br>选项组禁用<optgroup disabled></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="https://superq314.github.io/2022/09/14/frontEnd/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://superq314.github.io/2022/09/14/frontEnd/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-14T05:11:25.000Z</published>
    <updated>2022-09-14T05:44:36.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="语义话的目的是什么？"><a href="#语义话的目的是什么？" class="headerlink" title="语义话的目的是什么？"></a>语义话的目的是什么？</h3><p>语义化的主要目的可以概括为用正确的标签做正确的事</p><p>HTMl语义化可以让页面的内容结构化，以便于浏览器解析和搜索引擎解析，<br>并且提高了代码的可读性便于代码维护，</p><h3 id="HTML5新增元素"><a href="#HTML5新增元素" class="headerlink" title="HTML5新增元素"></a>HTML5新增元素</h3><p>Canvas绘图以及SVG绘图。<br>拖放（Drag and drop）API<br>语义化标签（header、nav、footer、article、section）<br>音频、视频（audio、video）API<br>地理定位（Geolocation）<br>本地离线存储（localStorage）,长期存储数据，关闭浏览器后不丢失。<br>会话储存（sessionStorage）,数据在关闭浏览器后自动删除。<br>表单控件（calendar、date、time、email、url、search）</p><h3 id="cookie与sessionStorage和localStorage的区别"><a href="#cookie与sessionStorage和localStorage的区别" class="headerlink" title="cookie与sessionStorage和localStorage的区别"></a>cookie与sessionStorage和localStorage的区别</h3><ul><li>保存方式<ul><li>cookie存放在客户的浏览器上。</li><li>session都在客户端中保存，不参与服务器通讯。</li></ul></li><li>生命周期<ul><li>cookie可设置失效时间</li><li>localStorage除非手动清除否则永久保存</li><li>sessionStorage关闭当前页面或浏览器后失效</li></ul></li><li>存储的大小<ul><li>cookie 4kb左右</li><li>session 5M</li></ul></li><li>易用性<ul><li>cookie需自己封装</li><li>session可以接受原生接口</li></ul></li></ul><p>因为cookie每次请求都会携带在http请求中,所以它的主要用来识别用户登录,localStorage可以用来跨页面传参,sessionStorage可以用来保留一些临时数据。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS有哪些基本的选择器，执行先后顺序？"><a href="#CSS有哪些基本的选择器，执行先后顺序？" class="headerlink" title="CSS有哪些基本的选择器，执行先后顺序？"></a>CSS有哪些基本的选择器，执行先后顺序？</h3><p>id选择器 &#x3D;&gt; #myId {}<br>类选择器 &#x3D;&gt; .myClass {}<br>标签选择器 &#x3D;&gt; p,h1 {}<br>后代选择器 &#x3D;&gt; div h1 {}<br>子选择器 &#x3D;&gt; div&gt;h1 {}<br>兄弟选择器(所有的兄弟) &#x3D;&gt; ul~h1 {}<br>相邻兄弟选择器 &#x3D;&gt; ul+h1 {}<br>属性选择器 &#x3D;&gt; li[name&#x3D;’sss’] {}<br>伪类选择器 &#x3D;&gt; h1:hover {}<br>伪元素选择器 &#x3D;&gt; h1::before{}<br>通配符选择器* &#x3D;&gt; * {}</p><p>!important&gt;内联样式（非选择器）&gt;ID选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器（*）</p><h3 id="垂直水平居中方式有哪些？"><a href="#垂直水平居中方式有哪些？" class="headerlink" title="垂直水平居中方式有哪些？"></a>垂直水平居中方式有哪些？</h3><h3 id="常用布局方式有哪些？什么是盒模型？"><a href="#常用布局方式有哪些？什么是盒模型？" class="headerlink" title="常用布局方式有哪些？什么是盒模型？"></a>常用布局方式有哪些？什么是盒模型？</h3><h3 id="常用的块元素与行内元素有哪些？有什么特征"><a href="#常用的块元素与行内元素有哪些？有什么特征" class="headerlink" title="常用的块元素与行内元素有哪些？有什么特征"></a>常用的块元素与行内元素有哪些？有什么特征</h3><p>块元素：div、h1~h6、ul、li、table、p、br、form。<br>特征：独占一行，换行显示，可以设置宽高，可以嵌套块和行</p><p>行内元素：span、a、img、textarea、select、option、input。<br>特征：只有在行内显示，内容撑开宽、高，不可以设置宽、高（img、input、textarea等除外）。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>父级div定义overflow:hidden（如果父级元素有定位元素超出父级，超出部分会隐藏，）<br>给浮动元素父级增加标签（由于新增标签会造成不必要的渲染，不建议使用）<br>伪元素清除浮动：给浮动元素父级增加 .clearfix::after（content: ‘’; display: table;<br>clear: both;）（不会新增标签，不会有其他影响，）</p><h3 id="CSS3新特征"><a href="#CSS3新特征" class="headerlink" title="CSS3新特征"></a>CSS3新特征</h3><p>圆角（border-radius）<br>阴影（box-shadow）<br>文字特效(text-shadow)<br>线性渐变（gradient）<br>变换(transform)<br>更多的CSS选择器<br>更多背景设置（background）<br>色彩模式（rgba）<br>伪元素（::selection）<br>媒体查询（@media）<br>多栏布局（column）<br>图片边框（border-image）</p><h3 id="CSS中有哪些长度单位？"><a href="#CSS中有哪些长度单位？" class="headerlink" title="CSS中有哪些长度单位？"></a>CSS中有哪些长度单位？</h3><p>绝对长度单位：px<br>百分比: %<br>相对父元素字体大小单位: em<br>相对于根元素字体大小的单位: rem<br>相对于视口<em>宽度的百分比（100vw即视窗宽度的100%）: vw<br>相对于视口</em>高度的百分比（100vh即视窗高度的100%）: vh</p><h3 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h3><h3 id="display-none和visibility-hidden的区别"><a href="#display-none和visibility-hidden的区别" class="headerlink" title="display:none和visibility:hidden的区别"></a>display:none和visibility:hidden的区别</h3><p>display:none：隐藏元素，在文档布局中不在给它分配空间（从文档中移除），会引起回流（重排）<br>visibility:hidden: 隐藏元素，但是在文档布局中仍保留原来的空间（还在文档中），不会引起回流（重绘）</p><h3 id="用CSS-实现三角形"><a href="#用CSS-实现三角形" class="headerlink" title="用CSS 实现三角形"></a>用CSS 实现三角形</h3><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><h3 id="什么是重绘，重排？如何解决？"><a href="#什么是重绘，重排？如何解决？" class="headerlink" title="什么是重绘，重排？如何解决？"></a>什么是重绘，重排？如何解决？</h3><h4 id="重绘（repaint-x2F-redraw）"><a href="#重绘（repaint-x2F-redraw）" class="headerlink" title="重绘（repaint&#x2F;redraw）"></a>重绘（repaint&#x2F;redraw）</h4><p>某个dom节点的颜色，背景颜色变了，字体大小，只影响自己，不影响其他元素。</p><p>注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p><h4 id="重排（回流-x2F-reflow-x2F-重构）"><a href="#重排（回流-x2F-reflow-x2F-重构）" class="headerlink" title="重排（回流&#x2F;reflow&#x2F;重构）"></a>重排（回流&#x2F;reflow&#x2F;重构）</h4><p>某个dom节点的宽高，布局，隐藏等发生改变，不仅自身发生了改变，而且其他元素也会受到影响随之发生改变。每个页面最少一次回流，就是页面第一次加载的时候。</p><h4 id="触发重排的原因"><a href="#触发重排的原因" class="headerlink" title="触发重排的原因"></a>触发重排的原因</h4><p>页面初始化渲染（无可避免）<br>添加或删除可见的DOM元素<br>元素尺寸的改变——大小，外边距；边框<br>浏览器窗口尺寸的变化<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变<br>读取某些元素属性：（offsetLeft&#x2F;Top&#x2F;Height&#x2F;Width,　clientTop&#x2F;Left&#x2F;Width&#x2F;Height,　scrollTop&#x2F;Left&#x2F;Width&#x2F;Height,　width&#x2F;height,　getComputedStyle(), currentStyle(IE))</p><blockquote><p>1.重绘不一定重排，但是重排一定会重绘<br>2.重绘和重排的成本都是非常高的，要尽量减少dom的增删改</p></blockquote><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>不要直接操作样式，先设置好class，然后修改DOM的className;<br>position:absolute 与flex 不会导致重排<br>不要把DOM 节点的属性放在一个循环当成循环的变量；<br>需要动画的元素脱离文档流；<br>不使用table 布局，<br>尽量不修改影响范围比较大的DOM;<br>如果要多次添加DOM,先使用  document.createDocumentFragment() 创建一个盒子，完盒子里面先添加子元素，添加完成在插入元素中；</p><h3 id="transition-都有哪些过度属性？"><a href="#transition-都有哪些过度属性？" class="headerlink" title="transition 都有哪些过度属性？"></a>transition 都有哪些过度属性？</h3><h3 id="link和-import的区别？"><a href="#link和-import的区别？" class="headerlink" title="link和@import的区别？"></a>link和@import的区别？</h3><p>link属于html标签，而@import是css提供的。<br>页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载的。<br>兼容性问题：@import只在IE5以上才能识别，而link是html标签，无兼容性问题。<br>权重问题:@import的权重要高于link。<br>DOM操作:DOM可以操作link中的样式，而不可以操作@import中的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html 文件 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- link 方式，推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @import 方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@import</span> url(style.css);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用的动画库有哪些？"><a href="#常用的动画库有哪些？" class="headerlink" title="常用的动画库有哪些？"></a>常用的动画库有哪些？</h3><h3 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h3><h3 id="href与src的区别"><a href="#href与src的区别" class="headerlink" title="href与src的区别"></a>href与src的区别</h3><h3 id="如何让-CSS-只在当前组件中起作用？"><a href="#如何让-CSS-只在当前组件中起作用？" class="headerlink" title="如何让 CSS 只在当前组件中起作用？"></a>如何让 CSS 只在当前组件中起作用？</h3><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code>。</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><h3 id="call、apply、bind-作用和区别（改变this指向）"><a href="#call、apply、bind-作用和区别（改变this指向）" class="headerlink" title="call、apply、bind 作用和区别（改变this指向）"></a>call、apply、bind 作用和区别（改变this指向）</h3><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><h3 id="JS基本数据类型"><a href="#JS基本数据类型" class="headerlink" title="JS基本数据类型"></a>JS基本数据类型</h3><h3 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h3><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li>语法更加简洁、清晰，&#x3D;&gt;()</li><li>箭头函数是匿名函数，不能作为构造函数，不能使用new</li><li>箭头函数不能使用arguments，而用reat参数…解决</li><li>箭头函数没有自己的this,会捕获其所在的上下文的this值,并且不能通过call()和apply()来改变其this</li><li>箭头函数没有原型</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><h3 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h3><p>常见的：<br>    原型链继承<br>    借用构造函数继承<br>    原型链 + 借用构造函数的组合继承（使用 call 或 applay 方法）<br>    ES6中class 的继承（class可以通过extends关键字实现继承）</p><h3 id="简述一下你理解的面向对象"><a href="#简述一下你理解的面向对象" class="headerlink" title="简述一下你理解的面向对象"></a>简述一下你理解的面向对象</h3><p>面向对象是基于万物皆对象这个哲学观点. 把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性和方法，也就是把一类事物的算法和数据结构封装在一个类之中,程序就是多个对象和互相之间的通信组成的。</p><p><strong>面向对象具有封装性,继承性,多态性。</strong></p><p>封装：隐蔽了对象内部不需要暴露的细节,使得内部细节的变动跟外界脱离,只依靠接口进行通信.封装性降低了编程的复杂性。<br>继承：使得新建一个类变得容易,一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。<br>多态：继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应,极大地提高了代码的通用性.。</p><h3 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别</h3><h3 id="数组有哪些方法？"><a href="#数组有哪些方法？" class="headerlink" title="数组有哪些方法？"></a>数组有哪些方法？</h3><h3 id="数组去重（笔试一般都会有）"><a href="#数组去重（笔试一般都会有）" class="headerlink" title="数组去重（笔试一般都会有）"></a>数组去重（笔试一般都会有）</h3><h3 id="JS中new操作符有什么用？"><a href="#JS中new操作符有什么用？" class="headerlink" title="JS中new操作符有什么用？"></a>JS中new操作符有什么用？</h3><p>创建临时对象，并将this指向临时对象<br>将构造函数的原型属性和方法挂载到新对象的__proto__(原型指针)上<br>return 临时对象</p><h3 id="JS获取HTML-DOM元素的方法"><a href="#JS获取HTML-DOM元素的方法" class="headerlink" title="JS获取HTML DOM元素的方法"></a>JS获取HTML DOM元素的方法</h3><p>通过ID获取（getElementById）<br>通过name属性（getElementsByName）<br>通过标签名（getElementsByTagName）<br>通过类名（getElementsByClassName）<br>获取html的方法（document.documentElement）<br>获取body的方法（document.body）<br>通过选择器获取一个元素（querySelector）<br>通过选择器获取一组元素（querySelectorAll）</p><h3 id="事件捕获和事件冒泡"><a href="#事件捕获和事件冒泡" class="headerlink" title="事件捕获和事件冒泡"></a>事件捕获和事件冒泡</h3><ul><li>事件捕获和事件冒泡主要解决了页面事件流的问题。页面的事件流经过了三个阶段，分别是事件捕获、目标阶段和事件冒泡阶段。</li><li>事件捕获是由外向内；而事件冒泡则是由内向外。</li><li>event.stopPropagation() 可以阻止事件流的进一步传播。</li><li>采用事件代理的方式，能够节省内存消耗，对于动态改变子元素的时候，也非常有利，避免了很多麻烦的步骤，比如重新绑定事件。（把子元素的事件委托给父元素来处理）</li></ul><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>定义：虚拟DOM就是普通的js对象。用来描述真实dom结构的js对象，因为它不是真实的dom，所以才叫做虚拟dom。<br>作用：虚拟dom可以很好地跟踪当前dom状态，因为它会根据当前数据生成一个描述当前dom结构的虚拟dom，然后数据发生变化时，有生成一个新的虚拟dom，而两个虚拟dom恰好保存了变化前后的状态。然后通过diff算法，计算出当前两个虚拟dom之间的差异，得出一个更好的替换方案。</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>冒泡排序：比较所有相邻元素,如果第一个比第二个大，则交换它们。<br>选择排序：找到数组中的最小值，选中它并将其放置在第一位。<br>插入排序：从第二个数开始往前比，比它大就往后排。<br>归并排序：把数组劈成两半，再递归地对数组进行“分”操作，直到分成一个个单独的数。<br>快速排序：从数组中任意选择一个基准，所有比基准小的元素放到基准前面，比基准大的元素放到基准的后面。</p><h3 id="数组操作方法会改变原数组"><a href="#数组操作方法会改变原数组" class="headerlink" title="数组操作方法会改变原数组"></a>数组操作方法会改变原数组</h3><p>会改变：push()，pop(),shift(),unshift() ,splice(),sort(),reverse()。<br>不变：concat(),split(),slice()。</p><h3 id="JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用"><a href="#JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用" class="headerlink" title="JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用"></a>JS中substr（）、substring（）、slice（）、splice（）、split（）的区别与作用</h3><h3 id="JS有几种方法判断变量的类型？"><a href="#JS有几种方法判断变量的类型？" class="headerlink" title="JS有几种方法判断变量的类型？"></a>JS有几种方法判断变量的类型？</h3><p>typeof：</p><pre><code>判断基本数据类型，对于引用数据类型除了function返回’function‘，其余全部返回’object’。</code></pre><p>instanceof：</p><pre><code>区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined, null, symbol检测不出来。</code></pre><p>instanceof的实现原理：</p><pre><code>验证当前类的原型prototype是否会出现在实例的原型链__proto__上，只要在它的原型链上，则结果都为true。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，找到返回true，未找到返回false。</code></pre><p>constructor：</p><pre><code>检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。</code></pre><p>Object.prototype.toString.call()：</p><pre><code>适用于所有类型的判断检测，检测方法是Object.prototype.toString.call(数据) 返回的是该数据类型的字符串。(举例：字符串返回的是[object String])</code></pre><p>Object.prototype.toString.call原理：</p><pre><code>Object.prototype.toString 表示一个返回对象类型的字符串，call()方法可以改变this的指向，那么把Object.prototype.toString()方法指向不同的数据类型上面，返回不同的结果</code></pre><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p>null和undefined 区别为：undefined是表示变量声明过但并未赋过值，它是所有未赋值变量默认值；null表示一个变量将来可能指向一个对象，一般用于主动释放指向对象的引用。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>（1）undefined：是所有没有赋值变量的默认值，自动赋值<br>（2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址</p><h4 id="null与undefined的异同点是什么呢？"><a href="#null与undefined的异同点是什么呢？" class="headerlink" title="null与undefined的异同点是什么呢？"></a>null与undefined的异同点是什么呢？</h4><p>共同点： 都是原始类型，保存在栈中变量本地<br>不同点：<br>（1）undefined——表示变量声明过但并未赋过值。<br>它是所有未赋值变量默认值。<br>例如：var a; &#x2F;&#x2F;a自动被赋值为undefined<br>（2）null——表示一个变量将来可能指向一个对象。<br>一般用于主动释放指向对象的引用。</p><h4 id="何时使用null"><a href="#何时使用null" class="headerlink" title="何时使用null?"></a>何时使用null?</h4><p>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null</p><h3 id="什么是跨域？及跨域解决方法"><a href="#什么是跨域？及跨域解决方法" class="headerlink" title="什么是跨域？及跨域解决方法"></a>什么是跨域？及跨域解决方法</h3><h3 id="防抖和节流的使用及区别"><a href="#防抖和节流的使用及区别" class="headerlink" title="防抖和节流的使用及区别"></a>防抖和节流的使用及区别</h3><h3 id="栈内存和堆内存的区别与原理"><a href="#栈内存和堆内存的区别与原理" class="headerlink" title="栈内存和堆内存的区别与原理"></a>栈内存和堆内存的区别与原理</h3><h3 id="深拷贝和浅拷贝的区别和与原理"><a href="#深拷贝和浅拷贝的区别和与原理" class="headerlink" title="深拷贝和浅拷贝的区别和与原理"></a>深拷贝和浅拷贝的区别和与原理</h3><h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><p>新增块级作用域let定义变量和const定义常量<br>变量的解构赋值<br>模板字符串 （‘${}’）<br>默认参数（key&#x3D;value）<br>箭头函数（&#x3D;&gt;）<br>扩展运算符（…）<br>模块（import&#x2F;export）<br>类（class&#x2F;extends）<br>Promise<br>Proxy<br>Symbol</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>含义： 异步编程的一种解决方案，用来解决回调地狱。<br>三种状态： pending（进行中）、fulfilled（已成功）和rejected（已失败） （Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。）</p><p>resolved函数作用：将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved）。<br>reject函数的作用：将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected）。</p><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<br>then: Promise 实例添加状态改变时的回调函数。可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。</p><p>缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><h2 id="计算机网络知识"><a href="#计算机网络知识" class="headerlink" title="计算机网络知识"></a>计算机网络知识</h2><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p>HTTP：客户端与服务器之间数据传输的格式规范，表示“超文本传输协议”。<br>HTTPS：在HTTP与TCP之间添加的安全协议层。<br>默认端口号：HTTP：80，HTTPS：443。<br>传输方式：http是明文传输，https则是具有安全性的ssl加密传输协议。<br>连接方式：http的是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信TCP首部开销20字节;UDP的首部开销小，只有8个字节。<br>TCP提供可靠的服务。UDP适用于一次只传少量数据、对可靠要求不高的环境。</p><h3 id="HTTP常见的状态码"><a href="#HTTP常见的状态码" class="headerlink" title="HTTP常见的状态码"></a>HTTP常见的状态码</h3><ul><li>1 开头的状态码(信息类)<br>100，接受的请求正在处理，信息类状态码</li><li>2 开头的状态码(成功类)<br>2xx(成功)表示成功处理了请求的状态码<br>200(成功)服务器已成功处理了请求。</li><li>3 开头的状态码(重定向)<br>3xx(重定向)表示要完成请求，需要进一步操作。通常这些状态代码用来重定向。<br>301，永久性重定向，表示资源已被分配了新的 URL<br>302，临时性重定向，表示资源临时被分配了新的 URL<br>303，表示资源存在另一个URL，用GET方法获取资源<br>304，(未修改)自从上次请求后，请求网页未修改过。服务器返回此响应时，不会返回网页内容</li><li>4 开头的状态码(客户端错误)<br>4xx(请求错误)这些状态码表示请求可能出错，妨碍了服务器的处理<br>400(错误请求)服务器不理解请求的语法<br>401表示发送的请求需要有通过HTTP认证的认证信息<br>403(禁止)服务器拒绝请求<br>404(未找到)服务器找不到请求网页</li><li>5 开头的状态码(服务器错误)<br>5xx(服务器错误)这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器<br>本身的错误，而不是请求的错误<br>500，(服务器内部错误)服务器遇到错误，无法完成请求<br>503，表示服务器处于停机维护或超负载，无法处理请求</li></ul><h3 id="浏览器从输入url到页面加载发生了什么"><a href="#浏览器从输入url到页面加载发生了什么" class="headerlink" title="浏览器从输入url到页面加载发生了什么"></a>浏览器从输入url到页面加载发生了什么</h3><p>1、浏览器的地址栏输入URL并按下回车。<br>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。<br>3、DNS解析URL对应的IP。<br>4、根据IP建立TCP连接（三次握手）。<br>5、HTTP发起请求。<br>6、服务器处理请求，浏览器接收HTTP响应。<br>7、渲染页面，构建DOM树。<br>8、关闭TCP连接（四次挥手）。</p><h3 id="HTTP-传输过程"><a href="#HTTP-传输过程" class="headerlink" title="HTTP 传输过程"></a>HTTP 传输过程</h3><p>含义：从建立连接到断开连接一共七个步骤，就是三次招手四次挥手</p><p>TCP 建立连接<br>浏览器发送请求命令<br>浏览器发送请求头<br>服务器应答<br>服务器回应信息<br>服务器发送数据<br>断开TCP连接</p><h3 id="浏览器如何渲染页面的？"><a href="#浏览器如何渲染页面的？" class="headerlink" title="浏览器如何渲染页面的？"></a>浏览器如何渲染页面的？</h3><p>浏览器解析html源码，将HTML转换成dom树，将CSS样式转换成stylesheet（CSS规则树），浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树（Render Tree）生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点合成绘制生成页面。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>减少http请求次数<br>减少DNS查找<br>避免重定向<br>使用Ajax缓存<br>少用全局变量、减少DOM操作的使用<br>优化图片大小，通过CSS Sprites（精灵图）优化图片，<br>将css放在顶部，将js放在底部</p><h3 id="webpack是怎么打包的，babel又是什么"><a href="#webpack是怎么打包的，babel又是什么" class="headerlink" title="webpack是怎么打包的，babel又是什么"></a>webpack是怎么打包的，babel又是什么</h3><p>Webpack：把所有依赖打包成一个 bundle.js文件，通过代码分割成单元片段并按需加载。Webpack是以公共JS的形式来书写脚本的，但对AMD&#x2F;CMD的支持也很全面，方便旧项目进行代码迁移。<br>把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p><p>babel将es6、es7、es8等语法转换成浏览器可识别的es5或es3语法。</p><h3 id="git-和-svn的区别"><a href="#git-和-svn的区别" class="headerlink" title="git 和 svn的区别"></a>git 和 svn的区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，首先要从中央服务器哪里得到最新的版本，干完活后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作（如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了）</p><p>Git是分布式版本控制系统，没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h3 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h3><p>webSocket： 可以让服务器主动向客户端发送消息，适合开发聊天室，多人游戏等协作应用。</p><p>WebSocket协议是基于TCP的一种新的网络协议。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h3 id="require和import区别"><a href="#require和import区别" class="headerlink" title="require和import区别"></a>require和import区别</h3><ul><li><p>调用时间</p><p>  require运行时调用，理论上可以运用在代码任何地，甚至不需要赋值给某个变量之后再使用。<br>  lmport是编译时候调用，必须放在文件开头，而且使用格式也是确定的。</p></li><li><p>遵循规范</p><p>  require 是 AMD规范引入方式<br>  import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p></li><li><p>本质<br>  require是赋值过程，其实require 的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。<br>  import是解构过程。</p></li></ul><p>通过require 引入基础数据类型时，属于复制该变量。<br>通过require 引入复杂数据类型时，数据浅拷贝该对象。<br>出现模块之间的循环引用时,会输出已经执行的模块,而未执行的模块不输出(比较复杂）。CommonJS模块默认export的是一个对象，即使导出的是基础数据类型。</p><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。<br>使用import取代require()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;moduleA&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.<span class="property">func1</span>;</span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.<span class="property">func2</span>;</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用export取代module.exports。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">React</span> = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Breadcrumbs</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;nav /&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Breadcrumbs</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Breadcrumbs</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;nav /&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Breadcrumbs</span>;</span><br></pre></td></tr></table></figure><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>原因：JavaScript是单线程，所有任务需要排队，前一个任务结束，才会执行后一个任务。</p><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务：不进入主线程、而进入”任务队列”的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>同步和异步任务分别进入不同的执行环境， 先执行同步任务，把异步任务放入循环队列当中挂起，等待同步任务执行完，再执行队列中的异步任务。异步任务先执行微观任务，再执行宏观任务。一直这样循环，反复执行。</p><p>微任务：Promise.then、catch、finally、async&#x2F;await。<br>宏任务：整体代码 Script、UI 渲染、setTimeout、setInterval、Dom事件、ajax事件。</p><h3 id="宏任务、微任务是怎么执行的？"><a href="#宏任务、微任务是怎么执行的？" class="headerlink" title="宏任务、微任务是怎么执行的？"></a>宏任务、微任务是怎么执行的？</h3><p>执行顺序：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。</p><h3 id="什么是单页面应用（SPA）"><a href="#什么是单页面应用（SPA）" class="headerlink" title="什么是单页面应用（SPA）"></a>什么是单页面应用（SPA）</h3><p>一个系统只加载一次资源，之后的操作交互、数据交互是通过路由、ajax来进行，页面并没有刷新。<br>在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。</p><p>优点：<br>前后端分离<br>良好的交互体验——用户不用刷新页面，页面显示流畅<br>减轻服务器压力——服务器只出数据<br>共用一套后端代码——多个客户端可共用一套后端代码<br>加载速度快,内容的改变不需要重新加载整个页面,对服务器压力小<br>缺点：<br>SEO难度高——数据渲染在前端进行<br>页面初次加载比较慢,页面复杂提高很多<br>多页面： 一个应用多个页面,页面跳转时整个页面都刷新,每次都请求一个新的页面<br>有点:SEO效果好</p><p>缺点： 页面切换慢,每次切换页面需要选择性的重新加载公共资源</p><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><p>渐进增强（Progressive Enhancement）： 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。<br>优雅降级（Graceful Degradation）： 一开始就构建站点的完整功能，然后针对浏览器测试和修复。</p><p>在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的。</p><p>二者区别：<br>1、优雅降级和渐进增强只是看待同种事物的两种观点。<br>2、优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。<br>3、渐进增强观点则认为应关注于内容本身。</p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h3 id="MVC和MVVM的理解"><a href="#MVC和MVVM的理解" class="headerlink" title="MVC和MVVM的理解"></a>MVC和MVVM的理解</h3><p>M:model(数据模型)，V：view(视图)，C：controller(逻辑处理)，VM：(连接model和view)<br>MVC:单向通信。必须通过controller来承上启下。<br>MVVM：数据双向绑定，数据改变视图，视图改变数据。</p><h3 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h3><p>通过数据劫持结合发布—订阅模式，通过Object.defineProperty()为各个属性定义get、set方法，在数据发生改变时给订阅者发布消息，触发相应的事件回调。</p><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><ul><li><p>beforeCreate</p><p>  创建前。此时，组件实例刚刚创建，还未进行数据观测和事件配置，拿不到任何数据。</p></li><li><p>created</p><p>  创建完成。vue 实例已经完成了数据观测，属性和方法的计算(比如props、methods、data、computed和watch此时已经拿得到)，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求，页面的初始化。</p></li><li><p>beforeMount</p><p>  挂载前。挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM）。编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p></li><li><p>mounted</p><p>  挂载完成。也就是模板中的HTML渲染到HTML页面中，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求，mounted只会执行一次。</p></li><li><p>beforeUpdate</p><p>  在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，不会触发附加地重渲染过程。</p></li><li><p>updated</p><p>  更新后。在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用，</p></li><li><p>beforeDestroy</p><p>  销毁前。在实例销毁之前调用，实例仍然完全可用。（一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件）</p></li><li><p>destroyed</p><p>  销毁后。在实例销毁之后调用，调用后，vue实列指示的所有东西都会解绑，所有的事件监听器会被移除。</p></li></ul><p>其他：</p><ul><li><p>activated</p><p>  在keep-alive组件激活时调用</p></li><li><p>deactivated</p><p>  在keep-alive组件停用时调用</p></li></ul><h3 id="为什么使用虚拟DOM-常问"><a href="#为什么使用虚拟DOM-常问" class="headerlink" title="为什么使用虚拟DOM(常问)"></a>为什么使用虚拟DOM(常问)</h3><p>创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。<br>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。<br>虚拟dom由于本质是一个js对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。<br>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</p><h3 id="v-if-和-v-show的作用和区别"><a href="#v-if-和-v-show的作用和区别" class="headerlink" title="v-if 和 v-show的作用和区别"></a>v-if 和 v-show的作用和区别</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">无论v-<span class="built_in">show</span>的值为<span class="literal">true</span>或者<span class="literal">false</span>,元素都会存在于html页面中; 而v-<span class="keyword">if</span>的值为<span class="literal">true</span>时,元素才会</span><br><span class="line">存在于html页面中。</span><br><span class="line">v-<span class="built_in">show</span>指令是通过修改元素的<span class="built_in">display</span>属性来实现的。</span><br><span class="line">v-<span class="keyword">if</span>是动态地向DOM树内添加或者删除DOM元素,v-<span class="built_in">show</span>是通过设置DOM元素的<span class="built_in">display</span>样式属性控制显隐的。</span><br><span class="line">v-<span class="keyword">if</span>是<span class="string">&quot;真正的&quot;</span>条件渲染,因为它会确保在奇幻过程中条件快内的事件监听器和子组件适当的销毁和重建。</span><br><span class="line">v-<span class="keyword">if</span>也是惰性的,如果在初始渲染时条件为假,则什么也不做,直到条件第一次变为真时,才开始渲染条件块。</span><br><span class="line">v-<span class="built_in">show</span>不管初始条件是什么,元素总会背渲染,并且只是简单地基于css进行切换。</span><br><span class="line">一般来说,v-<span class="keyword">if</span>有更高的切换开销,而v-<span class="built_in">show</span>则有更高的初始渲染开销</span><br></pre></td></tr></table></figure><p>因此,如果需要非常频繁地切换,使用v-show比较好,如果在运行时条件不会改变时,用v-if比较好</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">切换时生命周期函数的执行</span><br><span class="line">v-<span class="keyword">if</span></span><br><span class="line">初始渲染</span><br><span class="line">初始值为<span class="keyword">false</span>时,不会渲染(所谓惰性),生命周期函数不会执行</span><br><span class="line">初始值为<span class="keyword">true</span>时,组件开始渲染,依次执行beforCreate,created,beforeMount,mounted等生命周期</span><br><span class="line"></span><br><span class="line">切换时</span><br><span class="line">从<span class="keyword">false</span>到<span class="keyword">true</span>:依次执行beforeCreate,created,beforeMount,moynted</span><br><span class="line">从<span class="keyword">true</span>到<span class="keyword">false</span>:依次执行beforeDestroy,destroyed</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">show</span></span><br><span class="line">初始渲染</span><br><span class="line">无论初始状态为<span class="keyword">true</span>还是<span class="keyword">false</span>,组件都会渲染,依次执行beforeCreate,created,beforeMount,mounted</span><br><span class="line"></span><br><span class="line">切换</span><br><span class="line">基于css进行切换,对生命周期函数无影响.</span><br></pre></td></tr></table></figure><h3 id="用过vue的哪些组件？"><a href="#用过vue的哪些组件？" class="headerlink" title="用过vue的哪些组件？"></a>用过vue的哪些组件？</h3><p>1、vue-route<br>2、axios<br>3、vuex<br>4、Element UI<br>5、swiper<br>6、vue-echarts<br>7、vue-video-player<br>8、vue-photo-preview等等</p><h3 id="vue-router-的模式有？"><a href="#vue-router-的模式有？" class="headerlink" title="vue-router 的模式有？"></a>vue-router 的模式有？</h3><p>1、hash模式，用URL hash值来做路由，支持所有浏览器；该模式实现的路由，在通过链接后面添加““#”+路由名字”。<br>2、history模式，由h5提供的history对象实现，依赖H5 History API和服务器配置。<br>3、abstract模式，支持所有JS运行环境，如Node服务器端，如果发现没有浏览器的API，路由会自动强制进入该模式。</p><h3 id="组件之间如何传值"><a href="#组件之间如何传值" class="headerlink" title="组件之间如何传值"></a>组件之间如何传值</h3><ul><li><p>Vue父子 组件之间传值<br>子组件通过props来接受数据和通过$emit来触发父组件的自定义事件</p></li><li><p>兄弟组件之间的传值<br>建一个公共组件bus.js.。传递方通过事件触发bus.$emit。接收方通过在mounted（）{}生命周期里触发bus.$on。</p></li><li><p>可以通过VUEX 来跨组件传参</p></li><li><p>父孙传值 $attrs（向下）$listeners（向上）</p></li><li><p>祖先和子孙传值provide&#x2F;inject</p></li><li><p>获取父组件实例this.$parent</p></li></ul><h3 id="路由之间如何传参"><a href="#路由之间如何传参" class="headerlink" title="路由之间如何传参"></a>路由之间如何传参</h3><ul><li><p>通过router-link路由导航跳转传递<br><code>&lt;router-link to=</code>&#x2F;a&#x2F;${id}<code>&gt;routerlink传参&lt;/router-link&gt;</code></p></li><li><p>跳转时使用push方法拼接携带参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">`/getlist/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过路由属性中的name来确定匹配的路由，通过params来传递参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Getlist&#x27;</span>,</span><br><span class="line">   <span class="attr">params</span>: &#123;</span><br><span class="line">     <span class="attr">id</span>: id</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用path来匹配路由，然后通过query来传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"> <span class="attr">path</span>: <span class="string">&#x27;/getlist&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：query有点像ajax中的get请求，而params像post请求。</p></blockquote><p>params在地址栏中不显示参数，刷新页面，参数丢失,<br>其余方法在地址栏中显示传递的参数，刷新页面，参数不丢失。</p><h3 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h3><p>原理：Vuex是专门为vue.js应用程序设计的状态管理工具。</p><p>1、state   保存vuex中的数据源，通过this.$store.state获取</p><p>2、getters用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来</p><p>3、mutations  是修改store中的值得唯一方式&#x2F;&#x2F;this.$store.commit(‘add’)</p><p>4、action 官方建议提交一个actions，在actions中提交mutations再去修改状态值。this.$store.dispatch(‘add’)</p><p>5、modules 模块化</p><h3 id="如何解决vuex页面刷新数据丢失问题？"><a href="#如何解决vuex页面刷新数据丢失问题？" class="headerlink" title="如何解决vuex页面刷新数据丢失问题？"></a>如何解决vuex页面刷新数据丢失问题？</h3><p>原因：因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被清空。<br>解决方法：将vuex中的数据直接保存到浏览器缓存中。（一般是用sessionStorage）</p><h3 id="computed和watch的区别？"><a href="#computed和watch的区别？" class="headerlink" title="computed和watch的区别？"></a>computed和watch的区别？</h3><p>computed值有缓存、触发条件是依赖值发生更改、 watch无缓存支持异步、监听数据变化</p><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生<br>改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p><p>watch： 更多的是观察的作用，支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都<br>会执行回调进行后续操作；</p><p>computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以<br>利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch<br>选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结<br>果前，设置中间状态。这些都是计算属性无法做到的。</p><h3 id="route和router的区别"><a href="#route和router的区别" class="headerlink" title="route和router的区别"></a>route和router的区别</h3><p>route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。<br>router:是路由实例对象，包括了路由跳转方法，钩子函数等。</p><h3 id="vue中数据变了但是视图不跟新怎么解决？"><a href="#vue中数据变了但是视图不跟新怎么解决？" class="headerlink" title="vue中数据变了但是视图不跟新怎么解决？"></a>vue中数据变了但是视图不跟新怎么解决？</h3><p>vue不能检测以下变动的数组：</p><p>1、当你利用索引直接设置一个项时，vm.items[indexOfItem] &#x3D; newValue<br>2、当你修改数组的长度时，例如： vm.items.length &#x3D; newLength</p><p>对象属性的添加或删除</p><p>由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>解决办法：</p><p>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上<br>Vue.set(vm.someObject, ‘b’, 2) 或者 this.$set(this.someObject,‘b’,2) （这也是全局 Vue.set 方法的别名）</p><p>异步更新队列</p><p>在最新的项目中遇到了这种情况，数据第一次获取到了，也渲染了，但是第二次之后数据只有在再一次渲染页面的时候更新，并不能实时更新。</p><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>解决办法：</p><p>可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用</p><h3 id="vue中data为什么是函数而不是对象？"><a href="#vue中data为什么是函数而不是对象？" class="headerlink" title="vue中data为什么是函数而不是对象？"></a>vue中data为什么是函数而不是对象？</h3><p>vue组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的.</p><p>基于这一理念，组件每复用一次，data数据就会被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响。</p><p>如果data是对象的话，每当被复用是，复用的对象和源对象都会指向同一个内存地址（浅拷贝），互相之间相互影响，所以要是函数</p><h3 id="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"><a href="#vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）" class="headerlink" title="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"></a>vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）</h3><p>首先了解父子组件生命周期执行顺序<br>加载渲染数据过程<br>父组件 beforeCreate<br>父组件 created<br>父组件 beforeMount<br>子组件 beforeCreate<br>子组件 created<br>子组件 beforeMount<br>子组件 mounted<br>父组件 mounted</p><p>原因：因为生命周期只会执行一次，数据是要等到异步请求以后才能拿到，那么子组件的mounted钩子执行的时候，还没有拿到父组件传递过来的数据，但是又必须要打印出来结果，那这样的话，就只能去打印props中的默认值空字符串了，所以打印的结果是一个空字符串。</p><p>解决办法：</p><p>1、使用v-if控制组件渲染的时机</p><p>初始还没拿到后端接口的异步数据的时候，不让组件渲染，等拿到的时候再去渲染组件。使用v-if&#x3D;”变量”去控制，初始让这个变量为false，这样的话，子组件就不会去渲染，等拿到数据的时候，再让这个变量变成true，</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">isTrue</span>:<span class="literal">false</span> <span class="comment">// 初始为false</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">monted</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$post</span>.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>.<span class="title function_">getData</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(res.<span class="property">result</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">isTrue</span> = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用watch监听数据的变化</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">tableData</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    <span class="attr">default</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">   <span class="title function_">tableData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3、使用VueX</p><h3 id="Vue-路由跳转方式"><a href="#Vue-路由跳转方式" class="headerlink" title="Vue 路由跳转方式"></a>Vue 路由跳转方式</h3><p>router-link 标签跳转<br>this.$router.push()<br>this.$router.replace()<br>this.$router.go(n)：（0：当前页，-1上一页，+1下一页，n代表整数）</p><h3 id="Vue-中-for循环为什么加-key？"><a href="#Vue-中-for循环为什么加-key？" class="headerlink" title="Vue 中 for循环为什么加 key？"></a>Vue 中 for循环为什么加 key？</h3><p>为了性能优化， 因为vue是虚拟DOM，更新DOM时用diff算法对节点进行一一比对，比如有很多li元素，要在某个位置插入一个li元素，但没有给li上加key，那么在进行运算的时候，就会将所有li元素重新渲染一遍，但是如果有key，那么它就会按照key一一比对li元素，只需要创建新的li元素，插入即可，不需要对其他元素进行修改和重新渲染。<br>key也不能是li元素的index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了。</p><h3 id="vue路由守卫有哪些？"><a href="#vue路由守卫有哪些？" class="headerlink" title="vue路由守卫有哪些？"></a>vue路由守卫有哪些？</h3><p>路由守卫分为三种 ——分别是：全局路由守卫、组件路由守卫、独享路由守卫。</p><p>全局守卫<br>全局守卫又分为全局前置守卫、和后置守卫</p><ol><li>router.beforeEach((to,from,next)&#x3D;&gt;{})</li></ol><p>回调函数中的参数，to：进入到哪个路由去，from：从哪个路由离开，next：函数，决定是否展示你要看到的路由页面。</p><p>从名字全局前置守卫不难理解，它是全局的，即对 整个单页应用（SPA） 中的所有路由都生效，所以当定义了全局的前置守卫，在进入每一个路由之前都会调用这个回调，那么如果你在回调中对路由的跳转条件判断出错，简单点就是死循环…因为你遗漏了某种路由跳转的情况，守卫会一直执行。所以在使用全局前置守卫的时候一定要判断清楚可能会出现的路由跳转的情况。</p><p>2.router.afterEach((to, from) &#x3D;&gt; {}）</p><p>只有两个参数，to：进入到哪个路由去，from：从哪个路由离。</p><p>理解了全局前置守卫，那么全局后置守卫也就那么一回事。全局后置守卫是整个单页应用中每一次路由跳转后都会执行其中的回调。所以多用于路由跳转后的相应页面操作，并不像全局前置守卫那样会在回调中进行页面的重定向或跳转。</p><p>组件内的守卫<br>组件路由守卫分为到达这个组件时，离开这个组件时</p><ol><li>beforeRouteEnter:(to,from,next)&#x3D;&gt;{}——到达</li></ol><p>to，from参数与上面使用方法一致。next回调函数略有不同。<br>1<br>2.beforeRouteUpdate:(to,from,next)&#x3D;&gt;{}——更新</p><ol start="3"><li>beforeRouteLeave:(to,from,next)&#x3D;&gt;{}——离开</li></ol><p>点击其他组件时，判断是否确认离开。确认执行next()；取消执行next(false)，留在当前页面。<br>1<br>路由独享的守卫</p><ol><li>beforeEnter:(to,from,next)&#x3D;&gt;{}</li></ol><p>与全局路由守卫用法一致，但是只能针对一个页面使用<br>1</p><h3 id="vue常⽤的修饰符"><a href="#vue常⽤的修饰符" class="headerlink" title="vue常⽤的修饰符"></a>vue常⽤的修饰符</h3><p>.stop:等统⼀JavaScript中的event.stopPropagation(),防⽌事件冒泡<br>.prevent:等同于JavaScript中的event。preventDefault(),防⽌执⾏预设的⾏为(如果事件可<br>取消，则取消该事件，⽽不停⽌事件的进⼀步传播)；<br>.capture:与事件冒泡的⽅向相反，事件捕获由外到内<br>.self:只会触发⾃⼰范围内的事件，不包含⼦元素；<br>.once:只会触发⼀次。</p><h3 id="vue的两个核⼼点"><a href="#vue的两个核⼼点" class="headerlink" title="vue的两个核⼼点"></a>vue的两个核⼼点</h3><p>数据驱动：ViewModel，保证数据和视图的⼀致性<br>组件系统：应⽤类UI可以看做全部是由组件树构成的</p><h3 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了empty&#x2F;undefined其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值</p><h3 id="vue常⽤的UI组件库"><a href="#vue常⽤的UI组件库" class="headerlink" title="vue常⽤的UI组件库"></a>vue常⽤的UI组件库</h3><p>Mint UI，element，VUX</p><h3 id="Vue首页白屏是什么问题引起的？如何解决呢？"><a href="#Vue首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="Vue首页白屏是什么问题引起的？如何解决呢？"></a>Vue首页白屏是什么问题引起的？如何解决呢？</h3><h3 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h3><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="react的生命周期"><a href="#react的生命周期" class="headerlink" title="react的生命周期"></a>react的生命周期</h3><p>生命周期是什么？<br>react 实例的生命周期，就是react实例从初始化，更新，到销毁的过程</p><p>react实例生命周期经历三个阶段<br>初始化阶段：完成从react组件创建到首次渲染的过程</p><p>更新阶段：当调用setState函数时，会引起组件的重新渲染</p><p>销毁阶段：完成组件的销毁</p><p>三个阶段分别对应的构造函数有<br>初始化阶段：<br>constructor<br>构造函数里，可以做状态的初始化，接收props的传值<br>componentWillMount： 在渲染前调用，相当于vue中的beforeMount</p><p>render<br>渲染函数，不要在这里修改数据。 vue中也有render函数。</p><p>componentDidMount<br>渲染完毕，在第一次渲染后调用。</p><p>运行中阶段（更新）<br>当组件的 props 或 state 发生变化时会触发更新（严谨的说，是只要调用了setState（）或者改变了props时）。组件更新的生命周期调用顺序如下：</p><p>shouldComponentUpdate<br>是否更新？ 需要返回true或者false。如果是false，那么组件就不会继续更新了。</p><p>componentWillUpdate<br>即将更新。<br>componentWillReceiveProps(nextProps)： 在组件接收到一个新的 prop (更新后)时被调用。<br>这个方法在初始化render时不会被调用。nextProps 是props的新值，而 this.props是旧值。</p><p>render<br>不要在这里修改数据</p><p>componentDidUpdate<br>在组件完成更新后立即调用。在初始化时不会被调用。 相当于vue中的updated</p><p>销毁阶段（卸载）<br>componentWillUnmount()<br>即将卸载，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p><h3 id="为什么虚拟DOM-会提高性能"><a href="#为什么虚拟DOM-会提高性能" class="headerlink" title="为什么虚拟DOM 会提高性能"></a>为什么虚拟DOM 会提高性能</h3><p> 首先，（虚拟DOM是什么） 虚拟DOM就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&quot;p&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: <span class="string">&quot;width:200px;height: 100px;&quot;</span>,</span><br><span class="line">    <span class="attr">innerHTML</span>: <span class="string">&quot;我是p&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其次，操作虚拟DOM，就是在操作javascript对象，所以，并不会引起页面的重绘和重排。而操作真实DOM是会引起页面的重绘和重排的。</p><h3 id="React的diff原理"><a href="#React的diff原理" class="headerlink" title="React的diff原理"></a>React的diff原理</h3><p>传统diff算法<br>需要遍历整棵树的节点然后进行比较，是一个深度递归的过程，运算复杂度常常是O(n^3)</p><p>react diff的优化策略<br>DOM节点跨层级的操作不做优化，因为很少这么做，这是针对的tree层级的策略；<br>对于同一个类的组件，会生成相似的树形结构，对于不同类的组件，生成不同的树形结构，这是针对conponent层级的策略；<br>对于同一级的子节点，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；</p><h3 id="调用setState之后，发生了什么？"><a href="#调用setState之后，发生了什么？" class="headerlink" title="调用setState之后，发生了什么？"></a>调用setState之后，发生了什么？</h3><p>合并state<br>把传入setState（）里的参数对象和当前的state进行（属性）合并。 触发调和过程<br>（Reconciliation）</p><p>重新渲染组件<br>React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面<br>React 会自动计算出新的树与老树的节点差异（用diff算法），然后根据差异对界面进行最小化重<br>渲染</p><h3 id="state和props的区别"><a href="#state和props的区别" class="headerlink" title="state和props的区别"></a>state和props的区别</h3><p>state是组件的状态，也叫组件内部的数据</p><p>props是组件的属性，也可以认为是外部给组件传入的数据</p><h3 id="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"><a href="#React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？" class="headerlink" title="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"></a>React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？</h3><p>setState是异步的。</p><p>如果要拿到修改后的状态，需要使用回调函数的方式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态后想做一些事情：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  属性名:属性值</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//一般是用于在setState之后做一些操作</span></span><br><span class="line">  <span class="comment">//this.state == 修改之后的state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为什么不能直接用以下办法更新state"><a href="#为什么不能直接用以下办法更新state" class="headerlink" title="为什么不能直接用以下办法更新state"></a>为什么不能直接用以下办法更新state</h3><p>this.state.msg &#x3D; “hello”;</p><p>因为，这样不会引起组件的重新渲染，所以，数据修改后没法 呈现在页面上。</p><p>而调用setState()函数，会引起组件的重新渲染，这样更新的数据就会呈现在页面上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VScode快捷键</title>
    <link href="https://superq314.github.io/2022/09/13/VScode/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://superq314.github.io/2022/09/13/VScode/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2022-09-13T06:35:15.000Z</published>
    <updated>2022-09-13T07:22:31.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>col1</th><th>col2</th></tr></thead><tbody><tr><td>单词跳跃</td><td>Alt</td></tr><tr><td>单词选中</td><td>Alt+shift</td></tr><tr><td>注释</td><td>ctrl+’&#x2F;‘</td></tr><tr><td>代码块注释</td><td>Alt+shift+’A’</td></tr><tr><td>tab对齐</td><td>Alt+shift+’F’</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前沿知识</title>
    <link href="https://superq314.github.io/2022/09/13/frontEnd/%E5%89%8D%E6%B2%BF%E7%9F%A5%E8%AF%86/"/>
    <id>https://superq314.github.io/2022/09/13/frontEnd/%E5%89%8D%E6%B2%BF%E7%9F%A5%E8%AF%86/</id>
    <published>2022-09-13T06:25:30.000Z</published>
    <updated>2022-09-16T02:29:36.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态网页技术</p><ul><li>JSP</li><li>ASP</li><li>PHP</li></ul><p>MVC template：分层技术</p><p>平台兼容</p><p>&#x3D;&#x3D;&gt; prototype、jQuery、MooTools、Dojo、modernizer</p><p>UI组件化</p><p>&#x3D;&#x3D;&gt; Bindows、YUII、jQuery UI、Ext、Bootstrap、Semantic UI</p><p>分层模块化</p><p>&#x3D;&#x3D;&gt; JavaScript MVC、BackBone、Knockout、Vue、EmberJS、Angular、React</p><p>相对地址：</p><pre><code>当前目录./上一级目录../下一级./imgs</code></pre><p>绝对地址</p><p>引用地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浏览器输入url回车之后发生了什么</title>
    <link href="https://superq314.github.io/2022/09/10/computerBasics/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://superq314.github.io/2022/09/10/computerBasics/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-09-10T11:23:12.000Z</published>
    <updated>2022-09-10T12:31:17.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ul><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li><li>URL 解析</li><li>地址解析：</li></ul><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p>HSTS</p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。</p><p>其他操作</p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p>检查缓存</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter.png"></p><h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><p>基本步骤</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_baisc_process.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">浏览器缓存</button></li><li class="tab"><button type="button" data-href="#super-2">操作系统缓存</button></li><li class="tab"><button type="button" data-href="#super-3">路由器缓存</button></li><li class="tab"><button type="button" data-href="#super-4">ISP DNS 缓存</button></li><li class="tab"><button type="button" data-href="#super-5">根域名服务器查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>路由器也有自己的缓存。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_dns.png"></p><blockquote><p>根域名服务器：维基百科<br>需要注意的点</p></blockquote><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h2><p>TCP&#x2F;IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_tcp.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">应用层：发送 HTTP 请求</button></li><li class="tab"><button type="button" data-href="#super-2">传输层：TCP 传输报文</button></li><li class="tab"><button type="button" data-href="#super-3">网络层：IP 协议查询 Mac 地址</button></li><li class="tab"><button type="button" data-href="#super-4">链路层：以太网协议</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够準确地还原报文信息。<br>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP&#x2F;IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP&#x2F;IP 中，它位于网络层。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">以太网协议</button></li><li class="tab"><button type="button" data-href="#super-2">Mac 地址</button></li><li class="tab"><button type="button" data-href="#super-3">广播</button></li><li class="tab"><button type="button" data-href="#super-4">服务器接受请求</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方回应是单播。</p><blockquote><p>相关知识点：</p><ol><li>ARP 攻击</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>接受过程就是把以上步骤逆转过来，参见上图。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>大致流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_1.png"></p><p>HTTPD</p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p>处理请求</p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p>重定向</p><p>假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：详见这篇文章</p></blockquote><p>URL 重写</p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="浏览器接受响应"><a href="#浏览器接受响应" class="headerlink" title="浏览器接受响应"></a>浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h2 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h2><p>浏览器内核</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_broswer.png"></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p>基本流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_2.png"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">HTML 解析</button></li><li class="tab"><button type="button" data-href="#super-2">CSS 解析</button></li><li class="tab"><button type="button" data-href="#super-3">渲染树</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 解码（encoding）</button></li><li class="tab"><button type="button" data-href="#super-2">2. 预解析（pre-parsing）</button></li><li class="tab"><button type="button" data-href="#super-3">3.1 符号化（Tokenization）</button></li><li class="tab"><button type="button" data-href="#super-4">3.2 构建树（tree construction）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_html.png"></p><p>浏览器容错进制</p><p>你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p>事件</p><p>当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p>CSS 匹配规则</p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。</p></blockquote><p>计算</p><p>通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。</p><p>级联</p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li>!important</li></ol><p>然后得出一个权重值，取最高的那个。</p><p>渲染阻塞</p><p>当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">佈局与绘製</button></li><li class="tab"><button type="button" data-href="#super-2">合并渲染层</button></li><li class="tab"><button type="button" data-href="#super-3">回流与重绘</button></li><li class="tab"><button type="button" data-href="#super-4">JavaScript 编译执行</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>把以上绘制的所有图片合并，最终输出一张图片。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>回流 (reflow)</p><p>当浏览器发现某个部分发现变化影响了佈局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p>重绘 (repaint)</p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li>display:none 会触发回流，而 visibility:hidden 只会触发重绘。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>大致流程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_3.png"></p><p>可以分为三个阶段：</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">词法分析</button></li><li class="tab"><button type="button" data-href="#super-2">预编译</button></li><li class="tab"><button type="button" data-href="#super-3">执行</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将var a &#x3D; 2，，分成var、a、&#x3D;、2这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p>创建执行上下文</p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>JS 线程</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_7.png"></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p>注：浏览器对同一域名的併发连接数是有限的，通常为 6 个。</p><p>宏任务</p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p>微任务</p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：Promise，process.nextTick。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822185002.png"></p><p>代码例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>chrome调试</title>
    <link href="https://superq314.github.io/2022/09/10/frontEnd/0-0grammar/chrome%E8%B0%83%E8%AF%95/"/>
    <id>https://superq314.github.io/2022/09/10/frontEnd/0-0grammar/chrome%E8%B0%83%E8%AF%95/</id>
    <published>2022-09-10T11:14:55.000Z</published>
    <updated>2022-09-13T07:22:30.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打开调试器F12,或者点击鼠标右键，选择检查或检查属性</p><p>Elements[元素]：这里就是html和css了，我们经常在这里进行样式css调试</p><p>Console[控制台]：这里是打印器，可以理解为一个记录日志，所有的报错信息会在这里体现</p><ul><li>查看信息</li><li>运行脚本</li></ul><p>Sources[源代码]：这里是断点调试，也就是debugger，不明的话在你的js里面打上一个debugger试试就知道了，方便按步执行代码，找出代码在那一步出的错</p><ul><li>调试脚本</li><li>查看变量</li><li>查看堆栈</li><li>其他资源调试</li></ul><p>Network[网络]：这里是http请求的调试器，在这里可以查看所有的http请求，包括你的请求头，请求路径，请求参数，后台返回的数据还有请求的状态等等</p><ul><li>查看页面所有资源请求</li><li>查看单独资源信息</li><li>过滤和排序信息</li></ul><p>Performance[性能]：</p><p>Memory[内存]：</p><p>application[应用程序]：这里就是我们说的浏览器缓存了，存放着缓存的数据，缓存分两种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue实现网易云音乐</title>
    <link href="https://superq314.github.io/2022/09/10/frontEnd/6Vue/vue%E5%AE%9E%E7%8E%B0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>https://superq314.github.io/2022/09/10/frontEnd/6Vue/vue%E5%AE%9E%E7%8E%B0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</id>
    <published>2022-09-10T11:08:45.000Z</published>
    <updated>2022-09-10T11:11:05.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="技术基础"><a href="#技术基础" class="headerlink" title="技术基础"></a>技术基础</h2><p>Vue(2.5) + vuex + vue-router + vue-axios +better-scroll + Scss + ES6</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>开发一款移动端webAPP，</p><p>UI界面参考安卓版的网易云音乐，</p><p>flex布局适配常见移动端</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>Vue：用于构建用户界面的 MVVM 框架</p><p>vue-router：为单页面应用提供的路由系统，使用了 Lazy Loading Routes 技术来实现异步加载优化性能</p><p>vuex：Vue 集中状态管理，在多个组件共享某些状态时非常便捷</p><p>vue-lazyload：实现图片懒加载，节省用户流量，优化页面加载速度</p><p>better-scroll：解决移动端各种滚动场景需求的插件，使移动端滑动体验更加流畅</p><p>SCSS：css 预编译处理器</p><p>ES6：ECMAScript 新一代语法，模块化、解构赋值、Promise、Class 等方法非常好用</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>Node.js：利用 Express 搭建的本地测试服务器</p><p>vue-axios：用来请求后端 API 音乐数据</p><p>NeteaseCloudMusicApi：网易云音乐 NodeJS 版 API，提供音乐数据</p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>vue-cli：Vue 脚手架工具，快速初始化项目代码</p><p>eslint：代码风格检查工具，帮助我们规范代码书写（一定要养成良好的代码规范）</p><p>iconfont ：阿里巴巴图标库，</p><p>fastclick ：消除 click 移动游览器 300ms 的延时</p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>初始加载页面、播放器内核、轮播图（新歌首发、MV首发等）、每日推荐、推荐歌单（左右滑屏）、热榜页面、歌手页面、歌单详情、歌手详情、排行榜详情、搜索页面、播放列表、用户中心等等功能。</p><h3 id="推荐页面"><a href="#推荐页面" class="headerlink" title="推荐页面"></a>推荐页面</h3><p>推荐页分成三个部分，分别是 banner 轮播图、推荐歌单、推荐歌曲，数据都是使用 axios 请求 API 获取得到的，图片都使用 vue-lazyload 实现懒加载。</p><ol><li>轮播图 ：使用 better-scroll 实现，具体可以看这里 Slide 。点击跳转方面只实现歌曲和歌单的跳转，因为暂时只实现了这两个功能。</li><li>推荐歌单，推荐歌曲 ：使用 vuex 管理数据，方便组件之间的数据交互（播放器播放歌曲）。因为数据上还有播放数量，所以就顺便也加上去了。</li></ol><h3 id="排行榜页面"><a href="#排行榜页面" class="headerlink" title="排行榜页面"></a>排行榜页面</h3><p>同样是通过 API 获取到排行榜的数据，但是因为 API 获取到的是排行榜中所有歌曲的数据，所以难免在加载速度上有点慢，后期再看能不能优化一下，加载的慢毕竟太影响用户体验了，别的就没什么了。</p><h3 id="歌手页面"><a href="#歌手页面" class="headerlink" title="歌手页面"></a>歌手页面</h3><p>实现歌手列表的左右联动（这个需要理解理解），因为之前已经写过和这个有关的博客，所以就不多写了，具体可以看我之前的这个笔记移动端字母索引导航。</p><h3 id="歌曲列表组件"><a href="#歌曲列表组件" class="headerlink" title="歌曲列表组件"></a>歌曲列表组件</h3><p>用来显示歌曲列表，在很多的地方都进行了复用，例如：歌单详情页、排行榜详情页、歌手详情页、搜索结果、用户中心等等。</p><ol><li>歌单详情页  ： 通过歌单的 ID 来获取歌单中的歌曲数据，然后还做了一些体验上面的交互，比如上滑显示状态栏然后将状态栏标题变为歌单名，具体可以尝试一下就知道了。</li></ol><p>然后就是复用歌曲列表组建来显示歌曲。</p><ol start="2"><li>排行榜详情、歌手详情  ： 和歌单详情基本上没有什么区别，除了 UI 界面方面有细微的改动（根据不同的内容作出不同的优化）。</li><li>搜索功能</li></ol><p>实现功能：搜索歌手、歌单、歌曲、热门搜索、数据节流、上拉刷新、保存搜索记录。</p><p>通过关键字请求 API 获取搜索数据，显示歌手、歌单、歌曲。</p><p>实现了上刷新，因为搜索可以设置请求数据的条数，所以可以用来实现上刷新的功能。</p><p>通过节流函数实现数据节流，通过 localstorage 存储搜索数据。</p><ol start="4"><li>用户中心 ：将在本地存储的数据显示出来，方便用户使用，后期准备添加更多功能。</li></ol><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><p>最最最重要的组件，毕竟是个音乐播放器，不能放歌那啥都是扯淡了。</p><p>实现功能：顺序播放、单曲循环、随机播放、收藏等。</p><p>播放、暂停使用 HTML5 的 audio 实现。</p><p>数据、播放状态、播放历史、习惯歌曲等方面使用了 vuex 来进行管理，因为数据太多，组件直接传递的话是会死人的，所以还是老老实实的用 vuex 吧，数据之前的传递真的很方便。</p><p>图标使用 iconfont 阿里巴巴图标库，中间的唱片旋转动画使用了 animation 实现。</p><p>歌词部分获取到网易的歌词数据，然后使用第三方库 lyric-parser 进行处理。实现显示歌词、拖动进度条歌词同步滚动、歌词跟随歌曲进度高亮。</p><p>通过 localstorage 存储喜欢歌曲、播放历史数据。</p><p>audio 标签在移动端不能够自动播放的问题</p><p>电脑端是没有这个问题的，这个问题真的是让我很头大，最后是用了很鬼畜的方法解决了（使用 addEventListener 监听 touchend 事件，然后在回调函数中让 audio 播放一次，具体看 App.vue 文件，注释有写）。</p><h3 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h3><p>显示和管理当前播放歌曲，可以用来删除列表中的歌曲、以及选择播放歌曲。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>优化排行榜加载速度</li><li>优化重复代码</li><li>增加歌曲评论</li><li>增加 MV、电台 功能</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>创建vue项目过程</title>
    <link href="https://superq314.github.io/2022/09/10/frontEnd/6Vue/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/"/>
    <id>https://superq314.github.io/2022/09/10/frontEnd/6Vue/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/</id>
    <published>2022-09-10T11:00:37.000Z</published>
    <updated>2022-09-22T14:47:42.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="启动运行vue-js项目（维护他人的项目）的方法"><a href="#启动运行vue-js项目（维护他人的项目）的方法" class="headerlink" title="启动运行vue.js项目（维护他人的项目）的方法"></a>启动运行vue.js项目（维护他人的项目）的方法</h2><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>由于npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候失败，所以还需要npm的国内镜像—cnpm<br>在命令行中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> cnpm <span class="literal">--registry</span>=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack <span class="literal">-g</span></span><br></pre></td></tr></table></figure><p>webpack是一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less&#x2F;sass）、图片等都作为模块来使用和处理。 webpack 的核心是 依赖分析,把依赖分析出来了，其他都是细枝末节。</p><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue<span class="literal">-cli</span> <span class="literal">-g</span></span><br></pre></td></tr></table></figure><p>vue-cli是vue.js的脚手架，用于自动生成vue.js+webpack的项目模板，这个过程会耗时十几秒，等走完就好；好了，到此整个环境就搭建好了</p><h3 id="cd-x2F-项目名称"><a href="#cd-x2F-项目名称" class="headerlink" title="cd &#x2F;项目名称"></a>cd &#x2F;项目名称</h3><p>下面就是运行项目了，cd &#x2F;项目名称，进入项目。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ShopApp</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>进入项目之后安装依赖，安装成功</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>注意：在这一步可能会出现这样的错误；因为你打开的是别人的项目，项目之中肯定有 node_modules模块，那么先删除掉，在执行npm install命令</p><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>一切准备就绪，启动项目</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="自动启动浏览器就会打开项目了"><a href="#自动启动浏览器就会打开项目了" class="headerlink" title="自动启动浏览器就会打开项目了"></a>自动启动浏览器就会打开项目了</h3><p>在浏览器中输入<a href="http://localhost:8080/#/%EF%BC%9B%E8%BF%9B%E5%85%A5%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5">http://localhost:8080/#/；进入项目首页</a></p><p>若是要访问其他页面，直接在#后面加上组件名称即可：例如<a href="http://localhost:8080/#/adjustIntegral">http://localhost:8080/#/adjustIntegral</a></p><h3 id="属性选择"><a href="#属性选择" class="headerlink" title="属性选择"></a>属性选择</h3><p>创建vue项目<br>指令：vue create vue-music-next<br>1、Manually select features<br>2、Babel、Router、VueX、CSS Pre-processors、Linter&#x2F;Formatter<br>3、3.x<br>4、Y<br>5、Sass<br>6、ESLint + Standard config<br>7、Lint on save<br>8、In package.json<br>9、Y<br>10、use npm</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
