<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-10-10T15:29:35.495Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入Vue—Diff算法分析</title>
    <link href="https://superq314.github.io/posts/9e6b04d/"/>
    <id>https://superq314.github.io/posts/9e6b04d/</id>
    <published>2022-10-10T15:21:51.000Z</published>
    <updated>2022-10-10T15:29:35.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual DOM<br><strong>virtual DOM提高了开发效率，而非应用性能</strong></p><p>第2种方式比较快，因为第1种方式中间还夹着一个虚拟DOM的步骤，所以虚拟DOM比真实DOM快这句话其实是错的，或者说是不严谨的。<br>那正确的说法是什么呢？<br>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM，虚拟DOM和虚拟DOM算法是两种概念。</p><p>虚拟DOM算法 &#x3D; 虚拟DOM + Diff算法</p><p>什么是Diff算法<br>上面咱们说了虚拟DOM，也知道了只有虚拟DOM + Diff算法才能真正的提高性能，那讲完虚拟DOM，我们再来讲讲Diff算法吧，还是上面的例子(这张图被压缩的有点小，大家可以打开看，比较清晰)：</p><p>上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。<br>总结：Diff算法是一种对比算法。<br>对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。<br>使用虚拟DOM算法的损耗计算： </p><blockquote><p>总损耗 &#x3D; 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘<br>直接操作真实DOM的损耗计算：<br>总损耗 &#x3D; 真实DOM完全增删改+（可能较多的节点）排版与重绘<br>Diff &amp; Patch算法<br>Diff策略</p></blockquote><ol><li>按tree层级diff（level by level）</li><li>按类型进行diff</li><li>列表diff<br>Diff算法的原理<br>Diff同层对比<br>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。<br>所以Diff算法是:深度优先算法。 <br>时间复杂度:O(n)</li></ol><p>Diff对比流程<br>当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。<br>newVnode和oldVnode：同层的新旧虚拟节点 </p><p>patch方法<br>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签(同一类型的标准，下面会讲)：<br>是：继续执行patchVnode方法进行深层比对<br>否：没必要比对了，直接整个节点替换成新虚拟节点<br>来看看patch的核心原理代码<br>function patch(oldVnode, newVnode) {<br>  &#x2F;&#x2F; 比较是否为一个类型的节点<br>  if (sameVnode(oldVnode, newVnode)) {<br>    &#x2F;&#x2F; 是：继续进行深层比较<br>    patchVnode(oldVnode, newVnode)<br>  } else {<br>    &#x2F;&#x2F; 否<br>    const oldEl &#x3D; oldVnode.el &#x2F;&#x2F; 旧虚拟节点的真实DOM节点<br>    const parentEle &#x3D; api.parentNode(oldEl) &#x2F;&#x2F; 获取父节点<br>    createEle(newVnode) &#x2F;&#x2F; 创建新虚拟节点对应的真实DOM节点<br>    if (parentEle !&#x3D;&#x3D; null) {<br>      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) &#x2F;&#x2F; 将新元素添加进父元素<br>      api.removeChild(parentEle, oldVnode.el)  &#x2F;&#x2F; 移除以前的旧元素节点<br>      &#x2F;&#x2F; 设置null，释放内存<br>      oldVnode &#x3D; null<br>    }<br>  }<br>  return newVnode<br>}<br>sameVnode方法<br>patch关键的一步就是sameVnode方法判断是否为同一类型节点，那问题来了，怎么才算是同一类型节点呢？这个类型的标准是什么呢？<br>咱们来看看sameVnode方法的核心原理代码，就一目了然了<br>function sameVnode(oldVnode, newVnode) {<br>  return (<br>    oldVnode.key &#x3D;&#x3D;&#x3D; newVnode.key &amp;&amp; &#x2F;&#x2F; key值是否一样<br>    oldVnode.tagName &#x3D;&#x3D;&#x3D; newVnode.tagName &amp;&amp; &#x2F;&#x2F; 标签名是否一样<br>    oldVnode.isComment &#x3D;&#x3D;&#x3D; newVnode.isComment &amp;&amp; &#x2F;&#x2F; 是否都为注释节点<br>    isDef(oldVnode.data) &#x3D;&#x3D;&#x3D; isDef(newVnode.data) &amp;&amp; &#x2F;&#x2F; 是否都定义了data<br>    sameInputType(oldVnode, newVnode) &#x2F;&#x2F; 当标签为input时，type必须是否相同<br>  )<br>}<br>patchVnode方法<br>这个函数做了以下事情：</p><ul><li>找到对应的真实DOM，称为el</li><li>判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return</li><li>如果他们都有文本节点且不相等，那么将el的文本节点设置为newVnode的文本节点。</li><li>如果oldVnode有子节点而newVnode没有，则删除el的子节点</li><li>如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el</li><li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要<br>function patchVnode(oldVnode, newVnode) {<br>const el &#x3D; newVnode.el &#x3D; oldVnode.el &#x2F;&#x2F; 获取真实DOM对象<br>&#x2F;&#x2F; 获取新旧虚拟节点的子节点数组<br>const oldCh &#x3D; oldVnode.children, newCh &#x3D; newVnode.children<br>&#x2F;&#x2F; 如果新旧虚拟节点是同一个对象，则终止<br>if (oldVnode &#x3D;&#x3D;&#x3D; newVnode) return<br>&#x2F;&#x2F; 如果新旧虚拟节点是文本节点，且文本不一样<br>if (oldVnode.text !&#x3D;&#x3D; null &amp;&amp; newVnode.text !&#x3D;&#x3D; null &amp;&amp; oldVnode.text !&#x3D;&#x3D; newVnode.text) {<br>  &#x2F;&#x2F; 则直接将真实DOM中文本更新为新虚拟节点的文本<br>  api.setTextContent(el, newVnode.text)<br>} else {<br>  &#x2F;&#x2F; 否则<br>  if (oldCh &amp;&amp; newCh &amp;&amp; oldCh !&#x3D;&#x3D; newCh) {<br>&#x2F;&#x2F; 新旧虚拟节点都有子节点，且子节点不一样<br>&#x2F;&#x2F; 对比子节点，并更新<br>updateChildren(el, oldCh, newCh)<br>  } else if (newCh) {<br>&#x2F;&#x2F; 新虚拟节点有子节点，旧虚拟节点没有<br>&#x2F;&#x2F; 创建新虚拟节点的子节点，并更新到真实DOM上去<br>createEle(newVnode)<br>  } else if (oldCh) {<br>&#x2F;&#x2F; 旧虚拟节点有子节点，新虚拟节点没有<br>&#x2F;&#x2F;直接删除真实DOM里对应的子节点<br>api.removeChild(el)<br>  }<br>}<br>}<br>其他几个点都很好理解，我们详细来讲一下updateChildren<br>updateChildren方法<br>这是patchVnode里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在updateChildren方法中，接下来就结合一些图来讲，让大家更好理解吧<br>是怎么样一个对比方法呢？就是首尾指针法，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：<ul>  <li>a</li>  <li>b</li>  <li>c</li></ul>修改数据后<ul>  <li>b</li>  <li>c</li>  <li>e</li>  <li>a</li></ul>那么新旧两个子节点集合以及其首尾指针为：</li></ul><p>然后会进行互相进行比较，总共有五种比较情况：</p><ol><li>oldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)</li><li>oldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)</li><li>oldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)</li><li>oldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)</li><li>如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。</li></ol><p>接下来就以上面代码为例，分析一下比较的过程<br>分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置</p><p>第一步<br>oldS &#x3D; a, oldE &#x3D; c<br>newS &#x3D; b, newE &#x3D; a<br>比较结果：oldS 和 newE 相等，需要把节点a移动到newE所对应的位置，也就是末尾，同时oldS++，newE–</p><p>第二步<br>oldS &#x3D; b, oldE &#x3D; c<br>newS &#x3D; b, newE &#x3D; e<br>比较结果：oldS 和 newS相等，需要把节点b移动到newS所对应的位置，同时oldS++,newS++</p><p>第三步<br>oldS &#x3D; c, oldE &#x3D; c<br>newS &#x3D; c, newE &#x3D; e<br>比较结果：oldS、oldE 和 newS相等，需要把节点c移动到newS所对应的位置，同时oldS++,newS++</p><p>第四步<br>oldS &gt; oldE，则oldCh先遍历完成了，而newCh还没遍历完，说明newCh比oldCh多，所以需要将多出来的节点，插入到真实DOM上对应的位置上</p><p>思考题<br>我在这里给大家留一个思考题哈。上面的例子是newCh比oldCh多，假如相反，是oldCh比newCh多的话，那就是newCh先走完循环，然后oldCh会有多出的节点，结果会在真实DOM里进行删除这些旧节点。大家可以自己思考一下，模拟一下这个过程，像我一样，画图模拟，才能巩固上面的知识。<br>附上updateChildren的核心原理代码<br>function updateChildren(parentElm, oldCh, newCh) {<br>  let oldStartIdx &#x3D; 0, newStartIdx &#x3D; 0<br>  let oldEndIdx &#x3D; oldCh.length - 1<br>  let oldStartVnode &#x3D; oldCh[0]<br>  let oldEndVnode &#x3D; oldCh[oldEndIdx]<br>  let newEndIdx &#x3D; newCh.length - 1<br>  let newStartVnode &#x3D; newCh[0]<br>  let newEndVnode &#x3D; newCh[newEndIdx]<br>  let oldKeyToIdx<br>  let idxInOld<br>  let elmToMove<br>  let before<br>  while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) {<br>    if (oldStartVnode &#x3D;&#x3D; null) {<br>      oldStartVnode &#x3D; oldCh[++oldStartIdx]<br>    } else if (oldEndVnode &#x3D;&#x3D; null) {<br>      oldEndVnode &#x3D; oldCh[–oldEndIdx]<br>    } else if (newStartVnode &#x3D;&#x3D; null) {<br>      newStartVnode &#x3D; newCh[++newStartIdx]<br>    } else if (newEndVnode &#x3D;&#x3D; null) {<br>      newEndVnode &#x3D; newCh[–newEndIdx]<br>    } else if (sameVnode(oldStartVnode, newStartVnode)) {<br>      patchVnode(oldStartVnode, newStartVnode)<br>      oldStartVnode &#x3D; oldCh[++oldStartIdx]<br>      newStartVnode &#x3D; newCh[++newStartIdx]<br>    } else if (sameVnode(oldEndVnode, newEndVnode)) {<br>      patchVnode(oldEndVnode, newEndVnode)<br>      oldEndVnode &#x3D; oldCh[–oldEndIdx]<br>      newEndVnode &#x3D; newCh[–newEndIdx]<br>    } else if (sameVnode(oldStartVnode, newEndVnode)) {<br>      patchVnode(oldStartVnode, newEndVnode)<br>      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))<br>      oldStartVnode &#x3D; oldCh[++oldStartIdx]<br>      newEndVnode &#x3D; newCh[–newEndIdx]<br>    } else if (sameVnode(oldEndVnode, newStartVnode)) {<br>      patchVnode(oldEndVnode, newStartVnode)<br>      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)<br>      oldEndVnode &#x3D; oldCh[–oldEndIdx]<br>      newStartVnode &#x3D; newCh[++newStartIdx]<br>    } else {<br>      &#x2F;&#x2F; 使用key时的比较<br>      if (oldKeyToIdx &#x3D;&#x3D;&#x3D; undefined) {<br>        oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) &#x2F;&#x2F; 有key生成index表<br>      }<br>      idxInOld &#x3D; oldKeyToIdx[newStartVnode.key]<br>      if (!idxInOld) {<br>        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)<br>        newStartVnode &#x3D; newCh[++newStartIdx]<br>      }<br>      else {<br>        elmToMove &#x3D; oldCh[idxInOld]<br>        if (elmToMove.sel !&#x3D;&#x3D; newStartVnode.sel) {<br>          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)<br>        } else {<br>          patchVnode(elmToMove, newStartVnode)<br>          oldCh[idxInOld] &#x3D; null<br>          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)<br>        }<br>        newStartVnode &#x3D; newCh[++newStartIdx]<br>      }<br>    }<br>  }<br>  if (oldStartIdx &gt; oldEndIdx) {<br>    before &#x3D; newCh[newEndIdx + 1] &#x3D;&#x3D; null ? null : newCh[newEndIdx + 1].el<br>    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)<br>  } else if (newStartIdx &gt; newEndIdx) {<br>    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>  }<br>}<br>用index做key<br>平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？<br>我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表</p><ul>                      <ul>    <li key="0">a</li>        <li key="0">林三心</li>    <li key="1">b</li>        <li key="1">a</li>    <li key="2">c</li>        <li key="2">b</li>                             <li key="3">c</li></ul>                     </ul><p>按理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？废话不多说，实践一下：</p><ul>   <li v-for="(item, index) in list" :key="index"></li></ul><button @click="add">增加</button><p>list: [<br>        { title: “a”, id: “100” },<br>        { title: “b”, id: “101” },<br>        { title: “c”, id: “102” },<br>      ]<br>add() {<br>      this.list.unshift({ title: “林三心”, id: “99” });<br>}<br>点击按钮我们可以看到，并不是我们预想的结果，而是所有li标签都更新了</p><p>为什么会这样呢？还是通过图来解释<br>按理说，a，b，c三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个林三心</p><p>但是我们前面说了，在进行子节点的 diff算法 过程中，会进行 旧首节点和新首节点的sameNode对比，这一步命中了逻辑，因为现在新旧两次首部节点 的 key 都是 0了，同理，key为1和2的也是命中了逻辑，导致相同key的节点会去进行patchVnode更新文本，而原本就有的c节点，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行patchVnode更新文本，最后一个进行了新增，那就解释了为什么所有li标签都更新了。</p><p>那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了</p><ul>   <li v-for="item in list" :key="item.id"></li></ul>现在再来看看效果<p>为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，a，b，c节点的key就会是永远不变的，更新前后key都是一样的，并且又由于a，b，c节点的内容本来就没变，所以就算是进行了patchVnode，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Vue—虚拟DOM</title>
    <link href="https://superq314.github.io/posts/e7087c1d/"/>
    <id>https://superq314.github.io/posts/e7087c1d/</id>
    <published>2022-10-10T15:21:31.000Z</published>
    <updated>2022-10-10T15:29:00.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Virtual DOM<br>Virtual DOM是对DOM的抽象，本质上是JavaScript对象，这个对象就是更加轻量级的对DOM的描述。</p><p>Virtual DOM出现的原因<br>首先，前端性能优化的一个秘诀就是尽可能少地操作DOM，不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重回，这些都是性能的杀手，因此我们需要这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，这样保证了DOM不会出现性能很差的情况.<br>其次，现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率.<br>最后，Virtual DOM最初的目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR(服务端渲染)，那么一个方式就是借助Virtual DOM，因为Virtual DOM本身是JavaScript对象。<br>Virtual DOM的关键要素<br>Virtual DOM的创建<br>根据不同的需求，可以做出不同的抽象。<br>最简单的抽象方法如下:<br>{<br>  type, &#x2F;&#x2F; String，DOM 节点的类型，如 ‘div’<br>  data, &#x2F;&#x2F; Object，包括 props，style等等 DOM 节点的各种属性<br>  children &#x2F;&#x2F; Array，子节点<br>}<br>复杂的抽象，比如snabbdom.js的抽象方式是这样的.</p><p>在明确了抽象的Virtual DOM构造之后，就需要一个函数来创建Virtual DOM.<br>&#x2F;**</p><ul><li>生成 vnode</li><li>@param  {String} type     类型，如 ‘div’</li><li>@param  {String} key      key vnode的唯一id</li><li>@param  {Object} data     data，包括属性，事件等等</li><li>@param  {Array} children  子 vnode</li><li>@param  {String} text     文本</li><li>@param  {Element} elm     对应的 dom</li><li>@return {Object}          vnode<br> *&#x2F;<br>function vnode(type, key, data, children, text, elm) {<br>  const element &#x3D; {<br> __type: VNODE_TYPE,<br> type, key, data, children, text, elm<br>  }</li></ul><p>  return element<br>}<br>这个函数很简单,接受一定的参数,再根据这些参数返回一个对象,这个对象就是DOM的抽象.<br>Virtual DOM Tree的创建<br>上面已经声明了一个vnode函数用于单个Virtual DOM的创建工作<br>但是DOM其实是一个Tree，接下来要做的就是声明一个函数用于创建DOM Tree的抽象 – Virtual DOM Tree。<br>function h(type, config, …children) {<br>  const props &#x3D; {}</p><p>  let key &#x3D; null</p><p>  &#x2F;&#x2F; 获取 key，填充 props 对象<br>  if (config !&#x3D; null) {<br>    if (hasValidKey(config)) {<br>      key &#x3D; ‘’ + config.key<br>    }</p><pre><code>for (let propName in config) &#123;  if (hasOwnProperty.call(config, propName)&amp;&amp; !RESERVED_PROPS[propName]) &#123;    props[propName] = config[propName]  &#125;&#125;</code></pre><p>  }</p><p>  return vnode(<br>    type,<br>    key,<br>    props,<br>    flattenArray(children).map(c &#x3D;&gt; {<br>      return isPrimitive(c) ? vnode(undefined, undefined, undefined, undefined, c) : c<br>    })<br>  )<br>}<br>Virtual DOM 的更新<br>Virtual DOM 归根到底是JavaScript对象，需要将Virtual DOM与真实的DOM对应起来，也就是说，需要声明一个函数，将vnode转化为真实DOM.<br>function createElm(vnode, insertedVnodeQueue) {<br>  let data &#x3D; vnode.data<br>  let i<br>  &#x2F;&#x2F; 省略 hook 调用<br>  let children &#x3D; vnode.children<br>  let type &#x3D; vnode.type</p><p>  &#x2F;&#x2F;&#x2F; 根据 type 来分别生成 DOM<br>  &#x2F;&#x2F; 处理 comment<br>  if (type &#x3D;&#x3D;&#x3D; ‘comment’) {<br>    if (vnode.text &#x3D;&#x3D; null) {<br>      vnode.text &#x3D; ‘’<br>    }<br>    vnode.elm &#x3D; api.createComment(vnode.text)<br>  }<br>  &#x2F;&#x2F; 处理其它 type<br>  else if (type) {<br>    const elm &#x3D; vnode.elm &#x3D; data.ns<br>      ? api.createElementNS(data.ns, type)<br>      : api.createElement(type)</p><pre><code>// 调用 create hookfor (let i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode)// 分别处理 children 和 text。// 这里隐含一个逻辑：vnode 的 children 和 text 不会／应该同时存在。if (isArray(children)) &#123;  // 递归 children，保证 vnode tree 中每个 vnode 都有自己对应的 dom；  // 即构建 vnode tree 对应的 dom tree。  children.forEach(ch =&gt; &#123;    ch &amp;&amp; api.appendChild(elm, createElm(ch, insertedVnodeQueue))  &#125;)&#125;else if (isPrimitive(vnode.text)) &#123;  api.appendChild(elm, api.createTextNode(vnode.text))&#125;// 调用 create hook；为 insert hook 填充 insertedVnodeQueue。i = vnode.data.hookif (i) &#123;  i.create &amp;&amp; i.create(emptyNode, vnode)  i.insert &amp;&amp; insertedVnodeQueue.push(vnode)&#125;</code></pre><p>  }<br>  &#x2F;&#x2F; 处理 text（text的 type 是空）<br>  else {<br>    vnode.elm &#x3D; api.createTextNode(vnode.text)<br>  }</p><p>  return vnode.elm<br>}<br>上述函数其实工作很简单，就是根据 type 生成对应的 DOM，把 data 里定义的 各种属性设置到 DOM 上。<br>Virtual DOM 的diff<br>Virtual DOM 的 diff是整个Virtual DOM 中最难理解也最核心的部分<br>diff的目的：比较新旧Virtual DOM Tree找出差异并更新。<br>可见diff是直接影响Virtual DOM 性能的关键部分。<br>要比较Virtual DOM Tree的差异，理论上的时间复杂度高达O(n^3)。<br>在实际开发中，很少会出现跨层级的DOM变更，通常情况下的DOM变更是同级的，因此在现代的各种Virtual DOM库都是只比较同级差异，在这种情况下时间复杂度是O(n)。</p><p>那么我们接下来需要实现一个函数,进行具体的diff运算,函数updateChildren的核心算法如下:<br>&#x2F;&#x2F; 遍历 oldCh 和 newCh 来比较和更新<br>    while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) {<br>      &#x2F;&#x2F; 1. 首先检查4种情况<br>      &#x2F;&#x2F; 保证oldStart、oldEnd、newStart、newEnd这4个vnode非空<br>      &#x2F;&#x2F; 左侧的vnode为空就右移下标，右侧的vnode为空就左移下标。<br>      if (oldStartVnode &#x3D;&#x3D; null) {<br>        oldStartVnode &#x3D; oldCh[++oldStartIdx]<br>      } else if (oldEndVnode &#x3D;&#x3D; null) {<br>        oldEndVnode &#x3D; oldCh[–oldEndIdx]<br>      } else if (newStartVnode &#x3D;&#x3D; null) {<br>        newStartVnode &#x3D; newCh[++newStartIdx]<br>      } else if (newEndVnode &#x3D;&#x3D; null) {<br>        newEndVnode &#x3D; newCh[–newEndIdx]<br>      }</p><pre><code>  // 2. oldStartVnode、oldEndVnode、newStartVnode、newEndVnode两两比较  // 对vnode相同的4种情况执行对应的patch逻辑。  // - 如果同start或同end的两个vnode是相同的（情况1和2）  //   说明不用移动实际dom，直接更新dom属性／children即可  // - 如果start和end两个vnode相同（情况3和4）  //   那说明发生了vnode的移动，同理我们也要移动dom  //  // 情况1. 如果oldStartVnode和newStartVnode相同，执行 patch  else if (isSameVnode(oldStartVnode, newStartVnode)) &#123;    // 不需要移动dom    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)    oldStartVnode = oldCh[++oldStartIdx]    newStartVnode = newCh[++newStartIdx]  &#125;  // 情况2. 如果oldEndVnode和newEndVnode相同，执行patch  else if (isSameVnode(oldEndVnode, newEndVnode)) &#123;    // 不需要移动dom    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)    oldEndVnode = oldCh[--oldEndIdx]    newEndVnode = newCh[--newEndIdx]  &#125;  // 情况3. 如果oldStartVnode和newEndVnode相同，执行patch  else if (isSameVnode(oldStartVnode, newEndVnode)) &#123;    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)    // 把获得更新后的 (oldStartVnode/newEndVnode) 的dom右移，移动到oldEndVnode 对应的 dom 的右边。// 为什么这么右移？    // （1）oldStartVnode 和 newEndVnode 相同，显然是 vnode 右移。    // （2）若 while 循环刚开始，那移到 oldEndVnode.elm 右边就是最右边，是合理的；    // （3）若循环不是刚开始，因为比较过程是两头向中间，那么两头的 dom 的位置已经是合理的了，移动到 oldEndVnode.elm 右边是正确的位置；    // （4）记住，oldVnode 和 vnode 是相同的才 patch，且 oldVnode 自己对应的 dom总是已经存在的，vnode 的 dom 是不存在的，直接复用 oldVnode 对应的 dom。    api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm))    oldStartVnode = oldCh[++oldStartIdx]    newEndVnode = newCh[--newEndIdx]  &#125;  // 情况4. 如果 oldEndVnode 和 newStartVnode 相同，执行 patch  else if (isSameVnode(oldEndVnode, newStartVnode)) &#123;    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)    // 这里是左移更新后的 dom，原因参考上面的右移。    api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)    oldEndVnode = oldCh[--oldEndIdx]    newStartVnode = newCh[++newStartIdx]  &#125;  // 3. 最后一种情况：4 个 vnode 都不相同  // 1. 从 oldCh 数组建立 key --&gt; index 的 map。  // 2. 只处理 newStartVnode （简化逻辑，有循环我们最终还是会处理到所有 vnode），以它的 key 从上面的 map 里拿到 index；  // 3. 如果 index 存在，那么说明有对应的 old vnode，patch 就好了；  // 4. 如果 index 不存在，那么说明 newStartVnode 是全新的 vnode，直接创建对应的 dom 并插入。  else &#123;    // 如果 oldKeyToIdx 不存在，创建 old children 中 vnode 的 key 到 index 的映射，方便我们之后通过 key 去拿下标。    if (oldKeyToIdx === undefined) &#123;      oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)    &#125;    // 尝试通过 newStartVnode 的 key 去拿下标    idxInOld = oldKeyToIdx[newStartVnode.key]    // 下标不存在，说明 newStartVnode 是全新的 vnode。    if (idxInOld == null) &#123;      // 那么为 newStartVnode 创建 dom 并插入到 oldStartVnode.elm 的前面。      api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)      newStartVnode = newCh[++newStartIdx]    &#125;    // 下标存在，说明 old children 中有相同 key 的 vnode，    else &#123;      elmToMove = oldCh[idxInOld]      // 如果 type 不同，没办法，只能创建新 dom；      if (elmToMove.type !== newStartVnode.type) &#123;        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)      &#125;      // type 相同（且key相同），那么说明是相同的 vnode，执行 patch。      else &#123;        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)        oldCh[idxInOld] = undefined        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm)      &#125;      newStartVnode = newCh[++newStartIdx]    &#125;  &#125;&#125;// 上面的循环结束后（循环条件有两个），处理可能的未处理到的 vnode。// 如果是 new vnodes 里有未处理的（oldStartIdx &gt; oldEndIdx// 说明 old vnodes 先处理完毕）if (oldStartIdx &gt; oldEndIdx) &#123;  before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm  addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)&#125;// 相反，如果old vnodes有未处理的，删除（为处理vnodes对应的）多余的dom。else if (newStartIdx &gt; newEndIdx) &#123;  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)&#125;</code></pre><p>  }<br>我们可以假设有旧的Vnode数组和新的Vnode数组这两个数组,而且有四个变量充当指针分别指到两个数组的头尾.<br>重复下面的对比过程，直到两个数组中任一数组的头指针超过尾指针，循环结束 :</p><ol><li>头头对比: 对比两个数组的头部，如果找到，把新节点patch到旧节点，头指针后移</li><li>尾尾对比: 对比两个数组的尾部，如果找到，把新节点patch到旧节点，尾指针前移</li><li>旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点patch到旧节点，旧尾指针前移，新头指针后移</li><li>旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点patch到旧节点，新尾指针前移，旧头指针后移</li><li>利用key对比: 用新指针对应节点的key去旧数组寻找对应的节点,这里分三种情况,当没有对应的key，那么创建新的节点,如果有key并且是相同的节点，把新节点patch到旧节点,如果有key但是不是相同的节点，则创建新节点<br>假设有新旧两个数组:<br>旧数组: [1, 2, 3, 4, 5]<br>新数组: [1, 4, 6, 1000, 100, 5]</li></ol><p>首先我们进行头头对比,新旧数组的头部都是1,因此将双方的头部指针后移.</p><p>我们继续头头对比,但是2 !&#x3D;&#x3D; 4导致对比失败,我进入尾尾对比,5 &#x3D;&#x3D;&#x3D; 5,那么尾部指针则可前移.</p><p>现在进入新的循环,头头对比2 !&#x3D;&#x3D; 4,尾尾对比4 !&#x3D;&#x3D; 100,此时进入交叉对比,先进行旧尾新头对比,即4 &#x3D;&#x3D;&#x3D; 4,旧尾前移且新头后移.</p><p>接着再进入一个轮新的循环,头头对比2 !&#x3D;&#x3D; 6,尾尾对比3 !&#x3D;&#x3D; 100,交叉对比2 !&#x3D; 100 3 !&#x3D; 6,四种对比方式全部不符合,如果这个时候需要通过key去对比,然后将新头指针后移</p><p>继续重复上述对比的循环方式直至任一数组的头指针超过尾指针，循环结束.</p><p>在上述循环结束后,两个数组中可能存在未遍历完的情况: 循环结束后，<br>先对比旧数组的头尾指针，如果旧数组遍历完了（可能新数组没遍历完，有漏添加的问题），添加新数组中漏掉的节点</p><p>再对比新数组的头尾指针，如果新数组遍历完了（可能旧数组没遍历完，有漏删除的问题），删除旧数组中漏掉的节点</p><p>Virtual DOM的优化<br>具体的优化思想可以先参考diff 算法原理概述,其中一个核心的思想就是利用LIS(最长递增子序列)的思想做动态规划,找到最小的移动次数.<br>例如以下两个新旧数组,React的算法会把 a, b, c 移动到他们的相应的位置 + 1共三步操作,而inferno.js则是直接将d移动到最前端这一步操作.</p><ul><li>A: [a b c d]</li><li>B: [d a b c]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Vue—异步更新队列nextTick</title>
    <link href="https://superq314.github.io/posts/bd4e159e/"/>
    <id>https://superq314.github.io/posts/bd4e159e/</id>
    <published>2022-10-10T15:21:19.000Z</published>
    <updated>2022-10-10T15:28:31.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nextTick的官方解释：</p><blockquote><p><strong>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM</strong></p></blockquote><p>平民解释</p><blockquote><p>对Vue中data数据的修改会导致界面对应的响应变化，而通过nextTick方法，可以在传入nextTick的回调函数中获取到变化后的DOM，</p></blockquote><p>全局的<br>Vue.nextTick( [callback, context] );<br>实例vm的<br>vm.$nextTick( [callback] );<br>异步更新队列<br>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。<br>如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><blockquote><p>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<br>然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。<br>例如，当你设置 vm.someData &#x3D; ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。<br>多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。<br>虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。<br>为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。<br>这样回调函数将在 DOM 更新完成后被调用。例如：</p></blockquote><div id="example"></div>var vm = new Vue({  el: '#example',  data: {    message: '123'  }})vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () {  vm.$el.textContent === 'new message' // true})在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：Vue.component('example', {  template: '<span></span>',  data: function () {    return {      message: '未更新'    }  },  methods: {    updateMessage: function () {      this.message = '已更新'      console.log(this.$el.textContent) // => '未更新'      this.$nextTick(function () {        console.log(this.$el.textContent) // => '已更新'      })    }  }})因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2017 async/await 语法完成相同的事情：methods: {  updateMessage: async function () {    this.message = '已更新'    console.log(this.$el.textContent) // => '未更新'    await this.$nextTick()    console.log(this.$el.textContent) // => '已更新'  }}<p>实现一个简化版的Vue。<br>Vue响应式原理的核心就是Observer、Dep、Watcher。<br>Observer中进行响应式的绑定，在数据被读的时候，触发get方法，执行Dep来收集依赖，也就是收集Watcher。<br>在数据被改的时候，触发set方法，通过对应的所有依赖(Watcher)，去执行更新。比如watch和computed就执行开发者自定义的回调方法。<br>Vue类</p><p>首先我们实现一个Vue类，用于创建Vue对象，它的的构造方法接收一个options参数，用于初始化Vue。<br>class Vue{<br>    constructor(options){<br>       this.$el&#x3D;options.el;<br>       this._data&#x3D;options.data;<br>       this.$data&#x3D;this._data;<br>       &#x2F;&#x2F;对data进行响应式处理<br>       new Observe(this._data);<br>   }<br>}&#x2F;&#x2F;创建Vue对象new Vue({<br>    el:’#app’,<br>    data:{<br>      message:’hello world’<br>    }<br>})</p><p>上面的代码中我们首先创建了一个Vue的类，构造函数跟我们平时使用的Vue大致一致，为了容易理解我们这里只处理了参数el和data。<br>我们发现构造函数的最后一行创建了一个Observe类的对象，并传入data作为参数，这里的Observe就是对data数据进行响应式处理的类，接下来我们看一下Observe类的简单实现。<br>Observer类（响应式）<br>我们在Observe类中实现对data的监听，就是通过Object.defineProperty()方法实现的数据劫持，代码如下。<br>class Observer {<br>    constructor(data){<br>       &#x2F;&#x2F; 响应式绑定数据<br>       &#x2F;&#x2F;如果传入的数据是object<br>       if(typeof data&#x3D;&#x3D;’object’){<br>           this.walk(data);<br>       }<br>    }<br>    &#x2F;&#x2F;这个方法遍历对象中的属性，并依次对其进行响应式处理<br>    walk(obj){<br>        &#x2F;&#x2F;获取所有属性<br>        const keys&#x3D;Object.keys(obj);<br>        for (let i &#x3D; 0; i &lt; keys.length; i++) {<br>            &#x2F;&#x2F;对所有属性进行监听（数据劫持）<br>            this.defineReactive(obj, keys[i])<br>        }<br>    }<br>    defineReactive(obj,key){<br>        if(typeof obj[key]&#x3D;&#x3D;’object’){<br>            &#x2F;&#x2F;如果属性是对象，那么那么递归调用walk方法<br>            this.walk(obj[key]);<br>        }<br>        const dep&#x3D;new Dep();&#x2F;&#x2F;Dep类用于收集依赖<br>        const val&#x3D;obj[key];<br>        Object.defineProperty(obj, key, {<br>            enumerable: true,<br>            configurable: true,<br>            &#x2F;&#x2F;get代理将Dep.target即Watcher对象添加到依赖集合中<br>            get() {<br>              &#x2F;&#x2F;这里在创建Watcher对象时会给Dep.target赋值<br>              if (Dep.target) {<br>                dep.addSubs(Dep.target);<br>              }<br>              return val;<br>            },<br>            set(newVal) {<br>                val&#x3D;newVal;<br>                &#x2F;&#x2F;依赖的变更响应<br>                dep.notify(newVal)<br>            }<br>          })<br>    }<br>}</p><p>上述代码中我们使用到了Dep类，我们在劫持到的数据的get方法中收集到的依赖会被放到Dep类中保存。<br>Dep类（依赖管理）<br>通过defineReactive方法将data中的数据进行响应式后，虽然可以监听到数据的变化了，那怎么处理通知视图就更新呢？<br>Dep就是用来收集【究竟要通知到哪里的】。<br>下面代码是Dep类的实现，他有一个subs的数组，用于保存依赖，这里的依赖是我们后面要定义的Watcher，Watcher即观察者，<br>class Dep{<br>   static target&#x3D;null<br>   constructor(){<br>       this.subs&#x3D;[];<br>   }<br>   addSubs(watcher){<br>       this.subs.push(watcher)<br>   }<br>   notify(newVal){<br>       for(let i&#x3D;0;i&lt;this.subs.length;i++){<br>           this.subs[i].update(newVal);<br>       }<br>   }<br>}<br>Watcher类（中介）<br>观察者类，它做的事情就是观察数据的变更，它会调用data中对应属性的get方法触发依赖收集，并在数据变更后执行相应的更新。<br>let uid&#x3D;0class Watcher{<br>    &#x2F;&#x2F;vm即一个Vue对象，key要观察的属性，cb是观测到数据变化后需要做的操作，通常是指DOM变更<br>    constructor(vm,key,cb){<br>       this.vm&#x3D;vm;<br>       this.uid&#x3D;uid++;<br>       this.cb&#x3D;cb;<br>       &#x2F;&#x2F;调用get触发依赖收集之前，把自身赋值给Dep.taget静态变量<br>       Dep.target&#x3D;this;<br>       &#x2F;&#x2F;触发对象上代理的get方法，执行get添加依赖<br>       this.value&#x3D;vm.$data[key];<br>       &#x2F;&#x2F;用完即清空<br>       Dep.target&#x3D;null;<br>    }<br>    &#x2F;&#x2F;在调用set触发Dep的notify时要执行的update函数，用于响应数据变化执行run函数即dom变更<br>    update(newValue){<br>        &#x2F;&#x2F;值发生变化才变更<br>        if(this.value!&#x3D;&#x3D;newValue){<br>            this.value&#x3D;newValue;<br>            this.run();<br>        }<br>    }<br>    &#x2F;&#x2F;执行DOM更新等操作<br>    run(){<br>        this.cb(this.value);<br>    }<br>}</p><p>通过以上的代码我们就实现了一个去除了模板编译的简易版的Vue，我们用简单化模拟dom的变更。<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>let data&#x3D;{<br>    message:’hello’,<br>    num:0<br>}<br>let app&#x3D;new Vue({<br>    data:data<br>});<br>&#x2F;&#x2F;模拟数据监听<br>new Watcher(app,’message’,function(value){<br>    &#x2F;&#x2F;模拟dom变更<br>    console.log(‘message 引起的dom变更—&gt;’,value);<br>})<br>new Watcher(app,’num’,function(value){<br>    &#x2F;&#x2F;模拟dom变更<br>    console.log(‘num 引起的dom变更—&gt;’,value);<br>})<br>data.message&#x3D;’world’;<br>data.num&#x3D;100;</p><p>以上测试代码输出<br>message 引起的dom变更—&gt;world num 引起的dom变更—&gt;100</p><p>Vue为什么需要nextTick呢？nextTick又是如何实现的呢？<br>因为 vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新DOM，<br>而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更;<br>探索<br>这里我们就抱着好奇的心态，理解一下nextTick函数的实现原理，加深对Vue底层原理的理解。</p><p>要想理解nextTick的设计意图和实现原理我们需要两块的前置知识理解：<br>1.Vue响应式原理（理解设计意图）<br>2.浏览器事件循环机制（理解原理）<br>因此本次行文先简单讲解以上两部分内容，最后将知识整合详细介绍nextTick的实现原理。</p><p>到Vue中nextTick的实现，必须提到一个新概念异步更新队列，这里有两个关键字异步，更新队列。这理解这个概念我们就需要回顾一下前面我们写的简易版的Vue是如何响应数据并模拟dom更新的，这里我们在整体捋一遍流程：</p><p>Observe为数据添加代理，当我们使用到数据时，通过get代理方法我们可以收集到依赖该数据的Watcher对象，并且保存到Dep中作为该数据的依赖，这个过程就是依赖收集；</p><p>然后当我们修改数据时，会触发数据的set代理方法，进而执行Dep的notify方法触发所有依赖项的update方法执行更新。</p><p>而问题就出在了更新这一步，这里我们触发更新是同步执行的，即立即执行，像前面的for循环会频繁更新n多次，这造成了性能的浪费，尤其对于dom更新来说，一来是dom更新是昂贵的，二来这其中大多数是用户无法观测到的无效更新（因为浏览器事件循环机制中，一次循环中只有一次界面渲染）。</p><p>当模板中存在多处变量依赖的时候，每一个变量修改的时候，都会导致一次更新渲染。<br>for(let i&#x3D;0;i&lt;100;i++){ data.num&#x3D;i;&#x2F;&#x2F;每次的data数据的变化都会调用Watcher的update去更新DOM }<br>简单来说</p><blockquote><p>每次数据变化之后不是立刻去执行DOM更新，而是要把数据变化的动作缓存起来，在合适的时机只执行一次的dom更新操作。<br>这里就需要设置一个合适的时间间隔，通过下面要介绍的事件循环机制可以很完美的解决。</p></blockquote><p>1、JS 运行机制<br>JS 的执行是单线程的，所谓的单线程就是事件任务要排队执行，前一个任务结束，才会执行后一个任务，这就是同步任务，为了避免前一个任务执行了很长时间还没结束，那下一个任务就不能执行的情况，引入了异步任务的概念。JS 运行机制简单来说可以按以下几个步骤。<br>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，会把其回调函数作为一个任务添加到任务队列中。<br>一旦执行栈中的所有同步任务执行完毕，就会读取任务队列，看看里面有那些任务，将其添加到执行栈，开始执行。<br>主线程不断重复上面的第三步。也就是常说的事件循环(Event Loop)。<br>事件循环机制（简单回顾）<br>简单理解浏览器事件循环机制，即在js代码中执行中包括两种类型的任务，宏任务和微任务。宏任务即我们编写的顺序执行的代码和诸如setTimeout创建的任务，微任务则为通过诸如Promise.then中回调函数中执行的代码。</p><p>事件执行顺序：<br>宏任务<br>本次宏任务产生的所有微任务<br>render（视图更新）<br>下一次宏任务</p><p>我们的数据变化缓存可以依赖事件循环来完成；因为每次事件循环之间都有一次视图渲染，我们只需要在render之前完成对dom的更新即可，因此我们为了避免无效的DOM操作，需要将数据变更缓存起来，只保存最后一次数据最终的变更结果。</p><p>这里简单给出两种实现方法：setTimeout和Promise。</p><ul><li>常用的setTimeout会创建一个宏任务，会在此次同步代码执行完成后执行</li><li>Promise.then创建一个微任务，微任务会在本次事件循环同步代码执行结束后执行<br>区别：在setTimeout代码执行之前会穿插一次无效的视图渲染，因此尽量使用Promise创建微任务实现异步更新。</li></ul><p>思路整理<br>借助浏览器的事件循环机制实现异步更新，每次时间循环期间只执行一次dom变更。<br>首先我们为每个要观察的数据创建了一个Watcher对象，当数据变更时，会触发Watcher对象的update方法，但是此时我们不再直接在update中触发run方法执行更新，而是把这个变更的Watcher保存到一个待更新的队列（数组实现）中，同时我们为这个待更新的队列创建一个微任务来执行它里面保存的更新，有了这个思路，接下来我们就从Watcher开始进行改造吧。<br>开始改造<br>我们先看原来的Watcher中update方法的实现：<br> update(newValue){<br>        &#x2F;&#x2F;值发生变化才变更<br>        if(this.value!&#x3D;&#x3D;newValue){<br>            this.value&#x3D;newValue;<br>            this.run();<br>        }<br>    }<br>    &#x2F;&#x2F;执行DOM更新等操作<br>    run(){<br>        this.cb(this.value);<br>    }<br>这里的update方法中发现数据变更之后是立即执行run方法进行dom更新操作的，我们对它进行修改，首先需要创建一个全局的updateQueue数组来作为队列保存当前变更的数据对应的Watcher，之后再update方法中不再直接执行run方法，而是把当前变更的Watcher对象本身添加到更新队列updateQueue中<br>    let updateQueue&#x3D;[];&#x2F;&#x2F;注意，这个数组是全局声明，不再Watcher类中<br>    update(newValue){<br>        &#x2F;&#x2F;值发生变化才变更<br>        if(this.value!&#x3D;&#x3D;newValue){<br>            this.value&#x3D;newValue;<br>            &#x2F;&#x2F;在异步更新队列中添加Watcher，用于后续更新<br>            updateQueue.push(this);<br>        }<br>    }<br>    &#x2F;&#x2F;执行DOM更新等操作<br>    run(){<br>        this.cb(this.value);<br>    }<br>上面的代码我们把变更了的Watcher添加到更新队列updateQueque中，用于后续的更新，下面我们编写一个清空更新队列并依次执行更新的函数，这个函数之后要在微任务中执行。<br>function flushUpdateQueue(){<br>    while(updateQueue.length&gt;0){<br>        updateQueue.shift().run();<br>    }<br>}</p><p>现在我们有了一个处理更新队列的函数，但是现在还缺少一个很重要的步骤，就是执行此函数的时机，这时我们就可以用到上面提到的事件循环机制了，即使用setTimeout或者Promise实现异步更新，这个实现过程就是nextTick的代码实现了，下面是简化版nextTick函数实现：<br>let callbacks&#x3D;[];&#x2F;&#x2F;事件队列,包含异步dom更新队列和用户添加的异步事件<br>let pending&#x3D;false;&#x2F;&#x2F;控制变量，每次宏任务期间执行一次flushCallbacks清空callbacks<br>funciton nextTick(cb){<br>   callbacks.push(cb);<br>   if(!pending){<br>      pending&#x3D;true;<br>      &#x2F;&#x2F;这里也可以使用Promise，Promise创建的是微任务，微任务会在本次事件循环同步代码执行结束后执行，使用setTimeout创建的是宏任务，同样会在此次同步代码执行完成后执行，区别是在setTimeout代码执行之前会穿插一次无效的视图渲染，因此我们尽量使用Promise创建微任务实现异步更新。<br>      if(Promise){<br>          Promise.resovle().then(()&#x3D;&gt;{<br>              flushCallbacks();<br>          })<br>      }else{<br>          setTimeout(()&#x3D;&gt;{<br>              flushCallbacks();<br>          })<br>      }<br>   }<br>}<br>function flushCallbacks(){<br>    pending&#x3D;false;&#x2F;&#x2F;状态重置<br>    callbacks.forEach(cb&#x3D;&gt;{<br>        callbacks.shift()();<br>    })<br>}</p><p>主要做了两件事，创建callbacks数组作为保存事件的队列，我们每次调用nextTick函数就往callbacks事件队列中入队一个事件，然后我们在setTimeout或者Promise.then创建的异步事件中，通过flushCallbacks将异步队列中的函数一次出队并执行。</p><p>这里使用pending变量控制本次同步（宏）任务期间不重复创建异步任务（setTimeout或者Promise.then）。</p><p>把上述代码添加到Vue类上：<br>class Vue{<br>    constructor(options){<br>        this.waiting&#x3D;false<br>        this.$el&#x3D;options.el;<br>        this._data&#x3D;options.data;<br>        this.$data&#x3D;this._data;<br>        this.$nextTick&#x3D;this.nextTick;<br>        new Observer(this._data);<br>    }<br>    &#x2F;&#x2F;简易版nextTick<br>    nextTick(cb){<br>         callbacks.push(cb);<br>         if(!pending){&#x2F;&#x2F;控制变量，控制每次事件循环期间只执行一次flushCallbacks<br>             pending&#x3D;true;<br>             if(Promise){<br>                  Promise.resovle().then(()&#x3D;&gt;{<br>                      this.flushCallbacks();<br>                  })<br>              }else{<br>                  setTimeout(()&#x3D;&gt;{<br>                      this.flushCallbacks();<br>                  })<br>              }<br>         }<br>    }<br>      &#x2F;&#x2F;清空callbacks<br>    flushCallbacks(){<br>       while(callbacks.length!&#x3D;0){<br>         callbacks.shift()(this);&#x2F;&#x2F;这里把当前vue实例传入，为了后续flushUpdateQueue获取waiting<br>      }<br>      pending&#x3D;false;<br>    }<br>    &#x2F;&#x2F;清空UpdateQueue队列，更新视图<br>    flushUpdateQueue(vm){<br>        while(updateQueue.length!&#x3D;0){<br>           updateQueue.shift().run();<br>        }<br>        has&#x3D;{};<br>        vm.waiting&#x3D;false;<br>    }<br> }</p><p>对Watcher进行进一步完善如下：<br>class Watcher{<br>     constructor(vm,key,cb){<br>        this.vm&#x3D;vm;<br>        this.key&#x3D;key;<br>        this.uid&#x3D;uid++;<br>        this.cb&#x3D;cb;<br>        &#x2F;&#x2F;调用get，添加依赖<br>        Dep.target&#x3D;this;<br>        this.value&#x3D;vm.$data[key];<br>        Dep.target&#x3D;null;<br>     }<br>     update(){<br>         if(this.value!&#x3D;&#x3D;this.vm.$data[this.key]){<br>             this.value&#x3D;this.vm.$data[this.key];<br>             if(!this.vm.waiting){&#x2F;&#x2F;控制变量，控制每次事件循环期间只添加一次flushUpdateQueue到callbacks<br>                this.vm.$nextTick(this.vm.flushUpdateQueue);<br>                this.vm.waiting&#x3D;true;<br>             }<br>             &#x2F;&#x2F;不是立即执行run方法，而是放入updateQueue队列中<br>             if(!has[this.uid]){<br>                 has[this.uid]&#x3D;true;<br>                 updateQueue.push(this);<br>             }<br>         }<br>     }<br>     run(){<br>         this.cb(this.value);<br>     }<br> }</p><p>这里我们对Watcher类的update方法做了进一步的完善，我们通过给nextTick函数传入之前定义好的flushUpdateQueue完成dom更新。<br>另外，上述代码还添加了一个对象has来确保不添加重复的Watcher对象到异步更新队列中。<br>完整源码<br>class Dep{<br>    static target&#x3D;null<br>    constructor(){<br>        this.subs&#x3D;[];<br>    }<br>    addSubs(watcher){<br>        this.subs.push(watcher)<br>    }<br>    notify(){<br>        for(let i&#x3D;0;i&lt;this.subs.length;i++){<br>            this.subs[i].update();<br>        }<br>    }<br> }<br> class Observer{<br>     constructor(data){<br>        if(typeof data&#x3D;&#x3D;’object’){<br>            this.walk(data);<br>        }<br>     }<br>     walk(obj){<br>         const keys&#x3D;Object.keys(obj);<br>         for (let i &#x3D; 0; i &lt; keys.length; i++) {<br>             this.defineReactive(obj, keys[i])<br>         }<br>     }<br>     defineReactive(obj,key){<br>         if(typeof obj[key]&#x3D;&#x3D;’object’){<br>             this.walk(obj[key]);<br>         }<br>         const dep&#x3D;new Dep();<br>         let val&#x3D;obj[key];<br>         Object.defineProperty(obj, key, {<br>             enumerable: true,<br>             configurable: true,<br>             &#x2F;&#x2F;get代理将Dep.target即Watcher对象添加到依赖集合中<br>             get: function reactiveGetter () {<br>               if (Dep.target) {<br>                 dep.addSubs(Dep.target);<br>               }<br>               return val;<br>             },<br>             set: function reactiveSetter (newVal) {<br>                  val&#x3D;newVal;<br>                  dep.notify()<br>             }<br>           })<br>     }<br> }<br> let uid&#x3D;0<br> class Watcher{<br>     constructor(vm,key,cb){<br>        this.vm&#x3D;vm;<br>        this.key&#x3D;key;<br>        this.uid&#x3D;uid++;<br>        this.cb&#x3D;cb;<br>        &#x2F;&#x2F;调用get，添加依赖<br>        Dep.target&#x3D;this;<br>        this.value&#x3D;vm.$data[key];<br>        Dep.target&#x3D;null;<br>     }<br>     update(){<br>         if(this.value!&#x3D;&#x3D;this.vm.$data[this.key]){<br>             this.value&#x3D;this.vm.$data[this.key];<br>             if(!this.vm.waiting){&#x2F;&#x2F;控制变量，控制每次事件循环期间只添加一次flushUpdateQueue到callbacks<br>                this.vm.$nextTick(this.vm.flushUpdateQueue);<br>                this.vm.waiting&#x3D;true;<br>             }<br>             &#x2F;&#x2F;不是立即执行run方法，而是放入updateQueue队列中<br>             if(!has[this.uid]){<br>                 has[this.uid]&#x3D;true;<br>                 updateQueue.push(this);<br>             }<br>         }<br>     }<br>     run(){<br>         this.cb(this.value);<br>     }<br> }<br>  const updateQueue&#x3D;[];&#x2F;&#x2F;异步更新队列<br>  let has&#x3D;{};&#x2F;&#x2F;控制变更队列中不保存重复的Watcher<br>  const callbacks&#x3D;[];<br>  let pending&#x3D;false;<br> class Vue{<br>    constructor(options){<br>        this.waiting&#x3D;false<br>        this.$el&#x3D;options.el;<br>        this._data&#x3D;options.data;<br>        this.$data&#x3D;this._data;<br>        this.$nextTick&#x3D;this.nextTick;<br>        new Observer(this._data);<br>    }<br>    &#x2F;&#x2F;简易版nextTick<br>    nextTick(cb){<br>         callbacks.push(cb);<br>         if(!pending){&#x2F;&#x2F;控制变量，控制每次事件循环期间只执行一次flushCallbacks<br>             pending&#x3D;true;<br>             setTimeout(()&#x3D;&gt;{<br>                 &#x2F;&#x2F;会在同步代码（上一次宏任务）执行完成后执行<br>                 this.flushCallbacks();<br>             })<br>         }<br>     }<br>    &#x2F;&#x2F;清空UpdateQueue队列，更新视图<br>    flushUpdateQueue(vm){<br>        while(updateQueue.length!&#x3D;0){<br>           updateQueue.shift().run();<br>        }<br>        has&#x3D;{};<br>        vm.waiting&#x3D;false;<br>    }<br>    &#x2F;&#x2F;清空callbacks<br>    flushCallbacks(){<br>       while(callbacks.length!&#x3D;0){<br>         callbacks.shift()(this);&#x2F;&#x2F;传入当前vm实例，使得flushUpdateQueue能获取到<br>      }<br>      pending&#x3D;false;<br>    }<br> }<br>测试<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>let data&#x3D;{<br>    message:’hello’,<br>    num:0<br>}<br>let app&#x3D;new Vue({<br>    data:data<br>});<br>&#x2F;&#x2F;模拟数据监听<br>let w1&#x3D;new Watcher(app,’message’,function(value){<br>    &#x2F;&#x2F;模拟dom变更<br>    console.log(‘message 引起的dom变更—&gt;’,value);<br>})<br>&#x2F;&#x2F;模拟数据监听<br>let w2&#x3D;new Watcher(app,’num’,function(value){<br>    &#x2F;&#x2F;模拟dom变更<br>    console.log(‘num 引起的dom变更—&gt;’,value);<br>})<br>data.message&#x3D;’world’&#x2F;&#x2F;数据一旦更新，会为nextTick的事件队列callbacks中加入一个flushUpdateQueue回调函数<br>data.message&#x3D;’world1’<br>data.message&#x3D;’world2’&#x2F;&#x2F;message的变更push到updateQueue中，只保存最后一次赋值的结果for(let i&#x3D;0;i&lt;&#x3D;100;i++){<br>   data.num&#x3D;i;&#x2F;&#x2F;num的变更push到updateQueue中，只保存最后一次赋值的结果<br>}<br>&#x2F;&#x2F;开发者为callbacks添加的异步回调事件<br>app.$nextTick(function(){<br>   console.log(‘这是dom更新完成后的操作’)<br>})<br>我们捋一下上述例子中代码的执行顺序，加深理解：</p><ol><li>执行同步代码</li><li>其中第一次修改数据data.message&#x3D;’world’会通过nextTick方法把flushUpdateQueuepush到callbacks队列，并把message属性对应的Watcher入updateQueue，后续data.message的更新只修改Watcher的值value，不再重复添加到updateQueue;</li><li>之后是num的首次更新，同样会尝试通过nextTick把flushUpdateQueuepush到callbacks队列，但是会发现这时的waiting是true,不再重复添加flushUpdateQueue,之后会把num属性对应的Watcher入updateQueue，后续的99次data.num的变更都不会再重复添加到updateQueue；</li><li>接下来我们主动执行vue对象的nextTick方法，添加了一个回调函数到callbacks队列中；</li><li>同步代码（宏任务）执行完毕，这时轮到nextTick中的异步任务执行了，这里分Promise.then和setTimeout两种情况说一下：<br>5.1 Promise.then<blockquote><p>在新建的微任务中执行flushCallbacks，依次执行flushUpdateQueue执行UI更新队列和开发者添加的回调函数，微任务执行完成后dom变更也完成了，紧接着是浏览器的视图渲染。<br>5.2 setTimeout<br>在新建的宏任务中执行flushCallbacks，因为两次宏任务期间会有一次浏览器的视图渲染，因此这里会先执行一次无效的视图渲染，之后依次执行callbacks中的flushUpdateQueueUI更新队列和开发者添加的回调函数，dom更新完成，紧接着是下一次的视图渲染。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Vue—响应式原理</title>
    <link href="https://superq314.github.io/posts/7794f292/"/>
    <id>https://superq314.github.io/posts/7794f292/</id>
    <published>2022-10-10T15:20:56.000Z</published>
    <updated>2022-10-10T15:27:51.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>响应式（reactive programming）<br>是一种面向数据流和变化传播的编程范式，这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p><p>数据劫持 + 依赖收集（监听数据变化）<br>深入响应式原理<br>Vue 最独特的特性之一  &#x3D;&#x3D;&gt;  非侵入性的响应式系统<br>数据驱动视图，修改数据则视图随之响应更新。</p><p>Vue 2.0的响应式原理是基于Object.defineProperty实现的<br>getter() 收集依赖<br>setter() 通知依赖更新<br>Vue 3.0的响应式原理是基于ES6的Proxy实现的</p><h2 id="Vue-2-0响应式原理"><a href="#Vue-2-0响应式原理" class="headerlink" title="Vue 2.0响应式原理"></a>Vue 2.0响应式原理</h2><p>1.defineProperty 的应用<br>在Vue2.X 响应式中使用到了 defineProperty 进行数据劫持，所以我们对它必须有一定的了解，那么我们先来了解它的使用方法把， 这里我们来使用 defineProperty来模拟 Vue 中的 data</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue的data</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 对 vm 的 msg 进行数据劫持</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 拦截get，当我们访问data.msg时会被这个方法拦截到</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> data.<span class="property">msg</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 拦截set，当我们为data.msg赋值时会被这个方法拦截到</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果传入的值相等就不用修改</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (newValue === data.<span class="property">msg</span>) <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 修改数据</span></span></span><br><span class="line"><span class="language-javascript">            data.<span class="property">msg</span> = newValue</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">msg</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.defineProperty修改多个参数为响应式<br>修改多个参数<br>看了上面的方法只能修改一个属性，实际上我们 data 中数据不可能只有一个,我们何不定义一个方法把data中的数据进行遍历都修改成响应式呢</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue的data</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;哈哈&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 把多个属性转化 响应式</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">proxyData</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 把data 中每一项都[msg,age] 拿出来操作</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 对 vm 的 属性 进行数据劫持</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 可枚举</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 可配置</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 获取数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> data[key]</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 设置 属性值</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 如果传入的值相等就不用修改</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (newValue === data[key]) <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 修改数据</span></span></span><br><span class="line"><span class="language-javascript">                    data[key] = newValue</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data[key]</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">proxyData</span>(data)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object.defineProperty的弊端<br>现象：当data新增了其他属性后，进行访问和设值时，都不会触发get和set<blockquote><p>Object.defineProperty只对初始对象里的属性有监听作用，对新增的属性无效<br>因此，在Vue2.0中对象新增属性的修改需要使用Vue.$set来设值。</p></blockquote></li></ol><h2 id="Vue-3-0-响应式原理"><a href="#Vue-3-0-响应式原理" class="headerlink" title="Vue 3.0 响应式原理"></a>Vue 3.0 响应式原理</h2><p>Proxy<br>3.x的与2.x的核心思想一致，只不过数据的劫持使用Proxy而不是Object.defineProperty，只不过Proxy相比Object.defineProperty在处理数组和新增属性的响应式处理上更加方便。<br>先来了解下 Proxy 的两个参数<br>new Proxy(target,handler)</p><ul><li>target ：要拦截的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li><li>handler：对象，用来定制拦截行为<br>注意：<br>this 关键字表示的是代理的 handler 对象，所以不能使用this而是要用 receiver传递，receiver代表当前proxy对象 或者 继承proxy的对象，它保证传递正确的 this 给 getter，setter<br>set 和 deleteProperty 也需要返回（添加return ），返回的是一个布尔值，设置&#x2F;删除成功返回true，反之返回false<br>那么就放上代码了<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue data</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 模拟 Vue 的一个实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Proxy 第一个</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 拦截get</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// target 表示需要代理的对象这里指的就是 data</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// key 就是对象的 键</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> target[key]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 拦截set</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// newValue 是设置的值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 也先判断下是否和之前的值一样 节省性能</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (target[key] === newValue) <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 进行设置值</span></span></span><br><span class="line"><span class="language-javascript">            target[key] = newValue</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = target[key]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>收集依赖&#x2F;触发更新<br>上面我们还有get中收集依赖没有完成，收集依赖涉及道track , effect 还有依赖地图，下面我给出一张图先介绍一下effect和track是如何收集依赖的</li></ul><p>响应式顺序：effect &gt; track &gt; trigger &gt; effect<br>在组件渲染过程中，一个 effect 会会触发get，从而对值进行 track，当值发生改变，就会进行 trigge，执行 effect 来完成一个响应<br>那么先来实现 effect<br>effect<br>effect的实现很简单<br>&#x2F;&#x2F; activeEffect 表示当前正在走的 effect<br>let activeEffect &#x3D; nullexport function effect(callback) {<br>    activeEffect &#x3D; callback<br>    callback()<br>    activeEffect &#x3D; null<br>}<br>track<br>然后就是对 track 的实现<br>&#x2F;&#x2F; targetMap 表里每个key都是一个普通对象 对应他们的 depsMap<br>let targetMap &#x3D; new WeakMap()<br>export function track(target, key) {<br>    &#x2F;&#x2F; 如果当前没有effect就不执行追踪<br>    if (!activeEffect) return<br>    &#x2F;&#x2F; 获取当前对象的依赖图<br>    let depsMap &#x3D; targetMap.get(target)<br>    &#x2F;&#x2F; 不存在就新建<br>    if (!depsMap) {<br>        targetMap.set(target, (depsMap &#x3D; new Map()))<br>    }<br>    &#x2F;&#x2F; 根据key 从 依赖图 里获取到到 effect 集合<br>    let dep &#x3D; depsMap.get(key)<br>    &#x2F;&#x2F; 不存在就新建<br>    if (!dep) {<br>        depsMap.set(key, (dep &#x3D; new Set()))<br>    }<br>    &#x2F;&#x2F; 如果当前effectc 不存在，才注册到 dep里<br>    if (!dep.has(activeEffect)) {<br>        dep.add(activeEffect)<br>    }<br>}</p><p>最后添加到hander 里 get 中<br>get(target, key, receiver) {<br>    &#x2F;&#x2F; …<br>    &#x2F;&#x2F; 收集依赖<br>    track(target, key)</p><pre><code>   // ...</code></pre><p>},<br>触发更新<br>通过上面的图，我们知道在set中使用trigger函数来触发更新，我们来实现一下吧<br>&#x2F;&#x2F; trigger 响应式触发<br>export function trigger(target, key) {<br>    &#x2F;&#x2F; 拿到 依赖图<br>    const depsMap &#x3D; targetMap.get(target)<br>    if (!depsMap) {<br>        &#x2F;&#x2F; 没有被追踪，直接 return<br>        return<br>    }<br>    &#x2F;&#x2F; 拿到了 视图渲染effect 就可以进行排队更新 effect 了<br>    const dep &#x3D; depsMap.get(key)</p><pre><code>// 遍历 dep 集合执行里面 effect 副作用方法if (dep) &#123;    dep.forEach(effect =&gt; &#123;        effect()    &#125;)&#125;</code></pre><p>}<br>最后添加到hander 的 set 和 deleteProperty 中<br>set(target, key, value, receiver) {<br>    &#x2F;&#x2F; …<br>    if (oldValue !&#x3D;&#x3D; value) {<br>        result &#x3D; Reflect.set(target, key, value, receiver)<br>        trigger(target, key)<br>    }<br>    &#x2F;&#x2F; …<br>},<br>deleteProperty(target, key) {<br>    &#x2F;&#x2F; …<br>    if (hadKey &amp;&amp; result) {<br>        &#x2F;&#x2F; 更新操作<br>        trigger(target, key)<br>    }<br>    &#x2F;&#x2F; …<br>}<br>ref<br>把一个基础类型包装成一个有value响应式对象（这里是使用get&#x2F;set 存取器，来进行追踪和触发），如果是普通对象就调用 reactive 来创建响应式对象<br>&#x2F;&#x2F; 判断是否是一个对象，是就用 reactive 来代理<br>const convert &#x3D; val &#x3D;&gt; (isObject(val) ? reactive(val) : val)<br>class RefImpl {<br>    constructor(_rawValue) {<br>        this._rawValue &#x3D; _rawValue<br>        this.__v_isRef &#x3D; true<br>        &#x2F;&#x2F; 判断 _rawValue 是否是一个对象<br>        &#x2F;&#x2F; 如果是对象调用reactive使用 proxy来代理<br>        &#x2F;&#x2F; 不是返回 _rawValue 本身<br>        this._value &#x3D; convert(_rawValue)<br>    }<br>    &#x2F;&#x2F; 使用get&#x2F;set 存取器，来进行追踪和触发<br>    get value() {<br>        &#x2F;&#x2F; 追踪依赖<br>        track(this, ‘value’)<br>        &#x2F;&#x2F; 当然 get 得返回 this._value<br>        return this._value<br>    }<br>    set value(newValue) {<br>        &#x2F;&#x2F; 判断旧值和新值是否一直<br>        if (newValue !&#x3D;&#x3D; this._value) {<br>            this._rawValue &#x3D; newValue<br>            &#x2F;&#x2F; 设置新值的时候也得使用 convert 处理一下，判断新值是否是对象<br>            this._value &#x3D; convert(this._rawValue)<br>            &#x2F;&#x2F; 触发依赖<br>            trigger(this, ‘value’)<br>        }<br>    }<br>}<br>export function ref(rawValue) {<br>    &#x2F;&#x2F; __v_isRef 用来标识是否是 一个 ref 如果是直接返回，不用再转<br>    if (isObject(rawValue) &amp;&amp; rawValue.__v_isRef) return rawValue</p><pre><code>return new RefImpl(rawValue)</code></pre><p>}<br>toRef<br>toRef传入两个参数，目标对象，对象当中的属性名，它的返回结果就是属性名的可响应式数据，就是将对象中的某个值转化为响应式数据 toRef(obj,key)<br>那么简单来实现一下<br>class ObjectRefImpl {<br>    constructor(proxy, _key) {<br>        this._proxy &#x3D; proxy<br>        this._key &#x3D; _key<br>        &#x2F;&#x2F; __v_isRef 用来标识是否是 一个 ref<br>        this.__v_isRef &#x3D; true<br>    }<br>    get value() {<br>        &#x2F;&#x2F; 这里不用收集依赖<br>        &#x2F;&#x2F; this._proxy 就是响应式对象，当访问[this._key]时，this._proxy里面会去自动收集依赖<br>        return this._proxy[this._key]<br>    }<br>    set value(newVal) {<br>        &#x2F;&#x2F; 这里不用收集依赖<br>        &#x2F;&#x2F; this._proxy 响应式对象，会在this._proxy里面set去调用trigger<br>        this._proxy[this._key] &#x3D; newVal<br>    }<br>}<br>&#x2F;&#x2F; 暴露出去的方法<br>export function toRef(proxy, key) {<br>    return new ObjectRefImpl(proxy, key)<br>}</p><p>测试<br>import { ref, effect, toRef, reactive } from ‘..&#x2F;src&#x2F;reactive.js’<br>const obj &#x3D; reactive({<br>    name: ‘小浪’,<br>})<br>const age &#x3D; toRef(obj, ‘age’)<br>age.value &#x3D; 21console.log(obj)<br>effect(() &#x3D;&gt; {<br>    age.value &#x3D; 22<br>})<br>console.log(obj)<br>原来的obj对象没有 age 属性，使用 toRef 添加了 age， 并且是响应式的</p><p>区别于ref:<br>ref是对原始数据的拷贝，当修改ref数据时，模板中的视图会发生改变，但是原始数据并不会改变。 toRef是对原始数据的引用，修改toRef数据时，原始数据也会发生改变，但是视图并不会更新。<br>toRefs<br>想必这个大家经常使用吧，平时如果使用reactive创建对象，我们不能直接进行解构，我们要使用 toRefs 帮助我们进行解构， 把整个 reactive 创建的对象变成 普通对象， 然后把每个属性变成 ref 响应式对象。那么直接上手写一下吧， 其实它的核心还是使用了 toRef<br>export function toRefs(proxy) {<br>    &#x2F;&#x2F; 判断 当前 proxy 是 proxy 数组， 还是 proxy 对象<br>    const ret &#x3D; proxy instanceof Array ? new Array(proxy.length) : {}</p><pre><code>for (const key in proxy) &#123;    // 内部还是调用 toRef 进行转为 响应式    ret[key] = toRef(proxy, key)&#125;return ret</code></pre><p>}</p><p>测试<br>import { reactive, toRefs } from ‘..&#x2F;src&#x2F;reactive.js’<br>const obj &#x3D; reactive({<br>    name: ‘小浪’,<br>    age: 22,<br>})<br>const { name, age } &#x3D; toRefs(obj)<br>console.log(obj)<br>name.value &#x3D; ‘小云’<br>age.value &#x3D; 21console.log(obj)<br>测试成功，toRefs解构后的属性也是响应式</p><p>检测变化的注意事项<br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此还是有一些办法来回避这些限制并保证它们的响应性。<br>对于对象<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter&#x2F;setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：<br>var vm &#x3D; new Vue({<br>  data:{<br>    a:1<br>  }<br>})</p><p>&#x2F;&#x2F; <code>vm.a</code> 是响应式的</p><p>vm.b &#x3D; 2<br>&#x2F;&#x2F; <code>vm.b</code> 是非响应式的<br>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于：<br>Vue.set(vm.someObject, ‘b’, 2)<br>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：<br>this.$set(this.someObject,’b’,2)<br>有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。<br>&#x2F;&#x2F; 代替 <code>Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)</code><br>this.someObject &#x3D; Object.assign({}, this.someObject, { a: 1, b: 2 })<br>对于数组<br>Vue 不能检测以下数组的变动：</p><ol><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] &#x3D; newValue</li><li>当你修改数组的长度时，例如：vm.items.length &#x3D; newLength<br>举个例子：<br>var vm &#x3D; new Vue({<br>  data: {<br> items: [‘a’, ‘b’, ‘c’]<br>  }<br>})<br>vm.items[1] &#x3D; ‘x’ &#x2F;&#x2F; 不是响应性的<br>vm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的<br>为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] &#x3D; newValue 相同的效果，同时也将在响应式系统内触发状态更新：<br>&#x2F;&#x2F; Vue.set<br>Vue.set(vm.items, indexOfItem, newValue)<br>&#x2F;&#x2F; Array.prototype.splice<br>vm.items.splice(indexOfItem, 1, newValue)<br>你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：<br>vm.$set(vm.items, indexOfItem, newValue)<br>为了解决第二类问题，你可以使用 splice：<br>vm.items.splice(newLength)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Vue—computed以及watch源码分析</title>
    <link href="https://superq314.github.io/posts/1accd257/"/>
    <id>https://superq314.github.io/posts/1accd257/</id>
    <published>2022-10-10T15:20:36.000Z</published>
    <updated>2022-10-10T15:24:17.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 3.0</p><p>Object.defneProperty &#x3D;&gt; Proxy</p><p>composition API</p><p><a href="https://composition-api.vuejs.org/">https://composition-api.vuejs.org</a></p><p>Vue 3.0 Reactivity APIs</p><ul><li>reactive</li><li>ref</li><li>readonly</li><li>computed</li><li>watchEffect</li><li>watch</li></ul><p>Vue 2.0</p><p>computed</p><ul><li>会基于其内部的<strong>响应式依赖</strong>进行缓存</li><li>只在相关<strong>响应式依赖发生改变</strong>时他们才会重新求值</li><li>可以将模板中使用的常量放在计算属性中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Vue—双向数据绑定</title>
    <link href="https://superq314.github.io/posts/a06ab7e6/"/>
    <id>https://superq314.github.io/posts/a06ab7e6/</id>
    <published>2022-10-10T15:18:14.000Z</published>
    <updated>2022-10-10T15:23:51.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>双向数据绑定<br>双向数据绑定通常是指我们使用的v-model指令的实现，是Vue的一个特性，也可以说是一个input事件和value的语法糖。 Vue通过v-model指令为组件添加上input事件处理和value属性的赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;localValue&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的组件就相当于如下代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!-- 这里添加了input时间的监听和value的属性绑定 --&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">input</span> @<span class="attr">input</span>=<span class="string">&#x27;onInput&#x27;</span> <span class="attr">:value</span>=<span class="string">&#x27;localValue&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">localValue</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">localValue</span>:<span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">onInput</span>(<span class="params">v</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="comment">//在input事件的处理函数中更新value的绑定值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">this</span>.<span class="property">localValue</span>=v.<span class="property">target</span>.<span class="property">value</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">localValue</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>v-model实践<br>首先我们定义一个Vue组件，相信大家已经很熟悉了。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tempalte</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addCount&quot;</span>&gt;</span>click me </span><span class="template-variable">&#123;&#123;<span class="name">value</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">props</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//关键的第一步：设置一个value属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">value</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">type</span>:<span class="title class_">Number</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">default</span>:<span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">watch</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//监听value变化，更新组件localvalue状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">value</span>(<span class="params">v</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">localvalue</span>=v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//关键的第二步：事件触发localvalue变更，通过事件同步父组件状态变更</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">addCount</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">this</span>.<span class="property">localvalue</span>++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>,<span class="variable language_">this</span>.<span class="property">localvalue</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//组件状态，遵守单项数据流原则，不直接修改props中的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">localvalue</span>:<span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//初始化获取value值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">localvalue</span>=<span class="variable language_">this</span>.<span class="property">value</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的组件定了我们通过在props中添加value属性，并且在值更新时触发input事件。created钩子和watch中为localvalue赋值是为了同步父组件状态到子组件中。<br>通过上面v-model指令做双向数据绑定了。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">add-one</span> <span class="attr">v-model</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">add-one</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>父组件</span><span class="template-variable">&#123;&#123;<span class="name">count</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="attr">count</span>: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">created</span>(<span class="params"></span>)&#123;   </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>下面是实际效果当然我们也可以不使用value和input事件这样的组合，为了更使得组件的定义更加符合语义，我们也可以自定义要实现双向绑定的属性和事件。 我们在组件的model选项中设置value和event即可。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">      <span class="comment">//这里做了一个value和event的映射</span></span><br><span class="line">      <span class="attr">model</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">        <span class="attr">event</span>:<span class="string">&#x27;change&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">props</span>:&#123;</span><br><span class="line">       <span class="comment">//关键的第一步：设置一个value属性</span></span><br><span class="line">        <span class="attr">count</span>:&#123;</span><br><span class="line">          <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">          <span class="attr">default</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="comment">//关键的第二步：事件触发localvalue变更，通过事件同步父组件状态变更</span></span><br><span class="line">        <span class="title function_">addCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">localvalue</span>++;</span><br><span class="line">           <span class="variable language_">this</span>.$emit(<span class="string">&#x27;change&#x27;</span>,<span class="variable language_">this</span>.<span class="property">localvalue</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的组件定义<br><code>&lt;add-one v-model=&quot;count&quot;&gt;&lt;/add-one&gt;</code><br>就相当于</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">add-one</span> @<span class="attr">change</span>=<span class="string">&#x27;onChange&#x27;</span> <span class="attr">:count</span>=<span class="string">&#x27;count&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">add-one</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">count</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">count</span>:<span class="number">0</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">onChange</span>(<span class="params">v</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">this</span>.<span class="property">count</span>=v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>只不过v-model指令帮我们做上面的事件添加，属性绑定和状态同步操作罢了。<br>这里埋下一个小伏笔，不知道同学们熟不熟悉Vue的自定义指令，不熟悉的同学可以在评论区留言，下篇提前把使用自定义指令的各种技巧为各位同学奉上，附带v-model的具体实现。<br>加更：自定义指令的各种技巧和v-model的实现已完成，感兴趣的同学可以看一下理论+实践，彻底掌握Vue自定义指令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://superq314.github.io/posts/1690d21b/"/>
    <id>https://superq314.github.io/posts/1690d21b/</id>
    <published>2022-10-09T14:53:54.000Z</published>
    <updated>2022-10-09T15:26:53.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、命令式编程  &#x3D;&gt;  2、面向对象编程  &#x3D;&gt;  3、函数式编程<br>考虑一个小功能：将数组最后一个元素大写，假设 log, head，reverse，toUpperCase 函数存在（我们通过 curry 可以很容易写出来）</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">命令式写法</button></li><li class="tab"><button type="button" data-href="#super-2">面向对象写法</button></li><li class="tab"><button type="button" data-href="#super-3">函数式组合——compose</button></li><li class="tab"><button type="button" data-href="#super-4">函数式组合——pipe</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><code>log(toUpperCase(head(reverse(arr))))</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">reverse</span>()</span><br><span class="line">  .<span class="title function_">head</span>()</span><br><span class="line">  .<span class="title function_">toUpperCase</span>()</span><br><span class="line">  .<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure><p>链式调用看起来顺眼多了，然而问题在于，原型链上可供我们链式调用的函数是有限的，而需求是无限的 ，这限制了我们的逻辑表现力。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p><code>const upperLastItem = compose(log, toUpperCase, head, reverse);</code><br>通过参数我们可以很清晰的看出发生了 uppderLastItem 做了什么，它完成了一套流水线，所有经过这条流水线的参数都会经历：reverse -&gt; head -&gt; toUpperCase-&gt; log 这些函数的加工，最后生成结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>很多函数库（Lodash，Ramda）中也提供了另一种组合方式：pipe（从左往右的组合）<br><code>const upperLastItem = R.pipe(reverse, head, toUppderCase, log);</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>对于箭头函数在函数式编程里面有一个高大上的名字，叫 lambda 表达式，对于这种匿名函数在学术上就是叫 lambda 表达式。</p><p>函数式编程</p><p>思维：着眼点是 <strong>函数</strong> ，而不是 <strong>过程</strong> ，强调的是如何通过函数的组合变换去解决问题，而不是通过写什么样的语句去解决问题。</p><p>函数式编程的目的</p><p>使用函数来 <strong>抽象作用在数据之上的控制流和操作</strong> ，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong></p><p>函数式编程的特点</p><ol><li>函数是“一等公民”</li></ol><blockquote><p>这是函数式编程得以实现的 <strong>前提</strong> ，因为我们基本的操作都是在操作函数。这个特性意味着函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></blockquote><p>例如：<code>const convert2Obj = compose(genObj(&#39;name&#39;), capitalizeName)</code></p><ol start="2"><li>声明式编程</li></ol><blockquote><p>函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为 <a href="https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B%EF%BC%9Foldformat=true">声明式编程</a> 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。</p></blockquote><p>React 是声明式的，只要描述你的 UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠你自己去渲染和优化 diff 算法。</p><ol start="3"><li>惰性执行</li></ol><blockquote><p>所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 <strong>convertName</strong> 产生实际的结果。</p></blockquote><ol start="4"><li>无状态和数据不可变</li></ol><p>这是函数式编程的核心概念：</p><p>· <strong>数据不可变：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</p><p>· <strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</p><p>为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。<br><img src="/image/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1665327567706.png" alt="1665327567706"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">没有副作用（No Side Effects）</button></li><li class="tab"><button type="button" data-href="#super-2">纯函数 (pure functions)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>副作用这个词我们可算听的不少，它的含义是：在完成函数主要功能之外完成的其他副要功能。在我们函数中最主要的功能当然是根据输入 <strong>返回结果</strong> ，而在函数中我们最常见的副作用就是 <strong>随意操纵外部变量</strong> 。由于 JS 中对象传递的是引用地址，哪怕我们用 <strong>const</strong> 关键词声明对象，它依旧是可以变的。而正是这个“漏洞”让我们有机会随意修改对象。</p><p>例如： <strong>map</strong> 函数的本来功能是将输入的数组根据一个函数转换，生成一个新的数组：</p><p><strong>map :: [a] -&gt; [b]</strong></p><p>而在 JS 中，我们经常可以看到下面这种对 <strong>map</strong> 的 “错误” 用法，把 <strong>map</strong> 当作一个循环语句，然后去直接修改数组中的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line">list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">type</span> = <span class="number">1</span>;</span><br><span class="line">    item.<span class="property">age</span>++;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样函数最主要的输出功能没有了，变成了直接修改了外部变量，这就是它的副作用。而没有副作用的写法应该是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line"><span class="keyword">const</span> newList = list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;...item, <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">age</span>:item.<span class="property">age</span> + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure><p>保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug。</p><p>传递引用一时爽，代码重构火葬场</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>纯函数算是在“没有副作用” 的要求上再进一步了。</p><p>其实纯函数的概念很简单就是两点：</p><ol><li>不依赖外部状态（无状态）：** 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。</li><li>没有副作用（数据不变）：** 不修改全局变量，不修改入参。</li></ol><p>所以纯函数才是真正意义上的“函数”， 它意味着 <strong>相同的输入，永远会得到相同的输出</strong> 。</p><p>以下几个函数都是不纯的，因为他们都依赖外部变量，试想一下，如果有人调用了 <strong>changeName</strong> 对 <strong>curUser</strong> 进行了修改，然后你在另外的地方调用了 <strong>saySth</strong> ，这样就会产生你预料之外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = str =&gt; curUser.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 引用了全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">obj, name</span>) =&gt; obj.<span class="property">name</span> = name;  <span class="comment">// 修改了输入参数</span></span><br><span class="line"><span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(<span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Jay: hello!</span></span><br></pre></td></tr></table></figure><p>如果改成纯函数的写法会是怎么样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = (<span class="params">user, str</span>) =&gt; user.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 不依赖外部变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">user, name</span>) =&gt; (&#123;...user, name &#125;);  <span class="comment">// 未修改外部变量 </span></span><br><span class="line"><span class="keyword">const</span> newUser = <span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(curUser, <span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Peter: hello!</span></span><br></pre></td></tr></table></figure><p>这样就没有之前说的那些问题了。</p><p>我们这么强调使用纯函数，纯函数的意义是什么？</p><ol><li>便于测试和优化：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。这十分符合<strong>测试驱动开发</strong> TDD****的思想，这样产生的代码往往健壮性更强。</li><li>可缓存性：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果，有很多库有所谓的 <strong>memoize</strong> 函数，下面以一个简化版的 <strong>memoize</strong> 为例，这个函数就能缓存函数的结果，对于像 <strong>fibonacci</strong> 这种计算，就可以起到很好的缓存效果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> value = cache[key];</span><br><span class="line">        <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">            value = [fn.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>)];  <span class="comment">// 放在一个数组中，方便应对 undefined，null 等异常情况</span></span><br><span class="line">            cache[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fibonacci = <span class="title function_">memoize</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">2</span> ? <span class="attr">n</span>: <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">4</span>))  <span class="comment">// 执行后缓存了 fibonacci(2), fibonacci(3),  fibonacci(4)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)) <span class="comment">// fibonacci(2), fibonacci(3),  fibonacci(4) 的结果直接从缓存中取出，同时缓存其他的</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自文档化：由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解（配合后面介绍的 [类型签名](#hindly-milner 类型签名）更佳)。</li><li>更少的Bug：使用纯函数意味着你的函数中 不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中$含义及用法</title>
    <link href="https://superq314.github.io/posts/51b050d3/"/>
    <id>https://superq314.github.io/posts/51b050d3/</id>
    <published>2022-10-06T13:58:55.000Z</published>
    <updated>2022-10-06T14:08:37.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$在JS中本身只是一个符号而异，在JS里什么也不是。但在JS的应用库jQuery中，将之做为一个自定义函数名了，这个函数是获取指定网页元素的函数。</p><p>在不用JQUERY的情况，一般会自定义一个$函数。即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">Nid</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="title class_">Nid</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后不用每次使用document.getElementById(“ID名”)来获取元素，只用$(‘ID名’)即可。</p><p>三种具体用法：</p><ol><li>$()可以是$(expresion)</li></ol><blockquote><p>即css选择器、Xpath或html元素，也就是通过上述表达式来匹配目标元素。<br>比如：$(“a”)构造的这个对象，是用CSS选择器构建了一个jQuery对象——它选择了所有的<code>&lt;a/&gt;</code>这个标签。</p></blockquote><p>如：<code>$(&quot;a&quot;).click(function()&#123;...&#125;)</code><br>就是在点击页面上的任何一个链接时的触发事件。确切地说，就是jQuery用<a/>这个标签构建了一个对象$(“a”)，函数 click()是这个jQuery对象的一个（事件）方法。<br>比如有这样一段HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>one<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>three<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">onClick</span>=<span class="string">&quot;jq()&quot;</span> &gt;</span>jQuery<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而操作这段HTML的是如下一条语句：<br><code>alert($(&quot;div&gt;p&quot;).html());</code></p><p>$()中的是一个查询表达式，也就是用“div&gt;p”这样一个查询表达式构建了一个jQuery对象，然后的“html()”意思是显示其html内容，也就是上面HTML代码段的[two]。<br>再如： $(“<code>&lt;div&gt;&lt;p&gt;</code>Hello<code>&lt;/p&gt;&lt;/div&gt;</code>“).appendTo(“body”);<br>$()中的是一个字符串，用这样一段字串构建了jQuery对象，然后向<body/>中添加这一字串。  </p><ol start="2"><li>$()可以是$(element)<blockquote><p>即一个特定的DOM元素。如常用的DOM对象有document、location、form等。<br>如这样一行代码： <code>$(document).find(&quot;div&gt;p&quot;).html());</code></p></blockquote></li></ol><p>$()中的document是一个DOM元素，即在全文寻找带<code>&lt;p&gt;</code>的<code>&lt;div&gt;</code>元素，并显示<code>&lt;p&gt;</code>中的内容。 </p><ol start="3"><li>$()可以是$(function)<blockquote><p>即一个函数，它是$(document).ready()的一个速记方式。如常见的形式是这样的：<br><code>$(document).ready(function()&#123; alert(&quot;Hello world!&quot;); &#125;);</code></p></blockquote></li></ol><p>可变形作：<br><code>$(function()&#123; alert(&quot;Hello world!&quot;); &#125;);</code></p><p>对于选择HTML文档中的elements，jQuery有两种方法：<br>1）如$(“div&gt;ul a”)，它的意思是div标签中的ul标签中的a标签<br>2）用jQuery对象的几个方法（如方法find()、each()等） $(“#orderedlist).find(“li”) 就像 $(“#orderedlist li”). each()一样迭代了所有的li，而表达式中的“#”表示HTML中的ID，如上例中的“#orderedlist”就表示“ID为orderedlist所在的标签”。  **************************************************************** </p><p>2、XPath选择器 如：选择所有带有title 属性的链接，我们会这样写：$(‘a[@title]’)<br>[]里带@，说明[]里的是元素的属性；是个属性选择器<br>[]里没@，说明[]里的是元素的子孙。<br>在XPath中，要找一个“以…开头”的属性，用^&#x3D;，如找一个name属性是以mail开头的input元素，就用<br>$(‘input[@name^&#x3D;”mail”]’)<br>要找一个“以…结尾”的属性，要用$&#x3D; 要找一个“不头不尾”的属性，用*&#x3D;  </p><p>3、不属于上述的CSS和XPath的选择器，就是自定义的选择器了，用“:”表示，这里要用的就是:first，:last，:parent ，:hidden，:visible，:odd，:even，:not(‘xxx’)， “:eq(0)”（始于0)，:nth(n），:gt(0)，:lt(0)，:contains(“xxx”) 如：$(‘tr:not([th]):even’)意为<tr>元素的子孙中不含<th>的所有子孙的偶数项 </p><p>5、要直接访问DOM元素，可用get(0)的方法，如<br>$(‘#myelement’).get(0)<br>也可缩写成<br>$(‘#myelement’)[0]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lodash高阶函数</title>
    <link href="https://superq314.github.io/posts/c123e559/"/>
    <id>https://superq314.github.io/posts/c123e559/</id>
    <published>2022-10-06T13:38:01.000Z</published>
    <updated>2022-10-06T14:08:37.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="lodash-高阶函数"><a href="#lodash-高阶函数" class="headerlink" title="lodash 高阶函数"></a>lodash 高阶函数</h2><p>lodash 大家肯定不陌生，它是最流行的 JavaScript 库之一，透过函数式编程模式为开发者提供常用的函数。</p><p>其中有一些封装的高阶函数，让一些平平无奇的普通函数也能有相应的高阶功能。</p><p>举几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖动</span></span><br><span class="line">_.<span class="title function_">debounce</span>(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line">_.<span class="title function_">throttle</span>(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个断言函数结果取反</span></span><br><span class="line">_.<span class="title function_">negate</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line">_.<span class="title function_">curry</span>(func, [arity=func.<span class="property">length</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分应用</span></span><br><span class="line">_.<span class="title function_">partial</span>(func, [partials])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个带记忆的函数</span></span><br><span class="line">_.<span class="title function_">memoize</span>(func, [resolver])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装函数</span></span><br><span class="line">_.<span class="title function_">wrap</span>(value, [wrapper=identity])</span><br></pre></td></tr></table></figure><p>研究源码你就会发现，_.debounce 防抖、_.throttle 节流上面说过，_.curry 柯里化上面说过、_.partial 在“缓存传参”里说过、_.memoize 在“缓存计算”里也说过……</p><p>再举一个例子：</p><p>现在要求一个函数在达到 n 次之前，每次都正常执行，第 n 次不执行。</p><p>也是非常常见的业务场景！JavaScript 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">before</span>(<span class="params">n, func</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result,</span><br><span class="line">    count = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            func = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn= <span class="title function_">before</span>(<span class="number">3</span>,<span class="function">(<span class="params">x</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(x))</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">3</span>) <span class="comment">// 不执行</span></span><br></pre></td></tr></table></figure><p>反过来：函数只有到 n 次的时候才执行，n 之前的都不执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">after</span>(<span class="params">n, func</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = n || <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn= <span class="title function_">after</span>(<span class="number">3</span>,<span class="function">(<span class="params">x</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(x))</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>) <span class="comment">// 不执行</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>) <span class="comment">// 不执行</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>全是“闭包”、全是把参数“柯里化”。</p><p>细细体会，在控制台上敲一敲、改一改、跑一跑，下次或许你就可以自己写出这些有特定功能的高阶函数了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一道前端JS面试题</title>
    <link href="https://superq314.github.io/posts/481a45e8/"/>
    <id>https://superq314.github.io/posts/481a45e8/</id>
    <published>2022-10-06T12:10:26.000Z</published>
    <updated>2022-10-06T14:08:37.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">3</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; alert (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>();              <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>();                  <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();            <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>();                  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>();          <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();        <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p><p>此题包含7小问，分别说下。</p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>代码部分，</p><p>首先定义了一个叫Foo的函数，<br>之后为Foo创建了一个叫getName的<strong>静态属性</strong>存储了一个匿名函数，<br>之后为Foo的<strong>原型对象</strong>新创建了一个叫getName的匿名函数。<br>之后又通过<strong>函数变量表达式</strong>创建了一个getName的函数，<br>最后再<strong>声明</strong>一个叫getName函数。</p><p>第一问的 Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2。</p><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>第二问，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以跟1 2 3都没什么关系。</p><p>此处有两个坑，一是变量声明提升，二是函数表达式。</p><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>即所有声明变量或声明函数都会被提升到当前函数的顶部。</p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p> var getName 与 function getName 都是声明语句，区别在于 vargetName 是 <strong>函数表达式</strong> ，而 function getName 是 <strong>函数声明</strong> 。关于JS中的各种函数创建方式可以看 <a href="http://www.cnblogs.com/xxcanghai/p/4991870.html">大部分人都会做错的经典<strong>JS</strong>闭包面试题</a> 这篇文章有详细说明。</p><p>函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。</p><p>原题中代码最终执行时的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        alert (<span class="number">1</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName;<span class="comment">//只提升变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提升函数声明，覆盖var的声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    alert (<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line">getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">4</span>);&#125;;<span class="comment">//最终的赋值再次覆盖function getName声明</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//最终输出4</span></span><br></pre></td></tr></table></figure><h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><p>第三问的 Foo().getName(); 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。</p><p>Foo函数的第一句  getName &#x3D; function () { alert (1); };  是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。</p><p><strong>此处实际上是将外层作用域内的</strong>getName<strong>函数修改了。</strong></p><p>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。</p><p>之后Foo函数的返回值是this。</p><p><strong>简单</strong>的讲， <strong>this的指向是由所在函数的调用方式决定的</strong> 。而此处的直接调用方式，this指向window对象。</p><p>遂Foo函数返回的是window对象，相当于执行 window.getName() ，而window中的getName已经被修改为alert(1)，所以最终会输出1</p><p>此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。</p><h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><p>直接调用getName函数，相当于 window.getName() ，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1</p><h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><p>第五问 new Foo.getName(); ,此处考察的是js的运算符优先级问题。</p><p><strong>js运算符优先级:</strong></p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps1.jpg"></p><p>通过查上表可以得知点（.）的优先级高于new操作，遂相当于是:</p><p>new (Foo.getName)();</p><p>所以实际上将getName函数作为了构造函数来执行，遂弹出2。</p><h2 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h2><p>第六问 new Foo().getName() ，首先看运算符优先级括号高于new，实际执行为</p><p>(new Foo()).getName()</p><p>遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的构造函数返回值问题。</p><h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。</p><p>而在js中构造函数可以有返回值也可以没有。</p><p>1、没有返回值则按照其他语言一样返回实例化对象。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps2.jpg"></p><p>2、若有返回值则检查其返回值是否为 <strong>引用类型</strong> 。如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps3.jpg"></p><p>3、若返回值是引用类型，则实际返回值为这个引用类型。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps4.jpg"></p><p>原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p><p>之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。</p><p>遂最终输出3。</p><h2 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h2><p>第七问, new new Foo().getName(); 同样是运算符优先级问题。</p><p>最终实际执行为：</p><p>new ((new Foo()).getName)();</p><p>先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。</p><p>遂最终结果为3</p><p>这里确实是(new Foo()).getName()，但是跟括号优先级高于成员访问没关系，实际上这里成员访问的优先级是最高的，因此先执行了 .getName，但是在进行左侧取值的时候， new Foo() 可以理解为两种运算：new 带参数（即 new Foo()）和函数调用（即 先 Foo() 取值之后再 new），而 new 带参数的优先级是高于函数调用的，因此先执行了 new Foo()，或得 Foo 类的实例对象，再进行了成员访问 .getName。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网页设计</title>
    <link href="https://superq314.github.io/posts/81984e4e/"/>
    <id>https://superq314.github.io/posts/81984e4e/</id>
    <published>2022-10-06T12:02:07.000Z</published>
    <updated>2022-10-06T14:08:37.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>合格的网页应该包含</p><p>页面分为页头、菜单导航栏（可下拉）、中间内容板块、页脚四大部分；</p><p>所有页面相互超链接，可到三级页面，有5-10个页面组成；</p><p>页面样式风格统一布局显示正常，不错乱，使用div+css技术；</p><p>菜单美观、醒目，二级菜单可正常弹出与跳转；</p><p>要有JS特效，如定时切换和手动切换图片新闻；</p><p>页面中有多媒体元素，如gif、视频、音乐，表单技术的使用；</p><p>这个网页是模仿淘宝、京东等购物商场的布局，加上在本学期所学的内容，制作了七个关于“零食巴士”主题的页面，并将其定义为一个零食销售的购物网站。</p><p>index.html 是网站的首页，内置的链接有buycar.html、regist.html、login.html、product.html、personcenter.html 几乎能访问到所有的链接网页。</p><p>网页中head与footer可以通用到其他页面，节省了其他页面的编写时间。</p><p>product.html 是商品的详细页，中间为商品的详细信息介绍。</p><p>buycar.html 是购物车的界面，中间绘制了一张表格完成了购物商城的购物车。</p><p>login.html 是登录页面。</p><p>regist.html 是注册页面。</p><p>personcenter.html 是个人中心页面，中间为购买商品的一些情况。</p><p>information.html 是个人信息页面，中间为用户的个人信息。</p><p>food.html 美食的列表，第二个模板块。</p><p>Newidea.html 创意构想，第三个模板块</p><p>主要技术实现：</p><p>网页采用了纯html+css+jquery，在完成网页的过程中，顺便补充了jquery方面的知识，方便自己编写动画特效，发现相对于js，jquery封装之后的使用的确方便了许多，许多方面本来应该十分繁复的地方，jquery封装之后再进行使用就变得十分的轻便，而且解释起来也十分的方便。</p><p>整体的HTML，采用了网页互通，串成了一个整体。</p><p>CSS样式用的最多的是文字以及布局的一些设置，常常因为一个样式的大小位置调来调去。</p><p>视频演示：web前端大作业 零食商城设计【附完整源码和报告】.MP4</p><p>功能截图：</p><p>1.首页 （ index.html ）</p><p>本页面用了做了页头，中间，和页尾部分。其中包括了类似叮叮书店的js图片轮播技术，使用js技术将定位响应连接了起来，做成了类似多级菜单的效果，还有返回顶部并隐藏top键的js特效，根据老师的建议，不应该直接滑动到顶部而应该缓慢有个过程。</p><p>具体js实现：</p><p>在右边是详细介绍，分为了三个板块：商品属性、商品详情、商品评论。通过定义id以及a href 点击即可到达对应区域。</p><p>#商品详情 添加了网页截图所得到的的图片</p><p>#用户评论</p><p>运用了meter展示所占百分比，通过构建一张类似购物车的table，完成客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS雪碧图</title>
    <link href="https://superq314.github.io/posts/48ac2f57/"/>
    <id>https://superq314.github.io/posts/48ac2f57/</id>
    <published>2022-10-06T11:59:54.000Z</published>
    <updated>2022-10-09T14:38:41.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSS雪碧"><a href="#CSS雪碧" class="headerlink" title="CSS雪碧"></a>CSS雪碧</h2><p>即 <code>CSS Sprite</code>，也叫 <code>CSS</code>精灵，是一种 <code>CSS</code>图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用 <code>CSS</code>的背景定位来显示需要显示的图片部分。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>CSS </code>雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的 <code>HTTP </code>请求数量。该图片使用 <code>CSS </code>的 <code>background </code>和 <code>background-position </code>属性渲染，这也就意味着你的标签变得更加复杂了，图片是在 <code>CSS </code>中定义，而非 <code>img</code>标签。</p><ol><li>前期准备下载工具：css sprit（css精灵）<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064328704.png" alt="1665064328704"><br>百度云链接：<code>http://pan.baidu.com/s/1nuOZDqT</code></li><li>使用方法<br>下载，打开之后。</li><li>首先要切一些图片，不会切的话，移步：《前端ps切图方法，图文详细》</li><li>打开雪碧图，选择图片。<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064341241.png" alt="1665064341241"></li><li>添加完图片之后，会自动生成代码，需要排列一下图片：<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064387332.png" alt="1665064387332"><br>注意：排列图片的时候要注意各个图片之间留点空隙，不然使用的时候，会相互覆盖。</li><li>保存图片以及雪碧图css代码<br>保存雪碧图<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064443713.png" alt="1665064443713"><br>生成的雪碧图：<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064447657.png" alt="1665064447657"><br>保存雪碧图-css代码（因为软件没有到导出css代码的功能，所以要自己新建一个txt文件，放在雪碧图旁边，以后打开txt就知道图片在雪碧图的位置。）<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064455368.png" alt="1665064455368"></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>减少加载网页图片时对服务器的请求次数<blockquote><p>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</p></blockquote></li><li>提高页面的加载速度<blockquote><p>sprite 技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF 图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF 只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</p></blockquote></li><li>减少鼠标滑过的一些bug<blockquote><p>IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。</p></blockquote></li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>CSS雪碧的最大问题是内存使用<blockquote><p>除非这个雪碧图片是被非常小心的组织，你就会最终使用大量的无用的空白。</p></blockquote></li><li>影响浏览器的缩放功能<blockquote><p>如果一个使用CSS雪碧的页面使用一些浏览器提供的整页缩放功能缩放了，浏览器就需要做一些额外的工作来纠正这些图片边缘的行为——基本上来说，是为了避免雪碧中相邻的图片被“露进来”。这对于小图片没有什么问题，但是对于大图片会是一个性能下降。</p></blockquote></li><li>拼图维护比较麻烦<blockquote><p>拼合这么多图片，需要耐心。同时还要时刻思考如何在使用这个图片是不会产生相互的影响。将又瘦又高的图片和又宽又矮的图片放到一起时，不容易操作。如果要修改雪碧中的一个图片，你就要修改整张图片，这无疑会增大工作量。</p></blockquote></li><li>使CSS的编写变得困难<blockquote><p>如果CSS雪碧足够复杂，则大大增加了CSS的代码量和难度，让维护和修改变得困难起来。</p></blockquote></li><li>CSS 雪碧调用的图片不能被打印<blockquote><p>CSS 雪碧调用的图片不能被打印，除非在@media中特别添加 print声明。</p></blockquote></li><li>错误得使用 Sprites 影响可访问性<blockquote><p>一些刚入门的开发人员会为了节省 HTTP 请求数(这是使用 CSS Sprite 一直强调的好处)而把所有的图片都当背景图片来处理 – 甚至是那些传达重要信息的图片。结果会导致一个缺乏可访问性的网站，也会降低 HTML 中 title 和 alt 的潜在益处。<br>因此，CSS sprite 本身没错，而且也不会引发可访问性问题(事实上，正确得使用会提高可访问性)。但是不分对错得过度使用 sprite 会阻碍具有可访问性和生产率方面的网页建设进程。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>co源码分析</title>
    <link href="https://superq314.github.io/posts/b4573e17/"/>
    <id>https://superq314.github.io/posts/b4573e17/</id>
    <published>2022-10-03T09:36:42.000Z</published>
    <updated>2022-10-03T11:37:04.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Generator</button></li><li class="tab"><button type="button" data-href="#super-2">Promise</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><code>generator函数</code>是回调地狱的一种解决方案，跟 <code>promise</code>类似，但是却可以以同步的方式来书写代码，而避免了promise的链式调用。</p><p>它的执行过程在于调用生成器函数（function*）后，会返回一个iterator（迭代）对象，即Generator对象，但是它并不会立刻执行里面的代码。</p><p>它有几个方法，next(), throw()和return()。<br>调用next()方法后，它会找到第一个yield关键字（直到找到程序底部或者return语句），每次程序运行到yield关键字时，程序便会暂停，保存当前环境里面的变量的值，然后可以跳出当前运行环境去执行yield后面的代码，再把结果返回回来。</p><p>返回的结果是一个对象，类似于{value: ‘’, done: false}</p><ul><li>value表示本次yield后面执行之后返回的结果。如果是Promise实例，则是返回resolved后的值。</li><li>done表示迭代器是否执行完毕，若为true，则表示当前生成器函数已经产生了最后输出的值，即生成器函数已经返回。</li></ul><p>下面是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;All done.&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">constructor</span>);     <span class="comment">// output: GeneratorFunction &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 0, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: &#x27;All done.&#x27;, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p><code>Promise对象</code>用于一个异步操作的最终完成（或失败）及其结果值的表示(简单点说就是处理异步请求）。</p><p>Promise核心就在于里面状态的变换，是rejected、resolved还是pending，还有就是原型链上的then()方法，它可以传递本次状态转换后返回的值。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="co源码分析"><a href="#co源码分析" class="headerlink" title="co源码分析"></a>co源码分析</h2><p>主要脉络</p><p> <strong>co函数调用后，返回一个Promise实例</strong> 。</p><blockquote><p>co的思想就是将一个传递进来的参数进行合法化，再通过转换成Promise实例返回出去。<br>如果参数fn是generator函数的话，里面还可以自动进行遍历，执行generator函数里面的yield关键字后面的内容，并返回结果，也就是不断地调用fn().next()方法，再通过传递返回的Promise实例resolved后的值，从而达到同步执行generator函数的效果。</p></blockquote><p>注意：<strong>co里面最主要的是要理解Promise实例和Generator对象，它们是co函数里面的程序自动遍历执行的关键</strong> 。</p><p>下面解释一下co模块里面的最重要的两部分，一个是generator函数的自动调用，另外一个是参数的Promise化。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">co完整源码</button></li><li class="tab"><button type="button" data-href="#super-2">generator函数的自动调用</button></li><li class="tab"><button type="button" data-href="#super-3">参数Promise化(co中的toPromise的实现)</button></li><li class="tab"><button type="button" data-href="#super-4">着重来分析一下objectToPromise</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * slice() reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the generator function or a generator</span></span><br><span class="line"><span class="comment"> * and return a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">  <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">res</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="keyword">throw</span>(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">     * return a promise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">ret</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">onRejected</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">        + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="title class_">String</span>(ret.<span class="property">value</span>) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a `yield`ed value into a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPromise</span>(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isGeneratorFunction</span>(obj) || <span class="title function_">isGenerator</span>(obj)) <span class="keyword">return</span> co.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) <span class="keyword">return</span> arrayToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> objectToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a thunk to a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thunkToPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fn.<span class="title function_">call</span>(ctx, <span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">2</span>) res = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an array of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(obj.<span class="title function_">map</span>(toPromise, <span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an object of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectToPromise</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);  <span class="comment">//Object.create()</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);  <span class="comment">//[&quot;a&quot;,&quot;b&quot;]</span></span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];   <span class="comment">//a   b</span></span><br><span class="line">    <span class="keyword">var</span> promise = toPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj[key]);</span><br><span class="line">    <span class="keyword">if</span> (promise &amp;&amp; <span class="title function_">isPromise</span>(promise)) <span class="title function_">defer</span>(promise, key);</span><br><span class="line">    <span class="keyword">else</span> results[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Promise.resolve(4) Promise.resolve(5)  </span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">defer</span>(<span class="params">promise, key</span>) &#123;</span><br><span class="line">    <span class="comment">// predefine the key in the result</span></span><br><span class="line">    results[key] = <span class="literal">undefined</span>;   <span class="comment">//&#123;&#125;.a  &#123;&#125;.b</span></span><br><span class="line">    promises.<span class="title function_">push</span>(promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      results[key] = res;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">then</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a generator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isGenerator</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">next</span> &amp;&amp; <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a generator function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isGeneratorFunction</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> constructor = obj.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">if</span> (!constructor) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="property">name</span> || <span class="string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="property">displayName</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isGenerator</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check for plain object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span> == val.<span class="property">constructor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * slice() reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the generator function or a generator</span></span><br><span class="line"><span class="comment"> * and return a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存当前的执行环境</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 切割出函数调用时传递的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">    <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果gen是一个函数，则返回一个新的gen函数的副本，里面绑定了this的指向，即ctx</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果gen不存在或者gen.next不是一个函数，就说明gen已经调用完成，那么直接可以resolve(gen)，返回Promise</span></span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首次调用gen.next()函数，假如存在的话</span></span><br><span class="line">        <span class="title function_">onFulfilled</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">res</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试着获取下一个yield后面代码执行后返回的值</span></span><br><span class="line">                ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理结果</span></span><br><span class="line">            <span class="title function_">next</span>(ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试抛出错误</span></span><br><span class="line">                ret = gen.<span class="keyword">throw</span>(err);</span><br><span class="line">            &#125; <span class="keyword">catch</span> **(e) &#123;</span><br><span class="line">                <span class="keyword">return</span> **<span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理结果</span></span><br><span class="line">            <span class="title function_">next</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">         * return a promise.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">ret</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这个next()函数是最为关键的一部分，里面几乎包含了generator自动调用实现的核心</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果ret.done === true，证明generator函数已经执行完毕。即已经返回了值</span></span><br><span class="line">            <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把ret.value转换成Promise对象继续调用</span></span><br><span class="line">            <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果存在，则把控制权交给onFulfilled和onRejected，实现递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则最后直接抛出错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">onRejected</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span>+ <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="title class_">String</span>(ret.<span class="property">value</span>) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码中的onFulfilled和onRejected，可以把它们看成是co模块对于resolve和reject封装的加强版。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a `yield`ed value into a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的 obj 是假值，返回这个假值 如 undefined , false, null</span></span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 如果是 Promise 实例，返回这个 promise 实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPromise</span>(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 如果是 generator 函数或者 一个generator</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isGeneratorFunction</span>(obj) || <span class="title function_">isGenerator</span>(obj)) <span class="keyword">return</span> co.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是 thunk 函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) <span class="keyword">return</span> arrayToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是一个 plain object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> objectToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是原始值，则返回这个原始值。</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toPromise的本质上就是通过判定参数的类型，然后再通过转移控制权给不同的参数处理函数，从而获取到期望返回的值。</p><p>关于参数的类型的判断，看一下源码就能理解了，比较简单。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an object of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectToPromise</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="comment">// 定义一个和传入的对象一样构造器的空对象</span></span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取对象的所有可以遍历的key（属性）</span></span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="comment">// 用于盛放 每个属性值生成的对应的 promise 实例</span></span><br><span class="line">    <span class="keyword">var</span> promises = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于数组的每一个项都调用一次toPromise方法，变成Promise对象</span></span><br><span class="line">        <span class="keyword">var</span> promise = toPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj[key]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果里面是Promise对象的话，则取出e里面resolved后的值</span></span><br><span class="line">        <span class="keyword">if</span> (promise &amp;&amp; <span class="title function_">isPromise</span>(promise)) <span class="title function_">defer</span>(promise, key);</span><br><span class="line">        <span class="keyword">else</span> results[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行，按顺序返回结果，返回一个数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 将 results 作为 onFulfilled 函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key来获取Promise实例resolved后的结果，从而push进结果数组results中</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">defer</span>(<span class="params">promise, key</span>) &#123;</span><br><span class="line">        <span class="comment">// predefine the key in the result</span></span><br><span class="line">        results[key] = <span class="literal">undefined</span>;</span><br><span class="line">        promises.<span class="title function_">push</span>(promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义promise 实例的 resolve 函数</span></span><br><span class="line">            results[key] = res;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面理解的关键就在于把key遍历，如果key对应的value也是Promise对象的话，那么调用defer()方法来获取resolved后的值。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="编写自己的generator函数运行器"><a href="#编写自己的generator函数运行器" class="headerlink" title="编写自己的generator函数运行器"></a>编写自己的generator函数运行器</h2><p>通过以上的简单介绍，我们就可以尝试来写一个属于自己的generator函数运行器了，目标功能是能够自动运行function* 函数，并且里面的yield子句后面跟着的都是Promise实例。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">具体代码(my-co.js)</button></li><li class="tab"><button type="button" data-href="#super-2">在test.js文件中调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-co.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = my-co;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my-co = <span class="keyword">function</span> (<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="comment">// gen是一个具有Promise的生成器函数</span></span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">gen</span>(); <span class="comment">// 迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次调用next</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = g.<span class="title function_">next</span>(val); <span class="comment">// 调用ret</span></span><br><span class="line">        <span class="keyword">if</span> (ret.<span class="property">done</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; <span class="string">&#x27;function&#x27;</span> === <span class="keyword">typeof</span> ret.<span class="property">value</span>.<span class="property">then</span>) &#123;</span><br><span class="line">            ret.<span class="property">value</span>.<span class="title function_">then</span>( <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 继续循环下去</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">next</span>(data); <span class="comment">// promise resolved</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.jsconst</span></span><br><span class="line">myCo = <span class="built_in">require</span>(<span class="string">&#x27;./my-co&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">yield</span> <span class="title function_">pro1</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data1: &#x27;</span> + data1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">yield</span> <span class="title function_">pro2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data2: &#x27;</span> + data2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">yield</span> <span class="title function_">pro3</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data3: &#x27;</span> + data3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data4 = <span class="keyword">yield</span> <span class="title function_">pro4</span>(data1 + <span class="string">&#x27;\n&#x27;</span> + data2 + <span class="string">&#x27;\n&#x27;</span> + data3);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data4: &#x27;</span> + data4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;All done.&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用myCo</span></span><br><span class="line"><span class="title function_">myCo</span>(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟两秒</span></span><br><span class="line">resolve<span class="keyword">function</span> <span class="title function_">pro1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;promise1 resolved&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟一秒</span></span><br><span class="line">resolve<span class="keyword">function</span> <span class="title function_">pro2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;promise2 resolved&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入Hello World到./1.txt文件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pro3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="string">&#x27;Hello World\n&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;write-1 success&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入content到./1.txt文件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pro4</span>(<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>, content, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;write-2 success&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果：<br><code>// output data1: promise1 resolved data2: promise2 resolved data3: write-1 success data4: write-2 success</code><br>.&#x2F;1.txt文件内容：<br><code>Hello World promise1 resolved promise2 resolved write-1 success</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>虽然这个运行器很简单，后面只支持Promise实例，并且也不支持多种参数，但是却引导出了一个思路，促使我们思考怎么去展示我们的代码，还有就是很有效地避免了多重then，以 <strong>同步的方式来书写异步代码</strong> 。Promise解决的是回调地狱的问题（callback hell）,而Generator解决的是代码的书写方式。孰优孰劣，全在于个人意愿。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上分析了co部分源码的精髓，讲到了co函数里面generator函数自动遍历执行的机制，还讲到了co里面最为关键的objectToPromise()方法。</p><p>在文章的后面我们编写了一个属于自己的generator函数遍历器，其中主要的是next()方法，它可以检测我们yield后面Promise操作是否完成。<br>如果generator的状态done还没有置为true，那么继续调用next(val)方法，并把上一次yield操作获取到的值传递下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo更新方式</title>
    <link href="https://superq314.github.io/posts/15858/"/>
    <id>https://superq314.github.io/posts/15858/</id>
    <published>2022-09-30T11:35:29.000Z</published>
    <updated>2022-10-06T12:07:44.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/litten/</span>hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/yilia</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>使用cd命令进入博客根目录<br>常规操作，不做解释</p><p>更新插件和Hexo版本<br>npm update</p><h2 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h2><ol><li>使用cd命令进入博客根目录<br>常规操作，不做解释</li><li>检查插件更新<br>npm outdated</li><li>运行后可以检查Hexo和插件的最新版本<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537849838.png" alt="1664537849838"></li><li>更改版本文件<br>修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537868070.png" alt="1664537868070"></li><li>开始更新<br>npm install –save</li><li>查看当前版本号<br>hexo version<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537946133.png" alt="1664537946133"></li></ol><p>真实有效</p><p>升级方法：在主題目录下，进行 <code>git pull</code></p><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为butterfly。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo</span> g <span class="comment"># 生成</span></span><br><span class="line">hexo s <span class="comment"># 启动本地web服务器</span></span><br></pre></td></tr></table></figure><p>现在打开<a href="http://localhost:4000/">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP中get和post的区别</title>
    <link href="https://superq314.github.io/posts/d73b0b5a/"/>
    <id>https://superq314.github.io/posts/d73b0b5a/</id>
    <published>2022-09-28T12:15:16.000Z</published>
    <updated>2022-10-06T12:08:56.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p><p>到这里，大家应该有个大概的了解了，GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息。</p><p>1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>*注意：这里安全的含义仅仅是指是非修改信息。</p><p>(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：</p><p>幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。</p><p>幂等有一下几种定义：</p><p>对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)&#x3D;abs(abs(a))。</p><p>对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x)&#x3D;x。</p><p>看完上述解释后，应该可以理解GET幂等的含义了。</p><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><p>2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。</p><p>上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：</p><p>1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。</p><p>2.对资源的增，删，改，查操作，其实都可以通过GET&#x2F;POST完成，不需要用到PUT和DELETE。</p><p>3.另外一个是，早期的WebMVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的WebMVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。</p><p>*简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</p><p>以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(RepresentationalStateTransfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTfulWebServices》。</p><p>说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：</p><p>1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name&#x3D;hyddd&amp;password&#x3D;idontknow&amp;verify&#x3D;%E4%BD%A0%E5%A5%BD。如果数据是英文字母&#x2F;数字，原样发送，如果是空格，转换为+，如果是中文&#x2F;其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST把提交的数据则放置在是HTTP包的包体中。</p><p>2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p><p>以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：</p><p>(1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。</p><p>(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K&#x2F;100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。</p><p>对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。</p><p>由这个延伸出去，对于IIS6.0，微软出于安全考虑，加大了限制。我们还需要注意：</p><p>1).IIS6.0默认ASPPOST数据量最大为200KB，每个表单域限制是100KB。</p><p>2).IIS6.0默认上传文件的最大大小是4MB。</p><p>3).IIS6.0默认最大请求头是16KB。</p><p>IIS6.0之前没有这些限制。</p><p>所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。</p><p>3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(&quot;XXXX&quot;)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name&#x3D;hyddd&amp;password&#x3D;hyddd，用request.getQueryString()得到的是：name&#x3D;hyddd&amp;password&#x3D;hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。</p><p>4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-siterequestforgery攻击。</p><p>总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！</p><p>从<strong>数据包</strong>、<strong>编码方式</strong>、<strong>请求参数</strong>、<strong>收藏为书签</strong>、<strong>历史记录</strong>、<strong>安全性</strong>等几方面回答。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoulHqEe98uNmf1Jcj0p5Wvj8sA2bAJeobXuPcXF7kuf9RUvuW9iabmrCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><table><thead><tr><th>请求方式</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>数据包</td><td>产生一个 <code>TCP</code>数据包</td><td>可能产生两个 <code>TCP</code>数据包</td></tr><tr><td>数据位置</td><td>query string</td><td>request body</td></tr><tr><td>编码方式</td><td>只能进行 <code>url</code>编码</td><td>支持多种编码方式</td></tr><tr><td>请求参数</td><td>把参数包含在 <code>url</code>中，用 <code>&amp;</code>连接起来</td><td>通过 <code>request body</code>传递参数</td></tr><tr><td>请求缓存</td><td>会被主动 <code>Cache</code></td><td>不会缓存,除非手动设置</td></tr><tr><td>收藏为书签</td><td>支持</td><td>不支持</td></tr><tr><td>历史记录</td><td>参数会被完整保留在浏览历史记录里</td><td>不会保留</td></tr><tr><td>参数数据类型</td><td><code>ASCII</code>的字符</td><td></td></tr><tr><td>语义</td><td>在服务器上查询数据并返回</td><td>增加新资源，修改已有资源</td></tr><tr><td>安全性</td><td>低于post</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>compose和pipe函数</title>
    <link href="https://superq314.github.io/posts/82dafe4d/"/>
    <id>https://superq314.github.io/posts/82dafe4d/</id>
    <published>2022-09-23T06:48:12.000Z</published>
    <updated>2022-09-30T13:34:43.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Compose函数</button></li><li class="tab"><button type="button" data-href="#super-2">Pipe函数</button></li><li class="tab"><button type="button" data-href="#super-3">链式调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>定义：为了便于连续执行方法，把调用传值整个过程封装成函数，即为compose函数。只需要告诉compose函数需要执行哪些方法，其会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// arguments</span></span><br><span class="line">    <span class="keyword">const</span> args = [].<span class="property">slice</span>.<span class="title function_">apply</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _result = num;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(var i = args.length - 1; i &gt;= 0; i—) &#123;</span></span><br><span class="line"><span class="comment">            _result = args[i](_result);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return _result; </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        <span class="keyword">return</span> args.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">res, cb</span>) =&gt;</span> <span class="title function_">cb</span>(res), num); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(addThree, addTwo, minusOne, multiplyTwo)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>和compose函数功能一样，执行方向相反</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>用promise组成链式调用（此处和面向对象的链式调用有所区别）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>reflect反射机制</title>
    <link href="https://superq314.github.io/posts/41365fed/"/>
    <id>https://superq314.github.io/posts/41365fed/</id>
    <published>2022-09-23T01:16:27.000Z</published>
    <updated>2022-09-30T13:34:43.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>MDN定义：<br>Reflect是一个内置的对象，用来提供方法去拦截JavaScript的操作。Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，你不能通过 <code>new</code>操作符去新建或者将其作为一个函数去调用Reflect对象。Reflect的所有属性和方法都是静态的。</p></blockquote><p>反射机制指的是程序在运行时能够获取自身的信息。js 中的 apply 就是反射机制。</p><p><strong>Reflect API 汇总</strong><br>Reflect 提供了一套用于操作对象的 API（静态方法）</p><table><thead><tr><th><strong>handler⽅法</strong></th><th><strong>默认设置调⽤</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>get</td><td>Reflect.get(target, name, receiver)</td><td>获得目标的身上某一特性的值</td></tr><tr><td>set</td><td>Reflect.set(target, name, value, receiver)</td><td>在目标上设定特性</td></tr><tr><td>has</td><td>Reflect.has(obj, name)</td><td>分辨一个目标是不是存有某一特性</td></tr><tr><td>deleteProperty</td><td>Reflect.deleteProperty(obj, name)</td><td>删掉目标上的特性</td></tr><tr><td>getProperty</td><td>Reflect.getPrototypeOf(obj)</td><td>获得特定目标原形的涵数</td></tr><tr><td>setProperty</td><td>Reflect.setPrototypeOf(obj, newProto)</td><td>设定或更改目标原形的涵数</td></tr><tr><td>isExtensible</td><td>Reflect.isExtensible(target)</td><td>分辨一个目标是不是可拓展（即是不是可以加上新的特性）</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions(target)</td><td>阻拦新特性加上到目标</td></tr><tr><td>getOwnPropertyDescriptor</td><td>Reflect.getOwnPropertyDescriptor(target, propertyKey)</td><td>获得给出特性的特性描述符</td></tr><tr><td>defineProperty</td><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>界定或改动一个目标的特性</td></tr><tr><td>ownKeys</td><td>Reflect.ownKeys()</td><td>回到由总体目标目标本身的特性键构成的二维数组</td></tr><tr><td>apply</td><td>Reflect.apply(func, thisArg, args)</td><td>对一个涵数开展启用实际操作，另外能够传到一个二维数组做为启用主要参数</td></tr><tr><td>construct</td><td>Reflect.construct(target, args)</td><td>对构造方法开展new实际操作，完成建立类的案例</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions()</td><td>阻拦新特性加上到目标</td></tr></tbody></table><p><strong>Reflect对象的作用&#x2F;优点</strong></p><ol><li>把实现反射机制的方法重新归结在一起并且简化操作，保持JS语意清晰和语法简单</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> k = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; [s]: <span class="number">1</span>, [k]: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// getOwnPropertyNames获取到String类型的key</span></span><br><span class="line"><span class="comment">// getOwnPropertySymbols获取到Symbol类型的key</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// 使用Reflect的话：</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o);</span><br></pre></td></tr></table></figure><ol start="2"><li>补充一些Object对象没有的方法（如Reflect.apply）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">…rest</span>)&#123;</span><br><span class="line">  consloe.<span class="title function_">log</span>(rest);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello:`</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="property">apply</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="attr">hello</span>: <span class="string">`小明`</span></span><br></pre></td></tr></table></figure><ol start="3"><li>让Object操作都变为函数行为，比如使用Reflect.has(obj, name)替换name in obj</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">`id`</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, <span class="string">`id`</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>proxy</title>
    <link href="https://superq314.github.io/posts/7372c9be/"/>
    <id>https://superq314.github.io/posts/7372c9be/</id>
    <published>2022-09-23T01:14:37.000Z</published>
    <updated>2022-09-30T13:34:43.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Proxy是ES6中提供的新的API<br>proxy代理：在目标对象的前面设置一个拦截层，外界在访问这个对象的时候，必须经过拦截层。</p><blockquote><p>我们可以在拦截层做一些过滤或者是改写的操作。<br>语法<br><code>var proxy = new Proxy(target, handler);</code><br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中：</p></blockquote><ul><li>new Proxy() 表示生成一个 Proxy 实例</li><li>target 参数表示所要拦截的目标对象可以是一个object或者function</li><li>handler 参数也是一个对象，用来定制拦截行为;如果handler没有设置任何拦截，那就等同于直接通向原对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="Proxy" scheme="https://superq314.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>generator生成器</title>
    <link href="https://superq314.github.io/posts/8706750a/"/>
    <id>https://superq314.github.io/posts/8706750a/</id>
    <published>2022-09-22T14:51:13.000Z</published>
    <updated>2022-10-10T08:37:58.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Generatror-的两个特征："><a href="#Generatror-的两个特征：" class="headerlink" title="Generatror()的两个特征："></a>Generatror()的两个特征：</h2><ul><li>function关键字与函数名之间有一个星号</li><li>函数体内部使用yield语句，定义不同的内部状态</li></ul><p>生成器它能像迭代一样返回一个迭代器对象，然后调用 next 方法进行抽取。<br>Generator函数有多种理解角度。从语法上，可以把它理解成一个状态机，封装了多个内部状态。<br>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">createIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>　　在这个示例中，createlterator()前的星号表明它是一个生成器；yield关键字也是ES6的新特性，可以通过它来指定调用迭代器的next()方法时的返回值及返回顺序。生成迭代器后，连续3次调用它的next()方法返回3个不同的值，分别是1、2和3。生成器的调用过程与其他函数一样，最终返回的是创建好的迭代器<br>　　生成器函数最有趣的部分是，每当执行完一条yield语句后函数就会自动停止执行。举个例子，在上面这段代码中，执行完语句yield 1之后，函数便不再执行其他任何语句，直到再次调用迭代器的next()方法才会继续执行yield 2语句。生成器函数的这种中止函数执行的能力有很多有趣的应用<br>　　使用yield关键字可以返回任何值或表达式，所以可以通过生成器函数批量地给迭代器添加元素。例如，可以在循环中使用yield关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在此示例中，给生成器函数createlterator()传入一个items数组，而在函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个yield语句循环都会停止；每次调用迭代器的next()方法，循环会继续运行并执行下一条yield语句<br>　　生成器函数是ES6中的一个重要特性，可以将其用于所有支持函数使用的地方</p><h2 id="【使用限制】"><a href="#【使用限制】" class="headerlink" title="【使用限制】"></a>【使用限制】</h2><p>yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从字面上看，yield关键字确实在createlterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误</p><h2 id="【生成器函数表达式】"><a href="#【生成器函数表达式】" class="headerlink" title="【生成器函数表达式】"></a>【生成器函数表达式】</h2><p>　　也可以通过函数表达式来创建生成器，只需在function关键字和小括号中间添加一个星号(*)即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在这段代码中，createlterator()是一个生成器函数表达式，而不是一个函数声明。由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间。此外，这个示例基本与前例相同，使用的也是for循环<br>　　[注意]不能用箭头函数来创建生成器</p><h2 id="【生成器对象的方法】"><a href="#【生成器对象的方法】" class="headerlink" title="【生成器对象的方法】"></a>【生成器对象的方法】</h2><p>　　由于生成器本身就是函数，因而可以将它们添加到对象中。例如，在ES5风格的对象字面量中，可以通过函数表达式来创建生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">createIterator</span>: <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　也可以用ES6的函数方法的简写方式来创建生成器，只需在函数名前添加一个星号(*)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　这些示例使用了不同于之前的语法，但它们的功能实际上是等价的。在简写版本中，由于不使用function关键字来定义createlterator()方法，因此尽管可以在星号和方法名之间留白，但还是将星号紧贴在方法名之前</p><h2 id="【状态机】生成器的一个常用功能是生成状态机"><a href="#【状态机】生成器的一个常用功能是生成状态机" class="headerlink" title="【状态机】生成器的一个常用功能是生成状态机"></a>【状态机】生成器的一个常用功能是生成状态机</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = <span class="title function_">state</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;C&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="应用场景：通过yield-实现非线性迭代"><a href="#应用场景：通过yield-实现非线性迭代" class="headerlink" title="应用场景：通过yield*实现非线性迭代"></a>应用场景：通过yield*实现非线性迭代</h2><p>yield关键字后面可以跟随另一个generator对象或其他可迭代对象。<br>可以利用这个特性实现非线性结构的遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘a1’</span><br><span class="line">  <span class="keyword">yield</span> ‘a2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘b1’</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">a</span>()</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">yield</span> ‘b2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="title function_">b</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b1 a1 a2 1 2 b2</span></span><br></pre></td></tr></table></figure><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">next</button></li><li class="tab"><button type="button" data-href="#super-2">throw</button></li><li class="tab"><button type="button" data-href="#super-3">return</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>ES6规范中规定迭代器必须有一个next方法，这个方法会返回一个对象，这个对象具有done和value两个属性，done表示当前迭代器内容是否已经执行完，执行完为true，否则为false，value表示当前步骤返回的值。在generator具体运用中，每次遇到yield关键字都会暂停执行，当调用迭代器的next时，会将yield后面表达式的值作为返回对象的value，比如上面生成器的执行结果如下:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795897786.png" alt="1664795897786"><br>我们可以看到第一次调next返回的就是第一个yeild后面表达式的值，也就是1。需要注意的是，整个迭代器目前暂停在了第一个yield这里，给变量a赋值都没执行，要调用下一个next的时候才会给变量a赋值，然后一直执行到第二个yield。那应该给a赋什么值呢？从代码来看，a的值应该是yield语句的返回值，但是yield本身是没有返回值的，或者说返回值是undefined，如果要给a赋值需要下次调next的时候手动传进去，我们这里传一个4，4就会作为上次yield的返回值赋给a:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795908411.png" alt="1664795908411"><br>可以看到第二个yield后面的表达式a + 2的值是6，这是因为我们传进去的4被作为上一个yield的返回值了，然后计算a + 2自然就是6了。<br>我们继续next，把这个迭代器走完：<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795913662.png" alt="1664795913662"><br>上图是接着前面运行的，图中第一个next返回的value是NaN是因为我们调next的时候没有传参数，也就是说b为undefined，undefined + 3就为NaN了 。最后一个next其实是把函数体执行完了，这时候的value应该是这个函数return的值，但是因为我们没有写return，默认就是return undefined了，执行完后done会被置为true。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>迭代器还有个方法是throw，这个方法可以在函数体外部抛出错误，然后在函数里面捕获，还是上面那个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();  </span><br></pre></td></tr></table></figure><p>我们这次不用next执行了，直接throw错误出来:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795946858.png" alt="1664795946858"><br>这个错误因为我们没有捕获，所以直接抛到最外层来了，我们可以在函数体里面捕获他，稍微改下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();  </span><br></pre></td></tr></table></figure><p>然后再来throw下：<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795968330.png" alt="1664795968330"><br>这个图可以看出来，错误在函数里里面捕获了，走到了catch里面，这里面只有一个console同步代码，整个函数直接就运行结束了，所以done变成true了，当然catch里面可以继续写yield然后用next来执行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>迭代器还有个return方法，这个方法就很简单了，他会直接终止当前迭代器，将done置为true，这个方法的参数就是迭代器的value，还是上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();</span><br></pre></td></tr></table></figure><p>这次我们直接调用return:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795994234.png" alt="1664795994234"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>iterator迭代器</title>
    <link href="https://superq314.github.io/posts/a5155495/"/>
    <id>https://superq314.github.io/posts/a5155495/</id>
    <published>2022-09-22T14:50:35.000Z</published>
    <updated>2022-10-10T08:37:11.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="遍历和迭代的区别"><a href="#遍历和迭代的区别" class="headerlink" title="遍历和迭代的区别"></a>遍历和迭代的区别</h2><p>迭代：从目标源依次按逐个抽取的方式来提取数据，其中目标源满足：</p><blockquote><ol><li>有序的</li><li>连续的<br>遍历：没有这些要求，对于不同数据类型有着不同的遍历方式。</li></ol></blockquote><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>迭代器对象是一种接口，也可以说是一种规范。<br>为各种不同的数据结构提供统一的访问机制。<br>任何数据结构只要部署Iterator接口，就可以完成遍历操作。<br>本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。<br>只要拥有了该属性，就能够用迭代器的方式进行遍历。</p></blockquote><h2 id="数组的Symbol-iterator属性"><a href="#数组的Symbol-iterator属性" class="headerlink" title="数组的Symbol.iterator属性"></a>数组的Symbol.iterator属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">// 获取数组中的迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="手动实现Symbol-iterator"><a href="#手动实现Symbol-iterator" class="headerlink" title="手动实现Symbol.iterator"></a>手动实现Symbol.iterator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> make <span class="title class_">Iterator</span>(arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next () &#123;</span><br><span class="line">      <span class="keyword">if</span>(idx &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: arr[idx++],</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现对象的自定义迭代器对象"><a href="#实现对象的自定义迭代器对象" class="headerlink" title="实现对象的自定义迭代器对象"></a>实现对象的自定义迭代器对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mp = <span class="keyword">new</span> <span class="title class_">Map</span>([[‘a’, <span class="number">1</span>], [‘b’, <span class="number">2</span>], [’c’, <span class="number">3</span>]]);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        <span class="keyword">let</span> mpEntries = […, mp.<span class="title function_">entries</span>()];</span><br><span class="line">        <span class="keyword">if</span>(idx &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: mp[idx++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>iterator必须实现next方法，该方法每次被调用时返回一个迭代器结果。</p><ul><li>next()：被调用时返回一个iteratorResult对象</li><li>return()：被调用时返回一个iteratorResult对象，通常在调用者希望提前结束迭代时调用</li><li>throw()：被调用时返回一个iteratorResult对象，通常在调用者检测到错误时被调用</li></ul><h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><p>对象必须提供一个next()，执行该方法后 &#x3D;&gt; 要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代<br>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性</p><ul><li>value属性：迭代未完成时，返回当前位置的元素；迭代完成后，返回迭代器返回值或者缺省</li><li>done属性：一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()<br>  对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</li></ul><h2 id="遍历过程："><a href="#遍历过程：" class="headerlink" title="遍历过程："></a>遍历过程：</h2><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ol><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of使用</li></ol><h2 id="原生具备-Iterator-接口的数据结构"><a href="#原生具备-Iterator-接口的数据结构" class="headerlink" title="原生具备 Iterator 接口的数据结构"></a>原生具备 Iterator 接口的数据结构</h2><p>可用<code>for..of</code>直接迭代出来的有:</p><ul><li><code>Array</code></li><li><code>Map</code></li><li><code>Set</code></li><li><code>String</code></li><li><code>TypedArray</code></li><li>函数的<code>arguments</code>（类数组对象）</li><li><code>DOM</code>中的<code>NodeList</code>（类数组对象）</li></ul><p>如果一个数据类型能迭代的话，会在原型上存在 Symbol(Symbol.iterator)方法</p><blockquote><p>总结：调用Symbol(Symbol.iterator)方法将会返回一个 迭代器对象，而这个迭代器对象具备 next() 方法，通过这个方法来实现逐步调用，同时每次调用的时候会返回一个对象，包括 value 和 done 两个属性，当value为 undefined，done 为 true 时迭代完成。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
</feed>
