<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-08-16T08:44:31.805Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型链</title>
    <link href="https://superq314.github.io/2022/08/16/frontEnd/JavaScript/prototype/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://superq314.github.io/2022/08/16/frontEnd/JavaScript/prototype/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2022-08-16T08:44:14.675Z</published>
    <updated>2022-08-16T08:44:31.805Z</updated>
    
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JS" scheme="https://superq314.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>样式与选择器</title>
    <link href="https://superq314.github.io/2022/08/09/frontEnd/CSS/%E6%A0%B7%E5%BC%8F%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/08/09/frontEnd/CSS/%E6%A0%B7%E5%BC%8F%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-08-09T13:59:50.858Z</published>
    <updated>2022-08-09T14:41:42.714Z</updated>
    
    <content type="html"><![CDATA[<p>css样式声明（定义）由两部分组成，形式如下：<br><code>选择器&#123; 样式；&#125;</code>，在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。</p><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><h4 id="标签选择器（div，h1，p）"><a href="#标签选择器（div，h1，p）" class="headerlink" title="标签选择器（div，h1，p）"></a>标签选择器（div，h1，p）</h4><p>对应html代码中的标签。</p><h4 id="ID选择器（-id）"><a href="#ID选择器（-id）" class="headerlink" title="ID选择器（#id）"></a>ID选择器（#id）</h4><p>使用元素 id 作为标示来指定样式。<br>ID 选择器前面有一个 # 号。</p><h4 id="类（class）选择器（-class）"><a href="#类（class）选择器（-class）" class="headerlink" title="类（class）选择器（.class）"></a>类（class）选择器（.class）</h4><p>允许以一种独立于文档元素的方式来指定样式。</p><p>同一个类选择器可以指定给不同的多个元素。</p><h4 id="层级选择器（单个）"><a href="#层级选择器（单个）" class="headerlink" title="层级选择器（单个）"></a>层级选择器（单个）</h4><p>以空格分隔，只作用在一个选择器上。<br>只作用a的class-p1的选择器上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 类选择器a中的 类选择器class-p1*/</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.a</span> <span class="selector-class">.class-p1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: orange;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    滚开</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;class-p1&quot;</span>&gt;</span></span><br><span class="line">    我是谁？</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="组合选择器（多个）"><a href="#组合选择器（多个）" class="headerlink" title="组合选择器（多个）"></a>组合选择器（多个）</h4><p>以逗号进行分隔，作用在多个选择器上。<br><code>.class-p1, .class-p2&#123; color: orange; &#125;</code></p><h3 id="通配符选择器（-）"><a href="#通配符选择器（-）" class="headerlink" title="通配符选择器（*）"></a>通配符选择器（*）</h3><p>CSS2 引入了一种新的简单选择器 - 通配选择器，显示为一个星号（*）。该选择器可以与任何元素匹配，就像是一个通配符。<br><code>* &#123; color: red; &#125;</code>：可以使文档中的每个元素都为红色</p><h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><h4 id="后代选择器，又称包含选择器（li-a）"><a href="#后代选择器，又称包含选择器（li-a）" class="headerlink" title="后代选择器，又称包含选择器（li a）"></a>后代选择器，又称包含选择器（li a）</h4><p>可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。<br>举例来说，如果希望只对 h1 元素中的 em 元素应用样式，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">h1</span> <span class="selector-tag">em</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    This is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>important<span class="tag">&lt;/<span class="name">em</span>&gt;</span> heading</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    This is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>important<span class="tag">&lt;/<span class="name">em</span>&gt;</span> paragraph</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="子代选择器（ul-gt-li）"><a href="#子代选择器（ul-gt-li）" class="headerlink" title="子代选择器（ul &gt; li）"></a>子代选择器（ul &gt; li）</h4><p>与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素子元素的元素。</p><p>如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器（Child selector）。</p><p>例如，选择h1元素的子元素strong，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">h1</span> &gt; <span class="selector-tag">strong</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    This is <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> important.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    This is <span class="tag">&lt;<span class="name">em</span>&gt;</span>really <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> <span class="tag">&lt;/<span class="name">em</span>&gt;</span> important.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>层次选择器</th><th>类型</th><th>功能描述</th></tr></thead><tbody><tr><td>E F</td><td>后代选择器</td><td>选择匹配的F元素，F元素被包含在匹配的E元素内</td></tr><tr><td>E &gt; F</td><td>子选择器</td><td>选择匹配的F元素，F元素是E元素的子元素</td></tr><tr><td>E + F</td><td>相邻兄弟选择器</td><td>选择匹配的F元素，F元素紧位于匹配的E元素的后面</td></tr><tr><td>E ~ F</td><td>通用兄弟选择器</td><td>选择匹配的F元素，F元素是E元素之后所有的F元素</td></tr></tbody></table><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>用于向某些选择器添加特殊的效果。</p><h4 id="链接伪类"><a href="#链接伪类" class="headerlink" title="链接伪类"></a>链接伪类</h4><ol><li><code>&lt;a&gt;&lt;/a&gt;</code>此标签有一个提示属性，当鼠标移上去的时候有提示语句显示。</li><li><code>&lt;a&gt;&lt;/a&gt;</code>此标签的伪类选择器有顺序，顺序具体如下：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: <span class="number">#FF0000</span>&#125;        <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#00FF00</span>&#125;    <span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;    <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: <span class="number">#0000FF</span>&#125;    <span class="comment">/* 选定的链接 */</span></span><br></pre></td></tr></table></figure><p>可以简洁记忆：l v h a 记住四个属性的首字母即可。<br>注意：如果不按顺序编写此伪类标签无效。</p><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><table><thead><tr><th>结构伪类选择器</th><th>功能描述</th></tr></thead><tbody><tr><td>E:first-child</td><td>选择所有元素，且E元素是其父元素中第一个</td></tr><tr><td>E:last-child</td><td>选择所有元素，且E元素是其父元素中最后一个</td></tr><tr><td>E:root</td><td>选择E元素所在文档的根元素。HTML中，根元素始终是html</td></tr><tr><td>E F:nth-child(n)</td><td>选择父元素E的第n个子元素F。<br />n可以是整数(1，2，3)、关键字(even，odd)，n值起始值为1，而不是0</td></tr><tr><td>E F:nth-last-child(n)</td><td>选择父元素E的倒数第n个子元素F</td></tr><tr><td>E:nth-of-type(n)</td><td>选择所有在父元素内的第n个E元素</td></tr><tr><td>E:nth-last-of-type(n)</td><td>选择所有在父元素内的倒数第n个E元素</td></tr><tr><td>E:first-of-type</td><td>选择所有在父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同</td></tr><tr><td>E:last-of-type</td><td>选择所有在父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同</td></tr><tr><td>E:only-child</td><td>选择元素，且E元素是父元素的唯一子元素，没有别的元素</td></tr><tr><td>E:only-of-type</td><td>选择元素，且E元素是父元素中唯一类型的子元素。即多个子元素都是E元素</td></tr><tr><td>E:empty</td><td>选择没有子元素的E元素，而且E元素也不包含任何文本节点</td></tr><tr><td>E:before</td><td>选择E元素，在E元素之前插入内容</td></tr><tr><td>E:after</td><td>选择E元素，在E元素之后插入内容</td></tr></tbody></table><h4 id="UI元素状态伪类选择器"><a href="#UI元素状态伪类选择器" class="headerlink" title="UI元素状态伪类选择器"></a>UI元素状态伪类选择器</h4><table><thead><tr><th>UI元素状态伪类选择器</th><th>功能描述</th></tr></thead><tbody><tr><td>E:checked</td><td>匹配所有选中的表单元素。例如复选框、单选框</td></tr><tr><td>E:enabled</td><td>匹配所有启用的表单元素</td></tr><tr><td>E:disabled</td><td>匹配所有禁用的表单元素</td></tr><tr><td>E:focus</td><td>匹配所有获得光标焦点时的表单元素</td></tr><tr><td>E:read-write</td><td>匹配E元素处于非只读状态时</td></tr><tr><td>E:read-only</td><td>匹配E元素处于只读状态时</td></tr><tr><td>E:valid</td><td>匹配E元素诸如required、pattern等属性所指定的检查或元素内容符合元素的规定格式时的样式</td></tr><tr><td>E:invalid</td><td>匹配E元素诸如required、pattern等属性所指定的检查或元素内容不符合元素的规定格式时的样式</td></tr><tr><td>E:required</td><td>选择允许使用required属性并已使用该属性的input、select和textarea元素</td></tr><tr><td>E:optional</td><td>选择允许使用required属性但未使用该属性的input、select以及textarea元素</td></tr><tr><td>E::selection</td><td>选择被用户选取的E元素部分。使用两个冒号:: 是伪元素</td></tr></tbody></table><h3 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h3><p>内联样式 &gt;  css选择器样式 &gt; link 引入的样式</p><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important &gt; 行内（内联） &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符 &gt; 继承</p><p>权重<a href="https://gitee.com/souyunku/NewDevBooks/blob/master/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>：</p><p>（0，0，0，0）&#x3D;&#x3D;&gt;</p><blockquote><p>第一个 0 对应的是 !important 的个数<br>第二个 0 对应的是 id 选择器的个数<br>第三个 0 对应的类选择器的个数<br>第四个 0 对应的是标签选择器的个数<br>就是当前选择器的权重。</p></blockquote><p>比较：<br>先从第一个 0 开始比较，如果第一个 0 大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推</p><ul><li>!important声明的样式优先级最高，如果冲突再进行计算</li><li>虽然!important无敌和style一人之下，但都应尽量避免使用</li><li>如果优先级相同，则选择最后出现的样式</li><li>继承得到的样式的优先级最低</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;css样式声明（定义）由两部分组成，形式如下：&lt;br&gt;&lt;code&gt;选择器&amp;#123; 样式；&amp;#125;&lt;/code&gt;，在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。&lt;/p&gt;
&lt;h3 id=&quot;基本选择器&quot;&gt;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="CSS" scheme="https://superq314.github.io/categories/CSS/"/>
    
    
    <category term="选择器" scheme="https://superq314.github.io/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88/</id>
    <published>2022-08-01T13:25:20.121Z</published>
    <updated>2022-08-01T13:25:28.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h2><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=331" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=331">www.bilibili.com/video/BV1Sy…</a></p><h3 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h3><p>移动端浏览器兼容性较好，不需要考虑JS的兼容性问题，可放心食用原生js</p><p>移动端也独特的地方，比如：<strong>触屏事件touch（触屏事件）</strong> ，Android和IOS都有</p><p> <strong>touch对象代表一个触摸点</strong> 。触摸点可能是手指，也可能是触摸笔。触屏事件可响应用户对屏幕或触控板的操作</p><p>常见的触屏事件：</p><table><thead><tr><th>触屏touch事件</th><th>说明</th></tr></thead><tbody><tr><td>touchstart</td><td>触摸到DOM元素时触发</td></tr><tr><td>touchmove</td><td>在DOM元素上滑动时触发</td></tr><tr><td>touchend</td><td>在DOM元素上移开时触发</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移动端特效&quot;&gt;&lt;a href=&quot;#移动端特效&quot; class=&quot;headerlink&quot; title=&quot;移动端特效&quot;&gt;&lt;/a&gt;移动端特效&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https://www.bilibi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</id>
    <published>2022-08-01T13:24:53.678Z</published>
    <updated>2022-08-01T13:25:06.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a>本地存储特性</h3><p>特性：</p><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、页面刷新不会丢失数据</li><li>容量较大，sessionStorage约5M、localStorage约20M</li><li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li></ul><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage：</p><ul><li>生命周期为关闭浏览器窗口（关闭浏览器窗口消失）</li><li>在同一个窗口（页面）下数据可共享</li><li>以键值对的形式存储使用</li></ul><p>存储数据：<code>sessionStorage.setItem(key, value)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    var val = inputBox.value</span><br><span class="line">    sessionStorage.setItem(&#x27;userName&#x27;, val)</span><br><span class="line">    sessionStorage.setItem(&#x27;password&#x27;, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取数据：<code>sessionStorage.getItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(sessionStorage.getItem(&#x27;userName&#x27;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据：<code>sessionStorage.removeItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    sessionStorage.removeItem(&#x27;userName&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除所有数据：<code>sessionStorage.clear()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    sessionStorage.clear()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage：</p><ul><li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li><li>可以多窗口（页面）共享（同一浏览器）</li></ul><p>存储数据：<code>localStorage.setItem(key, value)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    var val = inputBox.value</span><br><span class="line">    localStorage.setItem(&#x27;userName&#x27;, val)</span><br><span class="line">    localStorage.setItem(&#x27;password&#x27;, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取数据：<code>localStorage.getItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(localStorage.getItem(&#x27;userName&#x27;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据：<code>localStorage.removeItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    localStorage.removeItem(&#x27;userName&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除所有数据：<code>localStorage.clear()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    localStorage.clear()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本地存储&quot;&gt;&lt;a href=&quot;#本地存储&quot; class=&quot;headerlink&quot; title=&quot;本地存储&quot;&gt;&lt;/a&gt;本地存储&lt;/h2&gt;&lt;h3 id=&quot;本地存储特性&quot;&gt;&lt;a href=&quot;#本地存储特性&quot; class=&quot;headerlink&quot; title=&quot;本地存储特</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</id>
    <published>2022-08-01T13:24:15.077Z</published>
    <updated>2022-08-01T13:24:38.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h2><h3 id="元素偏移量-offset系列"><a href="#元素偏移量-offset系列" class="headerlink" title="元素偏移量 offset系列"></a>元素偏移量 offset系列</h3><p>offset：偏移量，使用offset系列相关属性可动态的得到该元素的位置（偏移量）、大小等</p><ul><li>获得元素距离带有定位的父元素的位置</li><li>获得元素自身的大小（宽高）</li><li>注意：但会的数值都不带单位</li></ul><h4 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h4><table><thead><tr><th>offset系列属性</th><th>说明</th></tr></thead><tbody><tr><td>element.offsetParent</td><td>返回该元素带有定位的父元素，如果父元素没有定位，则返回body</td></tr><tr><td>element.offsetTop</td><td>返回元素相对带有定位的父元素上方的偏移</td></tr><tr><td>element.offsetLeft</td><td>返回元素相对带有定位的父元素左边框的偏移量</td></tr><tr><td>element.offsetWidth</td><td>返回自身包括padding、边框、内容的宽度，返回数值不带单位</td></tr><tr><td>element.offsetHeight</td><td>返回自身包括padding、边框、内容的高度，返回数值不带单位</td></tr></tbody></table><h4 id="offsetLeft-、offsetTop"><a href="#offsetLeft-、offsetTop" class="headerlink" title="offsetLeft 、offsetTop"></a>offsetLeft 、offsetTop</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=288" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=288">www.bilibili.com/video/BV1Sy…</a></p><p>offsetLeft 、offsetTop返回元素相对于带有定位的父元素上方&#x2F;左边的偏移，如果父级没有定位，则以body为准距离上方&#x2F;左方的距离是多少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .father &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        margin-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .son &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        background-color: rgb(51, 61, 197);</span><br><span class="line">        margin-left: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var father = document.querySelector(&#x27;.father&#x27;);</span><br><span class="line">    var son = document.querySelector(&#x27;.son&#x27;)</span><br><span class="line">    console.log(father.offsetTop); // 0</span><br><span class="line">    console.log(father.offsetLeft); // 100 因为father  margin-left: 100px; 距离左侧100的距离</span><br><span class="line">// 如果父级没有加定位 是 0 110 ，加了定位是 0 10</span><br><span class="line">    console.log(son.offsetTop); </span><br><span class="line">    console.log(son.offsetLeft);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="offsetWidth、offsetHeight"><a href="#offsetWidth、offsetHeight" class="headerlink" title="offsetWidth、offsetHeight"></a>offsetWidth、offsetHeight</h4><p>offsetWidth、offsetHeight 返回自身包括padding、边框、内容的宽度&#x2F;高度，返回数值不带单位</p><p>当盒子没有宽度时，盒子随之浏览器窗口大小变化而变化，offsetWidth、offsetHeight可以动态的获取盒子的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.test &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 10px solid pink;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var test = document.querySelector(&#x27;.test&#x27;)</span><br><span class="line">    console.log(test.offsetWidth); // 140 offsetWidth = width + padding + border </span><br><span class="line">    console.log(test.offsetHeight); // 140</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h4><p>offsetParent 返回该元素带有定位的父元素，如果父元素没有定位，则返回body</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(son.offsetParent); // div class=&quot;father&quot;&gt;&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">console.log(son.parentNode);// </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>offsetParent 和 parentNode的区别：</p><ul><li>offsetParent：返回带有定位的父级，没有没有一直往上找，直到body</li><li>parentNode：不管有没有定位，返回其父级</li></ul><h4 id="offset-和-style-的区别"><a href="#offset-和-style-的区别" class="headerlink" title="offset 和 style 的区别"></a>offset 和 style 的区别</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=290&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=290&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><table><thead><tr><th>offset</th><th>style</th></tr></thead><tbody><tr><td>offset可得到任意样式表中的样式值</td><td>style只能得到行内样式表中的样式值</td></tr><tr><td>offset系列获得的数值没有单位</td><td>style.width 获得的时带单位的字符串</td></tr><tr><td>offsetWidth包含 padding + border + width</td><td>style.width 不包含padding + border</td></tr><tr><td>offsetWidth 等属性是只读属性，只能获取不能赋值（不能修改）</td><td>style.width 是可读写属性，可获取也可赋值修改</td></tr><tr><td>所以，想要获取元素大小位置：offset</td><td>所以：想要修改元素的值：style</td></tr></tbody></table><h4 id="鼠标在盒子内的坐标（案例）"><a href="#鼠标在盒子内的坐标（案例）" class="headerlink" title="鼠标在盒子内的坐标（案例）"></a>鼠标在盒子内的坐标（案例）</h4><p>案例分析：</p><p>1、在盒子内移动，得到鼠标距离盒子左右的距离（盒子添加mousemove鼠标移动事件）</p><p>2、首先，得到鼠标在页面中的坐标（e.pageX e.pageY）</p><p>3、其次，盒子在页面中的距离（box.offsetLeft box.offsetTop）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    box.addEventListener(&#x27;mousemove&#x27;, function (e) &#123;</span><br><span class="line">        var x = e.pageX - this.offsetLeft;</span><br><span class="line">        var y = e.pageY - this.offsetTop;</span><br><span class="line">        console.log(box.offsetLeft, box.offsetTop);</span><br><span class="line">        box.innerHTML = &#x27;x坐标是：&#x27; + x + &#x27;y坐标是：&#x27; + y</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="拖拉拽（案例）"><a href="#拖拉拽（案例）" class="headerlink" title="拖拉拽（案例）"></a>拖拉拽（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=293" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=293">www.bilibili.com/video/BV1Sy…</a></p><p>拖拉拽的原理：鼠标按下（mousedown） + 鼠标移动（mousemove） + 松开鼠标（mouseup）</p><p>案例分析：</p><p>1、拖拉拽过程：鼠标移动过程中，获得最新的值，再赋值给盒子的left和top值，div就可以跟着鼠标移动</p><p>2、鼠标在页面的坐标 - 鼠标在盒子内的坐标 &#x3D; 盒子移动时的坐标</p><p>3、鼠标按下：得到鼠标在盒子中的坐标</p><p>4、鼠标移动：盒子的坐标 &#x3D; 鼠标坐标 - 盒子坐标 。注意移动事件要写在鼠标按下的事件里面</p><p>5、鼠标松开：停止拖拽，解除鼠标移动事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    // 1.当鼠标按下，获取鼠标再盒子内的坐标</span><br><span class="line">    box.addEventListener(&#x27;mousedown&#x27;, (e) =&gt; &#123;</span><br><span class="line">        // 鼠标在盒子内的坐标 = 鼠标在页面中的坐标 - 盒子在页面中的坐标</span><br><span class="line">        var x = e.pageX - box.offsetLeft;</span><br><span class="line">        var y = e.pageY - box.offsetTop;</span><br><span class="line">        console.log(e.pageX, e.pageY, box.offsetLeft, box.offsetTop);</span><br><span class="line">        // 2.鼠标移动的时候，把鼠标在页面中的坐标，减去鼠标在盒子内的坐标，得到盒子的left和top值</span><br><span class="line">        document.addEventListener(&#x27;mousemove&#x27;, move)</span><br><span class="line">        function move(e) &#123;</span><br><span class="line">            box.style.left = e.pageX - x + &#x27;px&#x27;;</span><br><span class="line">            box.style.top = e.pageY - y + &#x27;px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.鼠标松开，移除鼠标移动事件</span><br><span class="line">        document.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123;</span><br><span class="line">            document.removeEventListener(&#x27;mousemove&#x27;, move)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="放大镜效果（案例）"><a href="#放大镜效果（案例）" class="headerlink" title="放大镜效果（案例）"></a>放大镜效果（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=297" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=297">www.bilibili.com/video/BV1Sy…</a></p><ul><li>整个案例分为三个模块</li><li>鼠标经过小图片盒子，黄色遮挡层和大图片盒子显示；鼠标离开两个盒子隐藏<ul><li>鼠标经过：mouseover</li><li>鼠标离开：mouseout</li><li>显示隐藏：display:block display:none</li></ul></li><li>黄色的遮挡层跟随鼠标移动<ul><li>把鼠标坐标给遮挡曾不合适，因为遮挡层的坐标以父盒子为准</li><li>首先，获得鼠标在盒子的坐标</li><li>其次，把数值给遮挡层的 left 和 top 值</li><li>此时，用到鼠标移动事件，但是还是在小图片盒子内移动</li><li>为了使鼠标在遮罩层的中间，需要减去遮罩层宽高的一半 offsetWidth、offsetHeight获取盒子的宽高</li><li>遮挡层不能超过小盒子的范围（如果小于0，就把坐标设置为0）</li><li>遮挡层最大的移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</li></ul></li><li>移动黄色遮挡层，大图片跟随移动<ul><li>求大图片移动的公式：大图片移动距离 &#x3D; 遮挡层移动的距离 * 大图片最大移动距离 &#x2F; 遮挡层最大移动距离</li><li><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=299" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=299">www.bilibili.com/video/BV1Sy…</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .box &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 502px;</span><br><span class="line">        height: 285px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .mask &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        background-color: rgb(235, 238, 82, 0.4);</span><br><span class="line">        /* 鼠标经过变成移动的样式 */</span><br><span class="line">        cursor: move;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .enlarge &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 510px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 285px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .enlarge img &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./img/大数据热点图.jpg&quot; alt=&quot;&quot; class=&quot;img1&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;enlarge&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;./img/大数据热点图.jpg&quot; alt=&quot;&quot; class=&quot;img2&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    var mask = document.querySelector(&#x27;.mask&#x27;);</span><br><span class="line">    var enlarge = document.querySelector(&#x27;.enlarge&#x27;);</span><br><span class="line">    var img1 = document.querySelector(&#x27;.img1&#x27;);</span><br><span class="line"></span><br><span class="line">    // 鼠标经过显示遮罩层和大图片盒子</span><br><span class="line">    box.addEventListener(&#x27;mouseover&#x27;, () =&gt; &#123;</span><br><span class="line">        mask.style.display = &#x27;block&#x27;;</span><br><span class="line">        enlarge.style.display = &#x27;block&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 鼠标经过隐藏遮罩层和大图片盒子</span><br><span class="line">    box.addEventListener(&#x27;mouseout&#x27;, () =&gt; &#123;</span><br><span class="line">        mask.style.display = &#x27;none&#x27;;</span><br><span class="line">        enlarge.style.display = &#x27;none&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">    // </span><br><span class="line">    box.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123;</span><br><span class="line">        // 先计算出鼠标在盒子内的坐标</span><br><span class="line">        var x = e.pageX - box.offsetLeft;</span><br><span class="line">        var y = e.pageY - box.offsetTop;</span><br><span class="line">        // console.log(x,y);</span><br><span class="line"></span><br><span class="line">        // 把鼠标在盒子内的坐标赋值给遮罩层的left和top值</span><br><span class="line">        // 为了使鼠标在遮罩层的中间，需要减去遮罩层宽高的一半 offsetWidth、offsetHeight获取盒子的宽高</span><br><span class="line">        var maskX = x - mask.offsetWidth / 2;</span><br><span class="line">        var maskY = y - mask.offsetHeight / 2</span><br><span class="line"></span><br><span class="line">        // 遮挡层最大的移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</span><br><span class="line">        var maskXMax = box.offsetWidth - mask.offsetWidth;</span><br><span class="line">        var maskYMax = box.offsetHeight - mask.offsetHeight;</span><br><span class="line">        // console.log(maskXMax, maskYMax);</span><br><span class="line">        if (maskX &lt; 0) &#123;</span><br><span class="line">            maskX = 0</span><br><span class="line">        &#125; else if (maskX &gt;= maskXMax) &#123;</span><br><span class="line">            maskX = maskXMax</span><br><span class="line">        &#125;</span><br><span class="line">        if (maskY &lt; 0) &#123;</span><br><span class="line">            maskY = 0</span><br><span class="line">        &#125; else if (maskY &gt;= maskYMax) &#123;</span><br><span class="line">            maskY = maskYMax</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mask.style.left = maskX + &#x27;px&#x27;;</span><br><span class="line">        mask.style.top = maskY + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">        // 大图片移动距离 = 遮挡层移动的距离 * 大图片最大移动距离 / 遮挡层最大移动距离</span><br><span class="line">        // 大图</span><br><span class="line">        var img2 = document.querySelector(&#x27;.img2&#x27;);</span><br><span class="line">        // 大图片最大移动的距离</span><br><span class="line">        var enlargeMax = img2.offsetWidth - enlarge.offsetWidth;</span><br><span class="line">        // 大突破的移动距离</span><br><span class="line">        var enlargeX = maskX * enlargeMax / maskXMax;</span><br><span class="line">        var enlargeY = maskY * enlargeMax / maskYMax;</span><br><span class="line">        img2.style.left = -enlargeX + &#x27;px&#x27;;</span><br><span class="line">        img2.style.top = -enlargeY + &#x27;px&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h3><p>client 就是客户端，client 系列的相关属性来获取元素可视区的相关信息。</p><p>通过client系列的相关属性可动态的得到该元素的边框大小、元素大小等</p><table><thead><tr><th>client系列</th><th>说明</th></tr></thead><tbody><tr><td>element.clientTop</td><td>返回元素上边框的大小</td></tr><tr><td>element.clientLeft</td><td>返回元素左边框的大小</td></tr><tr><td>element.clientWidth</td><td>返回自身包括padding、内容的宽度，不含边框，返回的数值不带单位</td></tr><tr><td>element.clientHeight</td><td>返回自身包括padding、内容的高度，不含边框，返回的数值不带单位</td></tr></tbody></table><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>立即执行函数：不需要调用，立马能够自己执行的函数，也可以传递参数</p><p>立即执行函数最大的作用：独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突的情况</p><p>两种写法语法：</p><ul><li>(function(){})()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">   console.log(2) // 2</span><br><span class="line">&#125;)(); // 第二个小括号可看做是调用该函数</span><br><span class="line"></span><br><span class="line">(function(a)&#123;</span><br><span class="line">   console.log(a); // 1</span><br><span class="line">&#125;)(1); // 也可以传参</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>(function(){}())</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    console.log(3); // 3</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(function sum(a) &#123; // 函数有名字也不影响</span><br><span class="line">    console.log(a); // 4</span><br><span class="line">&#125;(3));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h3><p>scroll：滚动事件，使用scroll系列的相关属性可动态的得到该元素的大小、滚动的距离等</p><table><thead><tr><th>scroll系列属性</th><th>说明（返回数值都不带单位）</th></tr></thead><tbody><tr><td>element.scrollTop</td><td>返回被卷去的上册距离</td></tr><tr><td>element.scrollLeft</td><td>返回被卷去的左侧距离</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框</td></tr><tr><td>element.scrollHeight</td><td>返回自身实际的高度，不含边框</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        overflow: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">// scroll 滚动事件，当滚动条发生变化时，会触发该事件</span><br><span class="line">    div.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123;</span><br><span class="line">        console.log(div.scrollTop);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="offset、client、scroll总结"><a href="#offset、client、scroll总结" class="headerlink" title="offset、client、scroll总结"></a>offset、client、scroll总结</h3><p>三个系列都可返回元素的大小，返回值都不带单位</p><table><thead><tr><th>三个系列大小对比</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetWidth</td><td>返回自身包括padding、边框、内容区的宽度</td></tr><tr><td>element.clientWidth</td><td>返回自身包括padding、内容区的库纳杜</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框（包含了文字超出的部分）</td></tr></tbody></table><p>区别：</p><ul><li>offsetWidth 包含了边框</li><li>clientWidth 值返回元素的高度，但是如果元素内容超过了盒子的大小，则用scrollWidth可得到超出</li></ul><p>三个系列的主要用法：</p><ul><li><strong>offset系列</strong>常用于获取元素位置（ <strong>offsetLeft、offsetTop</strong> ）</li><li><strong>client系列</strong>常用于获取元素大小（ <strong>clientWidth、clientHeight</strong> ）</li><li><strong>scroll系列</strong>常用于获取滚动距离（ <strong>scrollTop、scrollLeft</strong> ）</li></ul><p>注意：页面滚动距离通过window.pageXOffset获得</p><h3 id="mouseenter-和-mouseover区别（面试题）"><a href="#mouseenter-和-mouseover区别（面试题）" class="headerlink" title="mouseenter 和 mouseover区别（面试题）"></a>mouseenter 和 mouseover区别（面试题）</h3><p>mouseenter 和 mouseover都是鼠标移动到元素上会触发的事件</p><p>区别：</p><ul><li>mouseenter 鼠标经过只有自身盒子触发，不会冒泡</li><li>mousrover 鼠标经过自身盒子会触发，经过子盒子也会触发</li><li>跟mouseenter搭配鼠标离开mouseleave同样不会冒泡</li></ul><h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p>核心原理：通过定时器setInterval()不断移动盒子位置</p><h4 id="盒子移动动画（案例）"><a href="#盒子移动动画（案例）" class="headerlink" title="盒子移动动画（案例）"></a>盒子移动动画（案例）</h4><p>案例分析：</p><ul><li>获取盒子当前位置</li><li>让盒子在当前位置上加上一个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位，才能使用element.style.left</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">    var timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // window.innerWidth 当前设备的宽度</span><br><span class="line">        if (box.offsetLeft &gt;= window.innerWidth) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            // clearInterval(timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            box.style.left = 0</span><br><span class="line">        &#125;</span><br><span class="line">        box.style.left = box.offsetLeft + 5 + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="动画效果封装"><a href="#动画效果封装" class="headerlink" title="动画效果封装"></a>动画效果封装</h4><p>此方法需要传递两个参数：动画的对象、目标位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 动画的对象obj, 目标位置target</span><br><span class="line">function animate(obj, target) &#123;</span><br><span class="line">    var timer = setInterval(() =&gt; &#123;</span><br><span class="line">        if (obj.offsetLeft &gt;= target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            // clearInterval(timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            obj.style.left = 0</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left = obj.offsetLeft + 5 + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br><span class="line">animate(box, window.innerWidth)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优化方案：<a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=311" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=311">www.bilibili.com/video/BV1Sy…</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 优化</span><br><span class="line">function animate(obj, target, callback) &#123;</span><br><span class="line">    // 如果需要某个条件才动画，比如点击按钮动画执行，需要先清除一次定时器，</span><br><span class="line">    // 以防按钮不断点击，元素移动的速度越来越快，因为开启了太多的定时器</span><br><span class="line">    // clearInterval(obj.timer); // 先清除以前的定时器，只保留当前的一个定时器</span><br><span class="line">    obj.timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // 步长写在定时器里面</span><br><span class="line">        // 把步长值改为整数,不要出现小数的问题</span><br><span class="line">        // var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br><span class="line">        var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line"></span><br><span class="line">        if (obj.offsetLeft == target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            // obj.style.left = 0</span><br><span class="line"></span><br><span class="line">            // 回调函数写在定时器里面</span><br><span class="line">            if (callback) &#123;</span><br><span class="line">                // 调用传递进来的回调函数</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把每次加1 这个步长值改为一个慢慢变小的值,步长公式:(目标值 - 现在的位置) / 10</span><br><span class="line">        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br><span class="line">animate(box, 500, function () &#123;</span><br><span class="line">    // 动画执行完毕后,执行回调函数, 此处代码调用</span><br><span class="line">    box.style.backgroundColor = &#x27;blue&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="常见网页特效案例"><a href="#常见网页特效案例" class="headerlink" title="常见网页特效案例"></a>常见网页特效案例</h3><h4 id="banner轮播"><a href="#banner轮播" class="headerlink" title="banner轮播"></a>banner轮播</h4><p>案例分析：</p><ul><li>鼠标经过（mouseover、mouseenter）轮播模块，左右按钮显示，鼠标离开（mouseout、mouseleave）左右按钮隐藏<ul><li>mouseover 鼠标经过自身盒子会触发，经过子盒子也会触发 ，对应mouseout</li><li>mouseenter 鼠标经过只有自身盒子触发，不会冒泡，对应mouseleave</li><li>显示隐藏按钮display</li></ul></li><li>动态生成导航小圆点<ul><li>核心思路：导航小圆点要跟图片张数一致</li><li>先得到ul里面图片的张数（图片放在li里面，li的个数也就是图片的个数）ul.children.length</li><li>循环动态生成小圆圈（小圆圈放在ol里面）</li><li>创建节点createElemeny(‘li’)</li><li>插入节点 ol.appendChild(li)</li><li>把ol里面的第一个li设置类名为current：表示选中的效果以及表示展示的是第一张图片 ol.children[0].className &#x3D; ‘current’</li><li>给导航小圆点添加点击事件：<strong>排他思想</strong> 干掉其他的li，留下当前点击的li</li></ul></li><li>点击右侧按钮播放下一张图片原理： 点击右侧按钮一次，图片往左播放一张，以此类推。左侧按钮同理<ul><li>声明一个变量num，点击一次，自增1，让这个变量 乘以 图片宽度，就是ul的滚动距离</li><li>图片无缝滚动原理（滚动到最后一张，循环滚动）：把ul第一个li复制一份放到ul的最后面，当图片滚动到复制的最后一张时，让ul快速的，不做动画的跳到最左侧：left为0</li><li>同时num赋值为0，重新开始滚动图片</li></ul></li><li>图片播放的同时，导航小圆点跟随一起变化<ul><li>简单的做法：声明一个变量cricle，每次点击自增1。注意：左侧按钮也需要这个变量，因为要声明全局变量</li><li>但是因为前面克隆了一张图片，现在图片多了一张，而小圆点的个数是之前图片的数量，所以必须加一个判断条件</li><li>如果cricle &#x3D;&#x3D; 之前图片的数量，就重新复原为cricle &#x3D; 0</li></ul></li><li>点击导航小圆点，播放相应的图片<ul><li>点击导航小圆点是ul在移动，而不是ul里面的li（要提前给ul加定位）</li><li>滚动图片的核心算法：点击某个小圆点，就让图片滚动，<strong>导航小圆点的索引号乘以图片的宽度</strong>作为ul移动的距离</li></ul></li><li>鼠标不经过轮播图，轮播图也会自动轮播图片<ul><li>定时器</li><li>自动播放轮播图，实际上类似点击了右侧按钮</li><li>此时使用手动调用右侧按钮点击事件 next.click()</li><li>鼠标经过banner，停止定时器</li><li>鼠标离开banner，开启定时器</li></ul></li></ul><h4 id="带有动画的返回顶部"><a href="#带有动画的返回顶部" class="headerlink" title="带有动画的返回顶部"></a>带有动画的返回顶部</h4><p>滚动窗口至文档中的特定位置：window.scroll(x,y)</p><p>页面滚动了多少：window.pageYOffset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventlistener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">    // 里面的x,y不跟单位，直接写数字即可</span><br><span class="line">// window.scroll(0, 0)</span><br><span class="line">    animate(window, 0); // 因为是窗口滚动，所以对象是window</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function animate(obj, target, callback) &#123;</span><br><span class="line">    // 如果需要某个条件才动画，比如点击按钮动画执行，需要先清除一次定时器，</span><br><span class="line">    // 以防按钮不断点击，元素移动的速度越来越快，因为开启了太多的定时器</span><br><span class="line">    clearInterval(obj.timer); // 先清除以前的定时器，只保留当前的一个定时器</span><br><span class="line">    obj.timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // 步长写在定时器里面</span><br><span class="line">        // 把步长值改为整数,不要出现小数的问题</span><br><span class="line">        // var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br><span class="line">        var step = (target - window.pageYOffset) / 10;</span><br><span class="line">        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line"></span><br><span class="line">        if (window.pageYOffset == target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            // obj.style.left = 0</span><br><span class="line"></span><br><span class="line">            // 回调函数写在定时器里面</span><br><span class="line">            // if (callback) &#123;</span><br><span class="line">            //     // 调用传递进来的回调函数</span><br><span class="line">            //     callback();</span><br><span class="line">            // &#125;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">        // 把每次加1 这个步长值改为一个慢慢变小的值,步长公式:(目标值 - 现在的位置) / 10</span><br><span class="line">        // obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">        window.scroll(0,window.pageYOffset + step)</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PC端网页特效&quot;&gt;&lt;a href=&quot;#PC端网页特效&quot; class=&quot;headerlink&quot; title=&quot;PC端网页特效&quot;&gt;&lt;/a&gt;PC端网页特效&lt;/h2&gt;&lt;h3 id=&quot;元素偏移量-offset系列&quot;&gt;&lt;a href=&quot;#元素偏移量-offset系列&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS高级事件</title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/JS%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/JS%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-08-01T13:21:32.927Z</published>
    <updated>2022-08-16T03:35:12.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="注册（绑定）事件的方式"><a href="#注册（绑定）事件的方式" class="headerlink" title="注册（绑定）事件的方式"></a>注册（绑定）事件的方式</h3><p>给元素添加事件，称为<strong>注册事件</strong>或者<strong>绑定事件</strong></p><p>注册事件的两种方式：</p><ul><li>传统的方式</li><li>方法监听注册方式</li></ul><h4 id="传统注册方式"><a href="#传统注册方式" class="headerlink" title="传统注册方式"></a>传统注册方式</h4><p>传统注册方式：</p><ul><li>利用on开头的事件 onclick</li><li><code>&lt;button onclick=&#39;alert(&#39;99&#39;)&#39;&gt;&lt;/button&gt;</code></li><li><code>btn.onclick = function()&#123;&#125;</code></li><li>特点：注册事件的唯一性</li><li>同一个元素同一个事件只能设置一个处理函数，后面注册的处理函数会覆盖前面注册的处理函数</li></ul><h4 id="方法监听注册方式"><a href="#方法监听注册方式" class="headerlink" title="方法监听注册方式"></a>方法监听注册方式</h4><p>方法监听注册方式：</p><ul><li>W3C标准 推荐方式</li><li><strong>addEventListener()</strong> 方法</li><li>IE9之前的IE不支持此方法，可用attachEvent() （不提倡用此方法）代替</li><li>特点：<strong>同一个元素同一个事件可注册（绑定）多个监听器（处理函数function(){}）</strong></li><li>按照绑定的顺序依次执行</li></ul><h4 id="addEventListener-事件监听方式"><a href="#addEventListener-事件监听方式" class="headerlink" title="addEventListener 事件监听方式"></a>addEventListener 事件监听方式</h4><p>语法：<code>eventTarget.addEventListener(type, listener[, useCapture])</code> 将指定的监听器绑定到eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数：</p><ul><li>type：事件类型字符串（要加引号）。比如：click、mouseover等，注意这里不需要带on</li><li>listener：事件处理函数，事件发生时，会调用该函数</li><li>useCapture：是否阻止冒泡，可选参数，布尔值，默认是false</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="删除事件（事件解绑）"><a href="#删除事件（事件解绑）" class="headerlink" title="删除事件（事件解绑）"></a>删除事件（事件解绑）</h3><h4 id="传统注册事件的事件解绑"><a href="#传统注册事件的事件解绑" class="headerlink" title="传统注册事件的事件解绑"></a>传统注册事件的事件解绑</h4><p>传统注册事件的事件解绑：<code>eventTarget.onclick = null;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 示例 只能点击一次，点完第一次 btn.onclick = null  事件解绑</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">    btn.onclick = null</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="方法监听注册方式-1"><a href="#方法监听注册方式-1" class="headerlink" title="方法监听注册方式"></a>方法监听注册方式</h4><p>方法监听注册方式：<code>eventTarget.removeEventListener(type, listener[, useCapture])</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, fn) // 里面的fn  调用不需要加 小括号</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">    btn.removeEventListener(&#x27;click&#x27;, fn)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：removeEventListener 方法解除事件绑定，必须告诉他解除哪个处理函数，前面绑定的函数可单独写出来</p><h3 id="DOM事件流（重要）"><a href="#DOM事件流（重要）" class="headerlink" title="DOM事件流（重要）"></a>DOM事件流（重要）</h3><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=252&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=252&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><p>事件流：描述的是从页面中接收事件的顺序</p><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播的过程称为 <strong>DOM事件流</strong> （ <strong>DOM事件流：事件传播的过程</strong> ）</p><p>DOM事件流分为三个阶段：</p><ul><li>捕获阶段：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程</li><li>当前目标阶段</li><li>冒泡阶段：IE最早提出，事件开始时由具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程</li></ul><p>注意：</p><ul><li>JS代码中，只能执行捕获或者冒泡其中的一个阶段</li><li>onclick、attachEvent只能得到冒泡阶段</li><li>addEventListener(type, listener[, useCapture]) 第三个参数如果是true，表示事件捕获阶段调用事件处理程序；如果是false（不写默认是false），表示事件冒泡阶段调用事件处理程序</li><li>在实际开发中，很少使用事件捕获，更关注事件冒泡</li><li>有些事件是没有冒泡的。比如：onblur、onfocus、onmouseenter、onmouseleave</li></ul><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function (event) &#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function(event)&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>event 就是一个事件对象，写在侦听函数的小括号里面，当形参来看</li><li>事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数</li><li>事件对象：是事件的一系列相关数据的集合，跟事件相关的。比如：鼠标点击，里面包含了鼠标的相关信息（鼠标坐标等）；如果是键盘事件，里面则包含的是键盘事件相关的信息（比如判断用户按下了哪个键）</li><li>事件对象简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放在这个对象里面，这个对象就是事件对象event，它有很多属性和方法</li><li>事件对象可自己命名。比如：event、evt、e（常用）</li><li>事件对象由兼容性问题。IE6&#x2F;7&#x2F;8通过window.event</li></ul><p>事件对象兼容性写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function (e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h3><p>e.target 返回的是触发事件的对象（元素）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;123&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    console.log(e.target); // &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    console.log(this);// &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>e.target 返回的是触发事件的对象（元素），this返回的是绑定事件的对象（元素）</li><li>e.target 点击了哪个元素，就返回哪个元素；this 哪个元素绑定了，就返回哪个元素</li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>组织默认行为，比如：让链接不跳转，让提交按钮不提交</p><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=255&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=255&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡：事件开始时由具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程</p><p>阻止事件冒泡：</p><ul><li>标准写法（推荐）：利用事件对象里面stopPropagation()方法</li><li>非标准写法：IE6-8 利用事件对象cancelBubble属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    e.stopPropagation(); // 阻止事件冒泡</span><br><span class="line">    e.cancelBubble = true // 阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h3><p><strong>事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点</strong></p><p>事件委托的作用：只操作一次DOM，提高了程序的性能</p><p>下面案例：给ul绑定点击事件，然后利用事件对象的target来找到当前所点击的li，因为点击li，事件会冒泡到ul上，ul有注册事件，就会触发事件监听器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">ul.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    // alert(&#x27;弹框~~&#x27;);</span><br><span class="line">    // e.target 可得到点击的对象</span><br><span class="line">    console.log(e.target);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p>获取鼠标在页面中的坐标</p><p>event对象代表事件的状态，跟事件相关的一系列信息的集合。</p><p>鼠标事件：MouseEvent</p><h4 id="获取鼠标的坐标"><a href="#获取鼠标的坐标" class="headerlink" title="获取鼠标的坐标"></a>获取鼠标的坐标</h4><table><thead><tr><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr><td>e.clientX</td><td>返回鼠标相对于浏览器窗口可视区的x坐标</td></tr><tr><td>e.clientY</td><td>返回鼠标相对于浏览器窗口可视区的y坐标</td></tr><tr><td>e.pageX</td><td>返回鼠标相对于文档页面的x坐标 IE9+支持</td></tr><tr><td>e.pageY</td><td>返回鼠标相对于文档页面的y坐标 IE9+支持</td></tr><tr><td>e.screenX</td><td>返回鼠标相对于电脑屏幕的X坐标</td></tr><tr><td>e.screenY</td><td>返回鼠标相对于电脑屏幕的y坐标</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">document.addEventListener(&#x27;click&#x27;, function(e)&#123;</span><br><span class="line">    // 1.client 鼠标在可视区的x和y坐标</span><br><span class="line">    console.log(e.clientX);</span><br><span class="line">    console.log(e.clientY);</span><br><span class="line">    // 2.page 鼠标在页面文档的x和y坐标</span><br><span class="line">    console.log(e.pageX);</span><br><span class="line">    console.log(e.pageY);</span><br><span class="line">    // 3.screen 鼠标在电脑屏幕的x和y坐标</span><br><span class="line">    console.log(e.screenX);</span><br><span class="line">    console.log(e.screenY);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="跟随鼠标移动的div（案例）"><a href="#跟随鼠标移动的div（案例）" class="headerlink" title="跟随鼠标移动的div（案例）"></a>跟随鼠标移动的div（案例）</h4><p>案例分析：</p><p>1、鼠标不断的移动，使用鼠标移动事件：mousemove</p><p>2、在页面中移动，给document注册事件</p><p>3、div要移动距离，而且不占位置，使用绝对定位即可</p><p>4、核心原理：每次鼠标移动，都会获得最新的鼠标坐标，把这个x和y坐标作为图片的top和left值就可移动图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// mousemove 只要鼠标移动1px，就会触发这个事件</span><br><span class="line">document.addEventListener(&#x27;mousemove&#x27;, function (e) &#123;</span><br><span class="line">    // e.pageX e.pageY 鼠标在页面文档的x和y坐标</span><br><span class="line">    var x = e.pageX;</span><br><span class="line">    var y = e.pageY;</span><br><span class="line">    // console.log(x, y);</span><br><span class="line">    // 拼接单位px</span><br><span class="line">    div.style.left = x - 50 + &#x27;px&#x27;;</span><br><span class="line">    div.style.top = y - 50 + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="keyup、keydown、keypress"><a href="#keyup、keydown、keypress" class="headerlink" title="keyup、keydown、keypress"></a>keyup、keydown、keypress</h4><table><thead><tr><th>键盘事件</th><th>说明</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键被松开时触发</td></tr><tr><td>onkeydown</td><td>某个键盘按键被按下时触发</td></tr><tr><td>onkeypress</td><td>某个键盘按键被按下时触发，但是不识别功能键，比如ctrl、shift、箭头等</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">document.addEventListener(&#x27;keyup&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;弹起~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keydown&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按下~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keypress&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按下keypress~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>传统方式需要加on，addEventListener不需要加on</li><li>onkeypress和前两个的区别是：不识别功能键。比如ctrl、左右箭头、shift等</li><li>三个执行顺序：keydown -&gt; keypress -&gt; keyup</li></ul><h4 id="keyCode判断用户按下哪个键"><a href="#keyCode判断用户按下哪个键" class="headerlink" title="keyCode判断用户按下哪个键"></a>keyCode判断用户按下哪个键</h4><p>键盘事件对象中的keyCode属性可用得到相应键的ASCII码值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;keyup&#x27;, function (e) &#123;</span><br><span class="line"> console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keydown&#x27;, function (e) &#123;</span><br><span class="line">    console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keypress&#x27;, function (e) &#123;</span><br><span class="line">   console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>keyup 和 keydown事件不区分大小写，a 和 A 得到的ASCII码值都是65</li><li>keypress 事件区分大小写，a 97 ，A 65</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件高级&quot;&gt;&lt;a href=&quot;#事件高级&quot; class=&quot;headerlink&quot; title=&quot;事件高级&quot;&gt;&lt;/a&gt;事件高级&lt;/h2&gt;&lt;h3 id=&quot;注册（绑定）事件的方式&quot;&gt;&lt;a href=&quot;#注册（绑定）事件的方式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JS" scheme="https://superq314.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/advancedObjects/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/advancedObjects/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-08-01T07:32:31.020Z</published>
    <updated>2022-08-01T07:32:31.020Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/function/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/function/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2022-08-01T07:16:38.123Z</published>
    <updated>2022-08-01T07:16:47.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p>&#x2F;&#x2F; 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line">  args = args || [];</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">      // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// es6 实现</span><br><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/42" title="https://github.com/mqyqingfeng/Blog/issues/42">《**JavaScript **专题之函数柯里化》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数柯里化的实现&quot;&gt;&lt;a href=&quot;#函数柯里化的实现&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化的实现&quot;&gt;&lt;/a&gt;函数柯里化的实现&lt;/h3&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/dataType/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/dataType/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-01T07:02:59.807Z</published>
    <updated>2022-08-01T07:03:36.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型的判断方法——typeof，instanceof，constructor，Object-prototype-toString-call"><a href="#数据类型的判断方法——typeof，instanceof，constructor，Object-prototype-toString-call" class="headerlink" title="数据类型的判断方法——typeof，instanceof，constructor，Object.prototype.toString.call()"></a>数据类型的判断方法——typeof，instanceof，constructor，Object.prototype.toString.call()</h3><h4 id="typeof-可用于判断基本数据类型"><a href="#typeof-可用于判断基本数据类型" class="headerlink" title="typeof 可用于判断基本数据类型"></a>typeof 可用于判断<strong>基本数据类型</strong></h4><p>对于原始数据类型来说，除了null都可以显示正确的类型</p><ul><li>对于null，返回object<blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null 的数据类型被 typeof 解释为object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure></blockquote></li><li>除了function以外的引用类型，都会返回object</li></ul><h4 id="instanceof-可用于判断引用数据类型"><a href="#instanceof-可用于判断引用数据类型" class="headerlink" title="instanceof 可用于判断引用数据类型"></a>instanceof 可用于判断<strong>引用数据类型</strong></h4><p>因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><p>instanceof实现原理</p><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><p>实现 instanceof：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.proto</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false  </span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true  </span><br><span class="line">    left = left.proto</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注：如果创建了一个对象，并更改它的原型，<strong>constructor</strong>就无法做出准确的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><p>使用 <code>Object</code> 对象的原型方法 <code>toString</code> ，使用 <code>call</code> 进行狸猫换太子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据类型的判断方法——typeof，instanceof，constructor，Object-prototype-toString-call&quot;&gt;&lt;a href=&quot;#数据类型的判断方法——typeof，instanceof，constructor，Object-p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/08/01/frontEnd/JavaScript/dataType/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <id>https://superq314.github.io/2022/08/01/frontEnd/JavaScript/dataType/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F/</id>
    <published>2022-08-01T07:02:30.519Z</published>
    <updated>2022-08-01T07:03:18.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型的转换方式"><a href="#数据类型的转换方式" class="headerlink" title="数据类型的转换方式"></a>数据类型的转换方式</h3><p>在 JS 中，类型转换只有三种情况，分别是：</p><ul><li><p>转换为布尔值</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Boolean()</td><td>其他类型转换成布尔值</td><td>Boolean(‘true’)</td></tr></tbody></table></li></ul></li><li><p>转换为数值型</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>parseInt(string)</td><td>将string型转换成整型数值型</td><td>parseInt(‘28’)</td></tr><tr><td>parseFloat(string)</td><td>将string型转换成浮点数数值型</td><td>parseFloat(‘28.12’)</td></tr><tr><td>Number()强制转换</td><td>将string型转换成数值型</td><td>Number(‘12’)</td></tr><tr><td>js隐式转换 （- * &#x2F;）</td><td>利用算术运算隐式转换为数值型</td><td>‘12’ - 0</td></tr></tbody></table></li></ul></li><li><p>转换为字符串</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>.toString()</td><td>转换成字符串</td><td>var num&#x3D;1; alert(num.toString());</td></tr><tr><td>String()</td><td>转换成字符串（强制转换）</td><td>var num&#x3D;1; alert(String(num));</td></tr><tr><td>加号拼接字符串</td><td>任意类型和字符串拼接结果都是字符串</td><td>var num&#x3D;1; alert(num + ‘字符串’)</td></tr></tbody></table></li><li><code>null</code>和 <code>underfined</code>没有 <code>.toString</code>方法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据类型的转换方式&quot;&gt;&lt;a href=&quot;#数据类型的转换方式&quot; class=&quot;headerlink&quot; title=&quot;数据类型的转换方式&quot;&gt;&lt;/a&gt;数据类型的转换方式&lt;/h3&gt;&lt;p&gt;在 JS 中，类型转换只有三种情况，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;转换为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES8新特性</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-31T09:42:29.243Z</published>
    <updated>2022-08-10T04:15:25.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>async 函数的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;&#125;</span><br></pre></td></tr></table></figure><p>async 函数的返回值：</p><p>返回的结果不是一个 Promise 类型的对象，返回的结果就是成功 Promise 对象<br>返回的结果如果是一个 Promise 对象，具体需要看执行resolve方法还是reject方法<br>抛出错误，返回的结果是一个失败的 Promise<br>async 函数的演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//async 函数</span><br><span class="line">async function fn() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(&#x27;成功的数据&#x27;);</span><br><span class="line">        // reject(&quot;失败的错误&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;const result = fn();//调用 then 方法</span><br><span class="line">result.then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h2><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><p>await 表达式的注意事项：</p><p>await 必须写在 async 函数中<br>await 右侧的表达式一般为 promise 对象<br>await 返回的是 promise 成功的值<br>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理<br>await 表达式的语法演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建 promise 对象</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;用户数据&quot;);</span><br><span class="line">    //reject(&quot;失败啦!&quot;);</span><br><span class="line">&#125;)//await 要放在 async 函数中.</span><br><span class="line">async function fun() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        let result = await p;</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//调用函数</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure><p>await 表达式的案例演示：async与await封装AJAX请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 发送 AJAX 请求, 返回的结果是 Promise 对象</span><br><span class="line">function sendAJAX(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        //1. 创建对象</span><br><span class="line">        const x = new XMLHttpRequest();</span><br><span class="line">        //2. 初始化</span><br><span class="line">        x.open(&#x27;GET&#x27;, url);</span><br><span class="line">        //3. 发送</span><br><span class="line">        x.send();</span><br><span class="line">        //4. 事件绑定</span><br><span class="line">        x.onreadystatechange = function () &#123;</span><br><span class="line">            if (x.readyState === 4) &#123;</span><br><span class="line">                if (x.status &gt;= 200 &amp;&amp; x.status &lt; 300) &#123;</span><br><span class="line">                    resolve(x.response);//成功</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    reject(x.status);//失败</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;// async 与 await 测试</span><br><span class="line">async function fun() &#123;</span><br><span class="line">    //发送 AJAX 请求 1</span><br><span class="line">    let joke = await sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;);</span><br><span class="line">    //发送 AJAX 请求 2</span><br><span class="line">    let tianqi = await sendAJAX(&#x27;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#x27;)    console.log(joke);</span><br><span class="line">    console.error(tianqi);//为了区别数据，我这里用红色的error输出</span><br><span class="line">&#125;// 调用函数</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure><h2 id="对象方法拓展"><a href="#对象方法拓展" class="headerlink" title="对象方法拓展"></a>对象方法拓展</h2><p>Object.keys()方法返回一个给定对象的所有可枚举键值的数组<br>Object.values()方法返回一个给定对象的所有可枚举属性值的数组<br>Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//声明对象</span><br><span class="line">const person = &#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;;//获取对象所有的键</span><br><span class="line">console.log(Object.keys(person));</span><br><span class="line">//获取对象所有的值</span><br><span class="line">console.log(Object.values(person));</span><br><span class="line">//获取对象所有的键值对数组</span><br><span class="line">console.log(Object.entries(person));</span><br><span class="line">//创建 Map</span><br><span class="line">const m = new Map(Object.entries(person));</span><br><span class="line">console.log(m.get(&quot;name&quot;));</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors方法返回指定对象所有自身属性的描述对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//声明对象</span><br><span class="line">const person = &#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;;</span><br><span class="line">//对象属性的描述对象</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));//声明对象</span><br><span class="line">const obj = Object.create(null, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        //设置值</span><br><span class="line">        value: &quot;李四&quot;,</span><br><span class="line">        //属性特性</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        //设置值</span><br><span class="line">        value: 21,</span><br><span class="line">        //属性特性</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//对象属性的描述对象</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;async-函数&quot;&gt;&lt;a href=&quot;#async-函数&quot; class=&quot;headerlink&quot; title=&quot;async 函数&quot;&gt;&lt;/a&gt;async 函数&lt;/h2&gt;&lt;p&gt;async 函数的语法：&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="ES新特性" scheme="https://superq314.github.io/tags/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ES9新特性</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES9%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-31T09:42:27.851Z</published>
    <updated>2022-08-10T04:15:30.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象拓展"><a href="#对象拓展" class="headerlink" title="对象拓展"></a>对象拓展</h2><p>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p><h3 id="对象展开"><a href="#对象展开" class="headerlink" title="对象展开"></a>对象展开</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function connect(&#123;host, port, ...user&#125;) &#123;</span><br><span class="line">    console.log(host);</span><br><span class="line">    console.log(port);</span><br><span class="line">    console.log(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(&#123;</span><br><span class="line">    host: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    port: 3306,</span><br><span class="line">    username: &#x27;root&#x27;,</span><br><span class="line">    password: &#x27;root&#x27;,</span><br><span class="line">    type: &#x27;master&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象合并"><a href="#对象合并" class="headerlink" title="对象合并"></a>对象合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const skillOne = &#123;</span><br><span class="line">    q: &#x27;天音波&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const skillTwo = &#123;</span><br><span class="line">    w: &#x27;金钟罩&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const skillThree = &#123;</span><br><span class="line">    e: &#x27;天雷破&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const skillFour = &#123;</span><br><span class="line">    r: &#x27;猛龙摆尾&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const mangseng = &#123;...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;</span><br><span class="line">console.log(mangseng);</span><br></pre></td></tr></table></figure><h2 id="正则表达式拓展"><a href="#正则表达式拓展" class="headerlink" title="正则表达式拓展"></a>正则表达式拓展</h2><h3 id="命名捕获分组"><a href="#命名捕获分组" class="headerlink" title="命名捕获分组"></a>命名捕获分组</h3><p>ES9 允许命名捕获组使用符号 ?<code>&lt;name&gt;</code> ，这样获取捕获结果可读性更强。使用数组下标不好吗？的确不好，因为如果一旦你想要获取的元素一旦增加，数组下标就改变了，所以建议使用命名捕获分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;打开百度，你就知道！&lt;/a&gt;&#x27;;</span><br><span class="line">const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;</span><br><span class="line">const result = reg.exec(str);</span><br><span class="line">console.log(result.groups.url);</span><br><span class="line">console.log(result.groups.text);</span><br></pre></td></tr></table></figure><h3 id="正向断言"><a href="#正向断言" class="headerlink" title="正向断言"></a>正向断言</h3><p>ES9 支持正向断言，通过对匹配结果后面的内容进行判断，对匹配进行筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明字符串</span><br><span class="line">let str = &quot;订单编号开始123456789订单编号结束&quot;;</span><br><span class="line">//正向断言</span><br><span class="line">const reg = /\d+(?=订单编号结束)/;//也就是说数字的后边一定要跟着 订单编号结束</span><br><span class="line">const result = reg.exec(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h3 id="反向断言"><a href="#反向断言" class="headerlink" title="反向断言"></a>反向断言</h3><p>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明字符串</span><br><span class="line">let str = &quot;订单编号开始123456789订单编号结束&quot;;</span><br><span class="line">//正向断言</span><br><span class="line">const reg = /(?&lt;=订单编号开始)\d+/;//也就是说数字的前边一定要跟着 订单编号开始</span><br><span class="line">const result = reg.exec(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h3 id="dotAll模式"><a href="#dotAll模式" class="headerlink" title="dotAll模式"></a>dotAll模式</h3><p>正则表达式中点 . 匹配除回车外的任何单字符，标记 s 改变这种行为，允许行终止符出现，也就是dotAll模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let str = </span><br><span class="line">`&lt;ul&gt;</span><br><span class="line">     &lt;li&gt;</span><br><span class="line">         &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="line">         &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;</span><br><span class="line">         &lt;/li&gt;</span><br><span class="line">     &lt;li&gt;</span><br><span class="line">         &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="line">         &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;`;</span><br><span class="line"></span><br><span class="line">//声明正则</span><br><span class="line">const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;</span><br><span class="line"></span><br><span class="line">// 执行匹配</span><br><span class="line">let result;</span><br><span class="line">let data = [];</span><br><span class="line">while (result = reg.exec(str)) &#123;</span><br><span class="line">    data.push(&#123;title: result[1], time: result[2]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">console.log(data);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象拓展&quot;&gt;&lt;a href=&quot;#对象拓展&quot; class=&quot;headerlink&quot; title=&quot;对象拓展&quot;&gt;&lt;/a&gt;对象拓展&lt;/h2&gt;&lt;p&gt;Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="ES新特性" scheme="https://superq314.github.io/tags/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ES10新特性</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES10%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES10%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-31T09:42:25.957Z</published>
    <updated>2022-08-10T04:15:35.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象方法拓展"><a href="#对象方法拓展" class="headerlink" title="对象方法拓展"></a>对象方法拓展</h2><p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//ES6：Map</span><br><span class="line">//ES10：Object.fromEntries</span><br><span class="line">const m = new Map();</span><br><span class="line">m.set(&quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">m.set(&quot;age&quot;, 20);</span><br><span class="line">const result = Object.fromEntries(m);</span><br><span class="line">console.log(result);//ES8：Object.entries</span><br><span class="line">const arr = Object.entries(result);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h2 id="字符串方法拓展"><a href="#字符串方法拓展" class="headerlink" title="字符串方法拓展"></a>字符串方法拓展</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;   iloveyou   &quot;;</span><br><span class="line">console.log(str.trimStart());//只去除前边的空格</span><br><span class="line">console.log(str.trimEnd());//只去除后边的空格</span><br></pre></td></tr></table></figure><h2 id="数组方法拓展"><a href="#数组方法拓展" class="headerlink" title="数组方法拓展"></a>数组方法拓展</h2><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，说白了就是将多维数组转化为低维数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3, 4, [5, 6]];</span><br><span class="line">console.log(arr1.flat());</span><br><span class="line">const arr2 = [1, 2, 3, 4, [5, 6, [7, 8, 9]]];</span><br><span class="line">console.log(arr2.flat());</span><br><span class="line">console.log(arr2.flat(1));//参数为深度是一个数字</span><br><span class="line">console.log(arr2.flat(2));//参数为深度是一个数字</span><br></pre></td></tr></table></figure><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4];</span><br><span class="line">console.log(arr1.map(x =&gt; x * 2));var arr2 = [1, 2, 3, 4];</span><br><span class="line">console.log(arr2.flatMap(x =&gt; x * 2));</span><br></pre></td></tr></table></figure><h2 id="Symbol属性拓展"><a href="#Symbol属性拓展" class="headerlink" title="Symbol属性拓展"></a>Symbol属性拓展</h2><p>Symbol.prototype.description用来读取Symbol的描述值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//创建 Symbol</span><br><span class="line">let s = Symbol(&quot;张三&quot;);</span><br><span class="line">console.log(s.description);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象方法拓展&quot;&gt;&lt;a href=&quot;#对象方法拓展&quot; class=&quot;headerlink&quot; title=&quot;对象方法拓展&quot;&gt;&lt;/a&gt;对象方法拓展&lt;/h2&gt;&lt;p&gt;Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="ES新特性" scheme="https://superq314.github.io/tags/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ES11新特性</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-31T09:42:23.866Z</published>
    <updated>2022-08-10T04:15:40.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="class-私有属性"><a href="#class-私有属性" class="headerlink" title="class 私有属性"></a>class 私有属性</h2><p>私有属性只能在class中访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    //公有属性</span><br><span class="line">    name;</span><br><span class="line">    //私有属性</span><br><span class="line">    #age;</span><br><span class="line">    #weight;    //构造方法</span><br><span class="line">    constructor(name, age, weight) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.#age = age;</span><br><span class="line">        this.#weight = weight;</span><br><span class="line">    &#125;    //普通方法</span><br><span class="line">    intro() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">        console.log(this.#age);</span><br><span class="line">        console.log(this.#weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">const girl = new Person(&quot;小可爱&quot;, 18, &quot;45kg&quot;);</span><br><span class="line">girl.intro();</span><br></pre></td></tr></table></figure><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><p>该Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。</p><p>相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个reject时立即结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//声明两个promise对象</span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;商品数据 - 1&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // resolve(&quot;商品数据 - 2&quot;);</span><br><span class="line">        reject(&quot;出错啦!&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);//调用 allsettled 方法</span><br><span class="line">const result1 = Promise.allSettled([p1, p2]);</span><br><span class="line">console.log(result1);//调用 all 方法</span><br><span class="line">const result2 = Promise.all([p1, p2]);</span><br><span class="line">console.log(result2);</span><br></pre></td></tr></table></figure><h2 id="字符串方法扩展"><a href="#字符串方法扩展" class="headerlink" title="字符串方法扩展"></a>字符串方法扩展</h2><p>String.prototype.matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let str =</span><br><span class="line">`&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="line">        &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="line">        &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;`;</span><br><span class="line"></span><br><span class="line">//声明正则</span><br><span class="line">const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sg;</span><br><span class="line"></span><br><span class="line">//调用方法</span><br><span class="line">const result = str.matchAll(reg);</span><br><span class="line">for (let v of result) &#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><p>当我们要使用传进来的一个属性值的时候，我们不知道这个属性值到底有没有传，我们可以使用&amp;&amp;运算符一级一级判断，就像这样 const dbHost &#x3D; config &amp;&amp; config.db &amp;&amp; config.db.host;但是这样会显得很麻烦，所以在ES11 中就提供了可选链操作符，它就简化了代码，变成了这样 const dbHost &#x3D; config?.db?.host; 另一方面，即使用户没有传入这个属性，我们用了也不会报错，而是undefined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function connect(config) &#123;</span><br><span class="line">    // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;</span><br><span class="line">    const dbHost = config?.db?.host;</span><br><span class="line">    console.log(dbHost);</span><br><span class="line">&#125;connect(&#123;</span><br><span class="line">    db: &#123;</span><br><span class="line">        host: &quot;192.168.1.100&quot;,</span><br><span class="line">        username: &quot;root&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    cache: &#123;</span><br><span class="line">        host: &quot;192.168.1.200&quot;,</span><br><span class="line">        username: &quot;admin&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import"></a>动态 import</h2><p>以前我们import 导入模块是在一开始的时候就全部导入了，这样在模块很多的时候，会显得网页速度加载很慢，在ES11中就提供了一种动态import，案例演示如下：</p><p>m1.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//分别暴露</span><br><span class="line">export let school = &quot;华北理工大学&quot;;export function study() &#123;</span><br><span class="line">    console.log(&quot;我们要学习！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点击我，加载m1.js模块 &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    const btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line"></span><br><span class="line">    btn.onclick = function()&#123;</span><br><span class="line">        import(&quot;./m1.js&quot;).then(module =&gt; &#123;</span><br><span class="line">            module.study();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="BigInt类型"><a href="#BigInt类型" class="headerlink" title="BigInt类型"></a>BigInt类型</h2><p>BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。</p><p>此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：</p><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>BigInt</li><li>String</li><li>Symbol</li><li>Object</li></ul><p>对于学过其它语言的程序员来说，JS中缺少显式整数类型常常令人困惑。许多编程语言支持多种数字类型，如浮点型、双精度型、整数型和双精度型，但JS却不是这样。在JS中，按照IEEE 754-2008标准的定义，所有数字都以双精度64位浮点格式表示。</p><p>在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。</p><p>如何定义BigInt？需要在数字的后边加上一个n，例如;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let n = 521n;</span><br></pre></td></tr></table></figure><p>我们接下来演示一下，大整数运算的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let max = Number.MAX_SAFE_INTEGER;console.log(max);</span><br><span class="line">console.log(max + 1);</span><br><span class="line">console.log(max + 2);console.log(BigInt(max));</span><br><span class="line">console.log(BigInt(max) + BigInt(1));</span><br><span class="line">console.log(BigInt(max) + BigInt(2));</span><br></pre></td></tr></table></figure><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>全局属性 globalThis 包含全局的 this 值，类似于全局对象（global object）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(globalThis);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;class-私有属性&quot;&gt;&lt;a href=&quot;#class-私有属性&quot; class=&quot;headerlink&quot; title=&quot;class 私有属性&quot;&gt;&lt;/a&gt;class 私有属性&lt;/h2&gt;&lt;p&gt;私有属性只能在class中访问&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="ES新特性" scheme="https://superq314.github.io/tags/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ES7新特性</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES7%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/newFeaturesofES/ES7%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-31T09:42:18.390Z</published>
    <updated>2022-08-10T04:15:20.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组方法扩展"><a href="#数组方法扩展" class="headerlink" title="数组方法扩展"></a>数组方法扩展</h2><p>Array.prototype.includes：此方法用来检测数组中是否包含某个元素，返回布尔类型值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mingzhu = [&quot;西游记&quot;, &quot;红楼梦&quot;, &quot;三国演义&quot;, &quot;水浒传&quot;];</span><br><span class="line">console.log(mingzhu.includes(&quot;西游记&quot;));</span><br></pre></td></tr></table></figure><h2 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h2><p>** 操作符的作用和 Math.pow 的作用是一样，请看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(2 ** 10);</span><br><span class="line">console.log(Math.pow(2, 10));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组方法扩展&quot;&gt;&lt;a href=&quot;#数组方法扩展&quot; class=&quot;headerlink&quot; title=&quot;数组方法扩展&quot;&gt;&lt;/a&gt;数组方法扩展&lt;/h2&gt;&lt;p&gt;Array.prototype.includes：此方法用来检测数组中是否包含某个元素，返回布尔类型值&lt;/p</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="ES新特性" scheme="https://superq314.github.io/tags/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95/</id>
    <published>2022-07-31T09:14:05.391Z</published>
    <updated>2022-08-10T04:52:11.087Z</updated>
    
    <content type="html"><![CDATA[<p>本地存储</p><p>设计模式</p><p>事件循环（EventLoop）</p><p>移动端特效</p><p>API接口</p><p>JS的DOM</p><p>JS的BOM</p><p>JS高级事件</p><p>JS面试手写代码</p><p>JS线程</p><p>JS异步编程</p><p>PC端网页特效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本地存储&lt;/p&gt;
&lt;p&gt;设计模式&lt;/p&gt;
&lt;p&gt;事件循环（EventLoop）&lt;/p&gt;
&lt;p&gt;移动端特效&lt;/p&gt;
&lt;p&gt;API接口&lt;/p&gt;
&lt;p&gt;JS的DOM&lt;/p&gt;
&lt;p&gt;JS的BOM&lt;/p&gt;
&lt;p&gt;JS高级事件&lt;/p&gt;
&lt;p&gt;JS面试手写代码&lt;/p&gt;
&lt;p&gt;JS线程&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E7%9A%84BOM/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E7%9A%84BOM/</id>
    <published>2022-07-31T09:13:36.661Z</published>
    <updated>2022-08-11T15:23:02.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h3><p> <strong>BOM：浏览器对象模型</strong> ，它提供了独立于内容而与 <strong>浏览器窗口进行交互的对象</strong> ，其核心对象时window</p><p>DOM和BOM的区别：</p><table><thead><tr><th>DOM</th><th>BOM</th></tr></thead><tbody><tr><td>文档对象模型</td><td>浏览器对象模型</td></tr><tr><td>DOM就是把文档当作一个对象来看待</td><td>BOM把浏览器当作一个对象来看待</td></tr><tr><td>DOM的顶级对象是document</td><td>BOM的顶级对象是window</td></tr><tr><td>DOM主要学习的是操作页面元素</td><td>BOM学习的是浏览器窗口交互的一些对象</td></tr><tr><td>DOM是W3C标准规范</td><td>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差</td></tr></tbody></table><p>BOM比DOM更大，BOM包含DOM</p><p>window对象是浏览器的顶级对象：</p><ul><li>它是JS访问浏览器窗口的一个接口</li><li>它是全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li></ul><h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><p>语法（两种）：</p><ul><li>传统：window.onload &#x3D; function(){}</li><li>方法：window.addEventListener(‘load’, function(){})</li></ul><p>window.onload 是窗口（页面）加载事件，当文档内容完全加载完成之后（包括图像、文字</p><p>css等），会触发该事件，就调用处理函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function ()&#123;</span><br><span class="line"> // js代码</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>有了window.onload就可以把JS代码写在页面元素的任何地方，因为onload是等页面内容全部加载完毕再去执行处理函数的</li><li>window.onload传统注册事件方式只能写一个，如果有多个，后面的会覆盖前面的，以最后一个为准</li><li>如果使用addEventListener，则没有限制</li></ul><h3 id="调整浏览器窗口大小事件"><a href="#调整浏览器窗口大小事件" class="headerlink" title="调整浏览器窗口大小事件"></a>调整浏览器窗口大小事件</h3><p>语法：<code>window.onresize = function()&#123;&#125;</code>或者 <code>window.addEventListener(&#39;resize&#39;, function()&#123;&#125;)</code></p><p>window.onresize 是调整浏览器窗口大小时加载的事件，当触发时就调用处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;窗口尺寸变化了&#x27;);</span><br><span class="line">     console.log(window.innerWidth); // 当前屏幕的宽度</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>只要窗口大小发生变化，就会触发这个事件</li><li>可利用这个事件完成响应式布局，配合 <code>window.innerWidth</code>获取当前屏幕的宽度</li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>两种定时器：</p><ul><li>setTimeout()</li><li>setInterval()</li></ul><h4 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout() 定时器"></a>setTimeout() 定时器</h4><p>语法：</p><p><code>window.setTimeout(回调函数， [延迟的毫秒数])</code></p><p>作用：用于设置一个定时器，该定时器会在定时器到期后执行回调函数，只执行一次就结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 示例一</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">// 示例二</span><br><span class="line">setTimeout(callback, 2000)</span><br><span class="line">function callback() &#123;</span><br><span class="line">    console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这个window在调用时可省略</li><li>延时的事件单位时毫秒（1000ms &#x3D; 1s），可省略，如果省略为0，则立即调用</li></ul><h4 id="clearTimeout-清除定时器"><a href="#clearTimeout-清除定时器" class="headerlink" title="clearTimeout() 清除定时器"></a>clearTimeout() 清除定时器</h4><p>语法：</p><p><code>window.clearTimeout(timeout ID)</code></p><p>clearTimeout()方法可取消setTimeout()建立的定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt; 按钮 &lt;/button&gt;</span><br><span class="line">var timer = setTimeout(function () &#123;</span><br><span class="line">console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    // 清除定时器</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval() 定时器"></a>setInterval() 定时器</h4><p>语法：<code>window.setInterval(回调函数,[间隔的毫秒数])</code></p><p>setInterval() 方法重复调用一个函数，每隔一段时间（设置的间隔时间），就去调用一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">    console.log(&#x27;111&#x27;);</span><br><span class="line">&#125;, 1000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这个window在调用时可省略</li><li>延时的事件单位时毫秒（1000ms &#x3D; 1s），可省略，如果省略为0，则立即调用</li></ul><h4 id="clearInterval-清除定时器"><a href="#clearInterval-清除定时器" class="headerlink" title="clearInterval 清除定时器"></a>clearInterval 清除定时器</h4><p>语法：<code>window.clearInterval(interval ID)</code></p><p>clearInterval() 方法清除通过setInterval创建的定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt; 按钮&lt;/button&gt;</span><br><span class="line">var timer = setInterval(function () &#123;</span><br><span class="line">console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    // 清除定时器</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="倒计时（案例）"><a href="#倒计时（案例）" class="headerlink" title="倒计时（案例）"></a>倒计时（案例）</h4><p>案例分析：</p><p>1、因为时间是不断变化的，因此需要定时器来自动变化（setInterval）</p><p>2、三个盒子里面分别存放时、分、秒</p><p>3、三个盒子利用innerHTML放入计算出来的时、分、秒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;hour&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;minute&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;second&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var hour = document.querySelector(&#x27;.hour&#x27;);</span><br><span class="line">var minute = document.querySelector(&#x27;.minute&#x27;);</span><br><span class="line">var second = document.querySelector(&#x27;.second&#x27;);</span><br><span class="line">var inputTime = +new Date(&#x27;2022-6-5 18:00:00&#x27;)</span><br><span class="line">countDown(); // 先调用一次时间函数，防止页面刷新出现空白的情况</span><br><span class="line">// 开启定时器，每隔一秒调用一次</span><br><span class="line">setInterval(countDown, 1000)</span><br><span class="line">// 计算 倒计时 时间的函数</span><br><span class="line">function countDown() &#123;</span><br><span class="line">    var nowTime = +new Date(); // 括号内为空，则返回的是当前时间的总毫秒数</span><br><span class="line"></span><br><span class="line">    /* 输入的时间 - 现在时间的总毫秒，再除以1000将毫秒转换为秒 */</span><br><span class="line">    var times = (inputTime - nowTime) / 1000; // times 是剩余时间的总秒数，1s = 1000ms</span><br><span class="line"></span><br><span class="line">    var h = parseInt(times / 60 / 60 % 24); // 小时</span><br><span class="line">    var m = parseInt(times / 60 % 60);// 分钟</span><br><span class="line">    var s = parseInt(times % 60); // 秒数</span><br><span class="line"></span><br><span class="line">    h = h &lt; 10 ? &#x27;0&#x27; + h : h;</span><br><span class="line">    m = m &lt; 10 ? &#x27;0&#x27; + m : m;</span><br><span class="line">    s = s &lt; 10 ? &#x27;0&#x27; + s : s;</span><br><span class="line"></span><br><span class="line">    hour.innerHTML = h;</span><br><span class="line">    minute.innerHTML = m;</span><br><span class="line">    second.innerHTML = s;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h3><ul><li>全局作用域或者普通函数中的this指向全局对象window，定时器里面的this也指向window</li><li>方法调用中谁调用this指向谁</li><li>构造函数中this指向构造函数的实例</li></ul><h3 id="JS执行队列（重要）"><a href="#JS执行队列（重要）" class="headerlink" title="JS执行队列（重要）"></a>JS执行队列（重要）</h3><h4 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h4><p>JavaScript语言的一大特点就是 <strong>单线程</strong> ，也就是说：<strong>同一个时间只能做一件事</strong></p><p>这是因为JavaScript这门脚本语言诞生的使命所致–JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。</p><p>比如：对某个DOM元素进行添加和删除操作，不能同时进行，要先添加后删除</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>为了解决代码一行一行执行，可能会导致后面的代码堵塞的问题，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。</p><p>于是，JavaScript出现了<strong>同步</strong>和<strong>异步</strong></p><p><strong>同步：前一个任务结束后再执行后面的任务，程序的执行顺序与任务的排列顺序是一致的、同步的，会出现代码阻塞的情况。</strong></p><p>比如：做饭的同步做法：烧水煮饭，等水开了（10分钟之后），再去切菜、炒菜。</p><p><strong>异步：同时做多个任务，多个任务一块进行</strong></p><p>比如：做饭的异步做法：烧水煮饭，烧水的同时，去切菜、炒菜。</p><h4 id="同步异步任务执行过程"><a href="#同步异步任务执行过程" class="headerlink" title="同步异步任务执行过程"></a>同步异步任务执行过程</h4><table><thead><tr><th>同步任务</th><th>异步任务</th></tr></thead><tbody><tr><td>同步任务都在<strong>主线程上执行</strong> ，形成一个<strong>执行栈</strong></td><td>js异步是通过<strong>回调函数</strong>实现的</td></tr><tr><td></td><td>一般而言，异步任务有以下三种类型：</td></tr><tr><td></td><td>1、普通事件。如：click、resize等</td></tr><tr><td></td><td>2、资源加载。如：load、error等</td></tr><tr><td></td><td>3、定时器，包括setInterval、setTimeout等</td></tr><tr><td></td><td>异步任务相关<strong>回调函数</strong>添加到<strong>任务队列</strong>中（任务队列也叫 <strong>消息队列</strong> ）</td></tr></tbody></table><p><strong>执行机制：</strong></p><p>1、把JS任务分为同步任务和异步任务，同步任务放在执行栈中，异步任务放在任务队列中（消息队列）</p><p>1、先执行执行栈中的同步任务</p><p>2、再去任务队列里面去看有没有异步任务，如果有则把任务队列里面的异步任务放到执行栈中执行</p><p>3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(3);</span><br><span class="line">// 输出顺序：1 3 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/" alt="js执行机制"></p><h4 id="异步进程处理"><a href="#异步进程处理" class="headerlink" title="异步进程处理"></a>异步进程处理</h4><p><img src="/" alt="js执行机制（事件循环）"></p><h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><h4 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h4><h5 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h5><h5 id="确认框"><a href="#确认框" class="headerlink" title="确认框"></a>确认框</h5><h5 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h5><h4 id="定时事件"><a href="#定时事件" class="headerlink" title="定时事件"></a>定时事件</h4><h5 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h5><h5 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a>定时器</h5><h4 id="常用窗口属性"><a href="#常用窗口属性" class="headerlink" title="常用窗口属性"></a>常用窗口属性</h4><h4 id="其它窗口方法"><a href="#其它窗口方法" class="headerlink" title="其它窗口方法"></a>其它窗口方法</h4><h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>window对象提供了一个 <strong>location属性</strong> ，用于 <strong>获取或设置窗体的URL</strong> ，并且可以用于 <strong>解析URL</strong> 。</p><p>因为这个属性返回的是一个对象，所以这个属性也称为<strong>location对象</strong></p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p> <strong>URL：统一资源定位符</strong> ，是互联网上标准资源的地址</p><p>互联网上每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</p><p>URL的一般语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol://host[:port]/path/[?query]#fragment</span><br><span class="line">https://www.bilibili.com/video/BV1Sy4y1C7ha?p=281</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>通信协议。常用：http、ftp、maito等</td></tr><tr><td>host</td><td>主机（域名）<a href="https://link.juejin.cn/?target=www.bilibili.com" title="www.bilibili.com">www.bilibili.com</a></td></tr><tr><td>port</td><td>端口号，可选，省略时使用方案的默认端口 。如：http默认端口号为80</td></tr><tr><td>path</td><td>路径。由零个或多个’&#x2F;‘符号隔开的字符串，一般用啦表示主机上的一个目录或文件地址</td></tr><tr><td>query</td><td>参数。以键值对的形式，通过&amp;符号分隔开</td></tr><tr><td>fragment</td><td>片段 #后面内容，常见于链接 锚点</td></tr></tbody></table><h4 id="location-对象常见的属性"><a href="#location-对象常见的属性" class="headerlink" title="location 对象常见的属性"></a>location 对象常见的属性</h4><table><thead><tr><th>location对象</th><th>返回值</th></tr></thead><tbody><tr><td>location.href</td><td>获取或设置 整个URL</td></tr><tr><td>location.host</td><td>返回主机（域名）<a href="https://link.juejin.cn/?target=www.bilibili.com" title="www.bilibili.com">www.bilibili.com</a></td></tr><tr><td>location.port</td><td>返回端口号。如果没有端口号，返回空字符串</td></tr><tr><td>location.pathname</td><td>返回路径</td></tr><tr><td>location.search</td><td>返回参数</td></tr><tr><td>location.hash</td><td>返回片段 #后面内容 常见于链接 锚点</td></tr></tbody></table><p>记住：location.href 获取或设置 整个URL 、 location.search 返回参数</p><h4 id="5秒后跳转页面（案例）"><a href="#5秒后跳转页面（案例）" class="headerlink" title="5秒后跳转页面（案例）"></a>5秒后跳转页面（案例）</h4><p>获取当前URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        console.log(location.href); //  file:///E:/practice/css/img/location.html</span><br><span class="line">        // 修改url地址，当按钮点击时，则会跳转到修改过后的地址</span><br><span class="line">        location.href = &#x27;https://www.baidu.com/&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>5秒后跳转页面：</p><p>案例分析：</p><p>1、利用定时器做倒计时效果</p><p>2、时间到了，就跳转页面，使用location.href</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">    var timer = 5;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        if (timer == 0) &#123;</span><br><span class="line">            location.href = &#x27;https://www.baidu.com/&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p.innerHTML = timer + &#x27;秒后跳转到百度页面&#x27;</span><br><span class="line">            timer--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取URL参数（案例）"><a href="#获取URL参数（案例）" class="headerlink" title="获取URL参数（案例）"></a>获取URL参数（案例）</h4><p>案例分析：</p><p>1、第一个登录页面，里面由提交表单，action提交到index.html页面</p><p>2、第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果</p><p>3、第二个页面之所有可以使用第一个页面的数据，是利用了URL里面的location.search参数</p><p>4、第二个页面中，需要把这个参数提取</p><p>5、第一步去掉问好? 利用substr</p><p>6、第二步利用&#x3D;等号分隔键和值 split(‘&#x3D;’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// --login.html</span><br><span class="line">&lt;form action=&quot;index.html&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">// --index.html</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">script&gt;</span><br><span class="line">    console.log(location.search); // ?username=andy</span><br><span class="line">    // 1.去掉？问号 substr(&#x27;起始位置&#x27;， 截取几个字符)</span><br><span class="line">    // 从字符串的第二个元素开始截取，substr()方法如果不写截取几个字符，默认后面的全部截取</span><br><span class="line">    var params = location.search.substr(1);  // params = username=andy</span><br><span class="line">soncole.log(params); //  username=andy</span><br><span class="line"></span><br><span class="line">    // 2.利用=等号 把字符串分割为数组  split(&#x27;=&#x27;)</span><br><span class="line">    var arr = params.split(&#x27;=&#x27;)</span><br><span class="line">    console.log(arr); //  [&#x27;username&#x27;, &#x27;andy&#x27;]</span><br><span class="line"></span><br><span class="line">    var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">    div.innerHTML = arr[1] + &#x27; 欢迎您！&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="location-常见方法"><a href="#location-常见方法" class="headerlink" title="location 常见方法"></a>location 常见方法</h4><table><thead><tr><th>location方法</th><th>返回值</th></tr></thead><tbody><tr><td>location.assign()</td><td>跟href一样，可以跳转页面（也称为重定向页面），记录浏览历史，可以后退页面</td></tr><tr><td>location.replace()</td><td>替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td>location.reload()</td><td>重新加载页面，相当于刷新按钮，或者F5。如果参数为true，强制刷新你ctrl+F5</td></tr></tbody></table><h3 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h3><p><strong>navigator</strong>对象：包含有关浏览器的信息</p><p>它有很多属性，最常用的是 <strong>userAgent</strong> ，该属性可以<strong>返回由客户机发送服务器的user-agent头部的值</strong></p><p>前端代码可以判断用户在哪个终端（PC端、移动端等）打开页面，实现跳转</p><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=285" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=285">www.bilibili.com/video/BV1Sy…</a></p><h3 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h3><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=286&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=286&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><p>window 对象提供了一个history对象，与浏览器历史记录进行交互</p><p>history对象包含用户（在浏览器窗口中）访问过的URL</p><table><thead><tr><th>history对象方法</th><th>说明</th></tr></thead><tbody><tr><td>back()</td><td>可以后退页面功能</td></tr><tr><td>forward()</td><td>前进页面功能</td></tr><tr><td>go(参数)</td><td>前进后退功能。参数如果是1，则前进1个页面；如果参数是-1，则后退1个页面</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;a href=&#x27;index.html&#x27;&gt;点击去首页&lt;/a&gt;</span><br><span class="line">&lt;button&gt;前进&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.querySelectot(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">        history.forward(); // </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h3><h4 id="Screen对象描述"><a href="#Screen对象描述" class="headerlink" title="Screen对象描述"></a>Screen对象描述</h4><h4 id="Screen对象属性"><a href="#Screen对象属性" class="headerlink" title="Screen对象属性"></a>Screen对象属性</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;BOM概述&quot;&gt;&lt;a href=&quot;#BOM概述&quot; class=&quot;headerlink&quot; title=&quot;BOM概述&quot;&gt;&lt;/a&gt;BOM概述&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;BOM：浏览器对象模型&lt;/strong&gt; ，它提供了独立于内容而与 &lt;strong&gt;浏览器窗口进行</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="BOM" scheme="https://superq314.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E7%9A%84DOM/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/JS%E7%9A%84DOM/</id>
    <published>2022-07-31T09:13:15.645Z</published>
    <updated>2022-08-11T15:15:47.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM概述"><a href="#DOM概述" class="headerlink" title="DOM概述"></a>DOM概述</h3><p>DOM：文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言（HTML或XML）的标准<strong>编程接口</strong></p><p>W3C定义了一系列的DOM接口，通过这些DOM接口可改变网页的内容、结构、样式</p><p>DOM中的专有名词：</p><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>元素：页面中的所有标签都是元素，DOM中使用element表示</li><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</li></ul><p>关于DOM操作，主要针对于元素的操作，主要有创建、增、删、改、查、属性操作、事件操作</p><h3 id="DOM文档节点"><a href="#DOM文档节点" class="headerlink" title="DOM文档节点"></a>DOM文档节点</h3><h4 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h4><h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><h4 id="文档节点"><a href="#文档节点" class="headerlink" title="文档节点"></a>文档节点</h4><h4 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h4><h4 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h4><h4 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h4><h3 id="DOM文档操作"><a href="#DOM文档操作" class="headerlink" title="DOM文档操作"></a>DOM文档操作</h3><h4 id="查找-HTML-元素"><a href="#查找-HTML-元素" class="headerlink" title="查找 HTML 元素"></a>查找 HTML 元素</h4><h4 id="获取-HTML-的值"><a href="#获取-HTML-的值" class="headerlink" title="获取 HTML 的值"></a>获取 HTML 的值</h4><h4 id="改变-HTML-的值"><a href="#改变-HTML-的值" class="headerlink" title="改变 HTML 的值"></a>改变 HTML 的值</h4><h4 id="修改-HTML-元素"><a href="#修改-HTML-元素" class="headerlink" title="修改 HTML 元素"></a>修改 HTML 元素</h4><h4 id="查找-HTML-父子"><a href="#查找-HTML-父子" class="headerlink" title="查找 HTML 父子"></a>查找 HTML 父子</h4><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>DOM中获取页面中元素的几种方式：</p><ul><li>根据ID获取</li><li>根据标签名获取</li><li>通过HTML5新增的方法获取</li><li>特殊元素获取</li></ul><h4 id="根据ID获取-getElementById"><a href="#根据ID获取-getElementById" class="headerlink" title="根据ID获取 getElementById()"></a>根据ID获取 getElementById()</h4><p>getElementById()：匹配特定ID的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">var element = document.getElementById(id);</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;time&#x27;&gt;2022-6-1&lt;/div&gt;</span><br><span class="line">var timeId = document.getElementById(&#x27;time&#x27;);</span><br><span class="line">console.log(timeId) // &lt;div id=&quot;time&quot;&gt;2022-6-1&lt;/div&gt;</span><br><span class="line">console.dir(timeId)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>返回一个元素对象</li><li>返回值：返回一个匹配到ID的DOM Element对象，若在当前Document下没有找到，则返回null</li><li>console.dir(timeId)：打印返回的元素对象，可更好的查里面的属性和方法</li></ul><h4 id="根据标签名获取-getElementsByTagName"><a href="#根据标签名获取-getElementsByTagName" class="headerlink" title="根据标签名获取 getElementsByTagName()"></a>根据标签名获取 getElementsByTagName()</h4><p>getElementsByTagName()：返回带有指定标签名的 <strong>对象的集合</strong> （以伪数组的形式存储的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var lis = document.getElementsByTagName(&#x27;li&#x27;); // 选中所有相同的标签</span><br><span class="line">console.log(lis); // 指定标签名的对象合集  以伪数组的方式存储</span><br><span class="line">console.log(lis[0]); // &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// 遍历</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    console.log(lis[i]);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>getElementsByTagName()：获取指定标签名的对象合集，以伪数组的方式存储（可使用数组的部分方法）</li><li>可用for遍历元素对象</li><li>如果页面中只有一个li，返回的依然是伪数组的形式</li><li>如果页面中没有该元素，返回的是一个空的伪数组</li></ul><p>获取某个元素（父元素）内部所有指定标签名的子元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&#x27;ol&#x27;&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 5&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">// 先获取父元素，再获取父元素中的指定标签名</span><br><span class="line">var ol = document.getElementById(&#x27;ol&#x27;)</span><br><span class="line">var ollis = ol.getElementsByTagName(&#x27;li&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：父元素必须是<strong>单个对象（必须指明是哪一个元素对象）</strong> ，获取的时候不包括父元素自己</p><h4 id="H5新增的方法"><a href="#H5新增的方法" class="headerlink" title="H5新增的方法"></a>H5新增的方法</h4><p>H5新增的方法不兼容IE9以下的浏览器，不考虑兼容性和移动端可放心食用</p><p><strong>getElementsByClassName()：根据类名获取某些元素集合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子&lt;/div&gt;</span><br><span class="line">var boxs = document.getElementsByClassName(&#x27;box&#x27;);</span><br><span class="line">console.log(boxs); // 伪数组的方式存储</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>querySelector(‘选择器’)：根据指定选择器，返回第一个元素对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 类选择器</span><br><span class="line">var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">console.log(box); // &lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">// ID选择器</span><br><span class="line">var nav = document.querySelector(&#x27;#nav&#x27;)</span><br><span class="line">console.log(nav); // </span><br><span class="line">// 标签选择器</span><br><span class="line">var li = document.querySelector(&#x27;li&#x27;)</span><br><span class="line">console.log(li); // &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>querySelectorAll(‘选择器’)：根据指定选择器返回所有元素对象的集合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 选择所有的.box （类选择器）</span><br><span class="line">var allBox = document.querySelectorAll(&#x27;.box&#x27;);  // 以伪数组的方式存储</span><br><span class="line">var allLi = document.querySelectorAll(&#x27;li&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取body和HTML元素"><a href="#获取body和HTML元素" class="headerlink" title="获取body和HTML元素"></a>获取body和HTML元素</h4><p>获取body元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var body = document.body;</span><br><span class="line">console.log(body);</span><br><span class="line">console.dir(body); // console.dir() 打印返回的元素对象，可更好的查里面的属性和方法</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>获取HTML元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var html = document.documentElement;</span><br><span class="line">console.log(html)  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><p>JavaScript的DOM操作可改变网页内容、结构、样式，可利用DOM操作元素来改变元素里面的内容、属性等</p><h4 id="改变元素内容（innerText、innerHTML）"><a href="#改变元素内容（innerText、innerHTML）" class="headerlink" title="改变元素内容（innerText、innerHTML）"></a>改变元素内容（innerText、innerHTML）</h4><p>innerText：修改元素的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 示例：点击获取当前系统时间</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点击获取当前系统时间&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">var p = document.querySelector(&#x27;p&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    p.innerText = getNowDay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getNowDay() &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    var year = date.getFullYear();</span><br><span class="line">    var month = date.getMonth();</span><br><span class="line">    var dates = date.getDate();</span><br><span class="line">    var day = date.getDay();</span><br><span class="line">    var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">    return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面加载就显示时间（不依赖事件）</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">div.innerText = getNowDay()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>共同点：</p><ul><li>innerText和innerHTML都可修改页面内容</li></ul><p>区别：</p><ul><li>innerText 不识别html标签 ， innerHTML识别html标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">div.innerText = &#x27;&lt;strong&gt;今天是：&lt;strong&gt;2020年&#x27;; // 不识别html标签，页面会显示&lt;strong&gt;</span><br><span class="line">div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;strong&gt;2020年&#x27;;// 识别html标签，今天是 加粗显示</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>innerText 非标准（老版本火狐不支持），innerHTML W3C标准（推荐）</li><li>这两个属性可读写（可获取元素里面的内容）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    王权</span><br><span class="line">&lt;span&gt;陈斌&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div.innerText); // 王权 陈斌</span><br><span class="line">console.log(div.innerHTML); //  王权  &lt;span&gt;陈斌&lt;/span&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>innerText 去除html标签，同时空格和换行也会去掉</li><li>innerHTML 保留html标签，同时保留空格和换行</li></ul><h4 id="修改元素属性"><a href="#修改元素属性" class="headerlink" title="修改元素属性"></a>修改元素属性</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=204&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=204&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h4 id="分时问候（案例）"><a href="#分时问候（案例）" class="headerlink" title="分时问候（案例）"></a>分时问候（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=205&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=205&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h4 id="修改表单属性"><a href="#修改表单属性" class="headerlink" title="修改表单属性"></a>修改表单属性</h4><p>利用DON可用操作表单元素的属性：</p><p>type、value、checked、selected、disabled</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;输入。。。&quot;&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">var input = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    input.value = &#x27;999&#x27;;</span><br><span class="line">    // this指向事件函数的调用者 btn</span><br><span class="line">    // disabled 被点击之后，不能再使用</span><br><span class="line">    this.disabled = true</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h4><p>可通过JavaScript修改元素的大小、颜色、位置等样式</p><p>element. <strong>style</strong> ：<strong>行内样式操作</strong></p><p>element. <strong>className</strong> ：<strong>类名样式操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// element.style：行内样式操作</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// 鼠标经过时的样式</span><br><span class="line">div.onmouseover = function () &#123;</span><br><span class="line">    // div.style.backgroundColor = &#x27;#f90&#x27; // 可用this this指向事件函数的调用者</span><br><span class="line">    this.style.backgroundColor = &#x27;#f90&#x27;</span><br><span class="line">    this.style.width = &#x27;500px&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 鼠标离开时的样式</span><br><span class="line">div.onmouseout = function () &#123;</span><br><span class="line">    this.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>JS里面的样式采用驼峰命名法。比如：backgroundColor、fontSize</li><li>js修改style样式操作，产生的是行内样式，权重比较高</li><li>如果样式少，或者简单的情况下使用（多的情况下，使用className）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // element.className：类名样式操作</span><br><span class="line">.change&#123;</span><br><span class="line">    background-color:#f90;</span><br><span class="line">    width:500px;</span><br><span class="line">    height: 500px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&#x27;div-style&#x27;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// 鼠标经过时的样式</span><br><span class="line">div.onmouseover = function () &#123;</span><br><span class="line">   this.className = &#x27;change&#x27;; // 可以理解为：给他添加个类名</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>可以理解为：提前写好样式，给他添加个这个类名</li><li>适合样式多或功能负责的情况</li><li>className 会直接更改元素的类名，会覆盖原先的类名，如果想要保留原先的类名，做法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.className = &#x27;原先的类名  改变后的类名&#x27;</span><br><span class="line">this.className = &#x27;div-style  change&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作元素总结"><a href="#操作元素总结" class="headerlink" title="操作元素总结"></a>操作元素总结</h4><p>操作元素：</p><ul><li>操作元素内容<ul><li>innerText</li><li>innerHTML</li></ul></li><li>操作常见元素属性<ul><li>src、href、title、alt等</li></ul></li><li>操作表单元素属性<ul><li>type、value、disabled等</li></ul></li><li>操作元素样式属性<ul><li>element.style</li><li>className</li></ul></li></ul><h4 id="全选与取消全选（案例）"><a href="#全选与取消全选（案例）" class="headerlink" title="全选与取消全选（案例）"></a>全选与取消全选（案例）</h4><p>案例分析：</p><p>1、全选取消全选的做法：让下面的复选框的checked属性 跟随 全选按钮即可（循环下面的复选框，将其checked属性改为和全选按钮一样）</p><p>2、下面的复选框需要全部选中，上面的全选才能选中：给下面的所有复选框绑定点击事件，每次点击，都要循环一下查看下面所有的复选框是否都选中，如果存在一个没选选中，则全选按钮不选中。设置一个变量，来控制是否选中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">全选：&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">&lt;div id=&quot;checkboxContent&quot;&gt;</span><br><span class="line">    篮球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">    足球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">    排球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var allCheckbox = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">// 选择ID为checkboxContent下所有的input标签的元素集合</span><br><span class="line">var inputs = document.getElementById(&#x27;checkboxContent&#x27;).getElementsByTagName(&#x27;input&#x27;)</span><br><span class="line"></span><br><span class="line">// 当全选框选中时，其他的复选框全部选中</span><br><span class="line">allCheckbox.onclick = function () &#123;</span><br><span class="line">    // this.checked 复选框是选中状态为true，未选中为fasle</span><br><span class="line">    // this指向调用事件函数的allCheckbox</span><br><span class="line">    // console.log(this.checked);</span><br><span class="line">    for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">        // 循环其他的复选框，把其它的状态改为和全选的状态一样</span><br><span class="line">        inputs[i].checked = this.checked; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给下面的所有复选框绑定点击事件，每次点击，都要循环一下查看下面所有的复选框是否都选中，如果存在一个没选中，则全选按钮不选中</span><br><span class="line">// 变量 flag 控制全选按钮是否选中</span><br><span class="line">for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    inputs[i].onclick = function () &#123;</span><br><span class="line">        // flag 控制全选按钮是否选中</span><br><span class="line">        var flag = true;</span><br><span class="line">        // 每次点击下面的复选框，都要循环检查其他的按钮是否全被选中</span><br><span class="line">        for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">            if (!inputs[i].checked) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allCheckbox.checked = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取自定义属性值-getAttribute"><a href="#获取自定义属性值-getAttribute" class="headerlink" title="获取自定义属性值 getAttribute()"></a>获取自定义属性值 getAttribute()</h4><p>自定义属性：程序员自己添加的属性，称为自定义属性</p><p>获取元素的属性值：</p><ul><li>element.属性</li><li>element.getAttribute(‘属性’)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27;&gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">console.log(div.id); // demo </span><br><span class="line">console.log(div.getAttribute(&#x27;id&#x27;)); // demo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>element.属性：获取内置属性值（元素本身自带的属性）</li><li>element.getAttribute(‘属性’)：主要获取自定义的属性（标准的），程序员自定义的属性</li></ul><h4 id="自定义属性的操作（设置、移除属性）"><a href="#自定义属性的操作（设置、移除属性）" class="headerlink" title="自定义属性的操作（设置、移除属性）"></a>自定义属性的操作（设置、移除属性）</h4><p><strong>设置属性的值</strong></p><ul><li>element.属性 &#x3D; ‘值’ 设置内置属性值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; index=&#x27;1&#x27; &gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.id = &#x27;test&#x27;;</span><br><span class="line">div.className = &#x27;test1&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li>element.setAttribute(‘属性’, ‘值’) ：主要针对自定义属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; index=&#x27;1&#x27; &gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.setAttribute(&#x27;index&#x27;, 2);</span><br><span class="line">div.setAttribute(&#x27;class&#x27;, &#x27;footer&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>移除属性 removeAttribute(属性)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.removeAttribute(&#x27;index&#x27;)</span><br><span class="line">// 移除后</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; &gt;&lt;div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tab栏切换（案例）"><a href="#tab栏切换（案例）" class="headerlink" title="tab栏切换（案例）"></a>tab栏切换（案例）</h4><p>案例分析：</p><p>1、tab切换有两个大模块</p><p>2、上面的模块选项卡，点击某一个，当前这个的背景颜色变成红色，其余的不变，可用修改类名的方式</p><p>3、下面的模块内容，会随着上面的选项卡变化而变化，所以下面的模块变化写在点击事件里面</p><p>4、规律：下面的模块显示内容和上面的选项卡一一对应，相匹配</p><p>5、核心思路：给上面的tab_list里面的所有小li添加自定义属性（setAttribute），属性值从0开始编号</p><p>6、当点击tab_list里面的某个小li，让tab_con里面对应序号的内容显示，其余隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tab_list&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;tab_con&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;display: block;&quot;&gt;111&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;222&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;333&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;444&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var tab_list = document.querySelector(&#x27;.tab_list&#x27;);</span><br><span class="line">var lis = tab_list.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">var items = document.querySelector(&#x27;.tab_con&#x27;).querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">// 循环绑定事件</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    // 给五个li设置索引号 </span><br><span class="line">    lis[i].setAttribute(&#x27;data-index&#x27;, i)</span><br><span class="line">    lis[i].onclick = function () &#123;</span><br><span class="line">        // 上面的模块选项卡，点击某一个，当前这个的背景颜色变成红色，其余的不变，可用修改类名的方式</span><br><span class="line">        for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">            // 清除所有li的class 这个类</span><br><span class="line">            lis[i].className = &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 只留下当前点击的那个，给他添加上类（样式）</span><br><span class="line">        this.className = &#x27;current&#x27;;</span><br><span class="line"></span><br><span class="line">        // 点击切换时，显示的内容模块</span><br><span class="line">        var index = this.getAttribute(&#x27;data-index&#x27;)</span><br><span class="line">        // 先把所有的隐藏</span><br><span class="line">        for (var i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">            items[i].style.display = &#x27;none&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        // 只留下当前的要显示的内容（和上对应的内容）</span><br><span class="line">        items[index].style.display = &#x27;block&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h4><p>自定义属性的目的：为了保存并使用数据，有些数据可保存到页面中，不必保存到数据库中</p><p>自定义属性获取属性是通过：getAttribute(‘属性’)</p><p>但是有些自定义属性很容易引起歧义，不容易判断元素是内置属性还是自定义属性</p><p>H5新增的自定义属性（不考虑兼容性问题）：</p><ul><li>H5规定自定义属性data-开头作为属性名，并且赋值。比如：<code>&lt;div data-index = &#39;1&#39;&gt;&lt;/div&gt;</code></li><li>通过setAttribute(‘属性’)自定义属性。比如：<code>div.setAttribute(&#39;data-time&#39;, 20)</code></li><li>获取自定义属性的值getAttribute。比如：<code>div.getAttribute(&#39;data-time&#39;)</code></li><li>dataset 是一个集合，里面存放了所有以data开头的自定义属性。<ul><li>示例：<code>console.log(div.dataset.index)</code> 打印data-开头 index的自定义属性，<code>console.log(div.dataset)</code>打印所有以data开头的自定义属性</li><li><code>div.dataset[&#39;index&#39;]</code> 打印data开头 index的自定义属性</li><li>dataset 兼容性差 IE11才兼容</li></ul></li><li>如果自定义属性里面有多个-连接的单词，获取自定义属性时，需要采取驼峰命名法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自定义属性里面有多个-连接的单词，获取自定义属性时，需要采取驼峰命名法</span><br><span class="line">&lt;div data-list-name=&#x27;andy&#x27;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.dataset.listName); // andy</span><br><span class="line">console.log(div.dataset[&#x27;listName&#x27;]); // andy</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p>页面中的所有内容都是节点（标签、属性、文本、注释等），在DOM中，节点使用node来表示</p><p>HTML DOM树中的所有节点均可以通过JavaScript进行访问，所有HTML元素（节点）均可被修改、创建、删除</p><p>一般的节点至少拥有：<strong>nodeType（节点类型）</strong> 、<strong>nodeName（节点名称）</strong> 、<strong>nodeValue（节点值）</strong> 三个基本属性</p><p>nodeType（节点类型）：</p><ul><li>元素节点 nodeType 为 1</li><li>属性节点 nodeType 为 2</li><li>文本节点 nodeType 为 3（文本节点包括：文字、空格、换行）</li></ul><p>在实际开发中，节点操作主要操作的是<strong>元素节点</strong></p><h4 id="父节点-parentNode"><a href="#父节点-parentNode" class="headerlink" title="父节点 parentNode"></a>父节点 parentNode</h4><p>语法：<code>node.parentNode</code> 返回指定子节点的父节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div class=&#x27;box&#x27;&gt;</span><br><span class="line">    &lt;span class=&#x27;font&#x27;&gt;文字文字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 父节点</span><br><span class="line">var font = document.querySelector(&#x27;.font&#x27;);</span><br><span class="line">// var box = document.querySelector(&#x27;.box&#x27;) // 以前的写法</span><br><span class="line">console.log(font.parentNode); // font.parentNode 可以直接获取子节点font的父节点</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>node.parentNode 得到的是离子节点最近的父节点</li><li>如果指定的节点找不到父节点，则返回为null</li></ul><h4 id="子节点-children"><a href="#子节点-children" class="headerlink" title="子节点 children"></a>子节点 children</h4><p>语法：parentNode.childNodes 返回包含指定节点的子节点（包含：元素节点、文本节点等）的集合，该集合为即使更新的集合</p><p>如果只想要获得里面的元素节点，则需要专门处理，一般不提倡用childNodes</p><p>推荐使用：<code>parentNode.children</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">// var li = document.querySelector(&#x27;li&#x27;); // 以前的写法</span><br><span class="line">console.log(ul.children); // ul.children 可以直接获取父节点ul下的所有子节点</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="第一个和最后一个子节点"><a href="#第一个和最后一个子节点" class="headerlink" title="第一个和最后一个子节点"></a>第一个和最后一个子节点</h4><p>parentNode.firstElementChild ：返回第一个子元素节点，找不到返回null</p><p>parentNode.lastElementChild：返回最后一个子元素节点，找不到返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;22&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">console.log(ul.firstElementChild); // 第一个子元素节点： &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">console.log(ul.lastElementChild); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：这两个方法有兼容性问题，IE9以上才支持</p><p>实际开发的写法，<strong>既没有兼容性问题，又能返回第一个和最后一个子元素：</strong></p><p>ul.children[ol.children.length - 1 ] ：获取最后一个子元素（父节点所有子节点的长度减1，则是元素的下标），不管子元素增加减少，都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ul.children 返回ul下面所有的子节点，再用children[0]数组的方式取第一个子节点</span><br><span class="line">console.log(ul.children[0]); // 第一个子元素节点： &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">console.log(ul.children[2]); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">console.log( ul.children[ol.children.length - 1 ]); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="导航栏（父子节点案例）"><a href="#导航栏（父子节点案例）" class="headerlink" title="导航栏（父子节点案例）"></a>导航栏（父子节点案例）</h4><p>案例分析：</p><p>1、导航栏里面的li都要鼠标经过的效果，所以需要循环绑定鼠标事件</p><p>2、核心元素：当鼠标经过li里面的第二个孩子ul显示，当鼠标离开，ul隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;&quot;&gt;首 页&lt;/a&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;&quot;&gt;微 博&lt;/a&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var nav = document.querySelector(&#x27;.nav&#x27;)</span><br><span class="line">var lis = nav.children; // 得到nav下面的子li</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].onmouseover = function () &#123;</span><br><span class="line">        this.children[1].style.display = &#x27;block&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    lis[i].onmouseout = function () &#123;</span><br><span class="line">        this.children[1].style.display = &#x27;none&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>语法：</p><ul><li><code>node.nextElementSibling</code> 返回下一个兄弟元素节点，找不到返回null</li><li><code>node.previousElementSibling</code> 返回下一个兄弟元素节点，找不到返回null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;div&lt;/div&gt;</span><br><span class="line">&lt;span&gt;span&lt;/span&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div.nextElementSibling); // &lt;span&gt;span&lt;/span&gt;</span><br><span class="line">console.log(div.previousElementSibling); // null</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：这两个方法有兼容性问题，IE9以上才支持</p><h4 id="创建-x2F-添加-x2F-删除-x2F-替换-x2F-查找节点"><a href="#创建-x2F-添加-x2F-删除-x2F-替换-x2F-查找节点" class="headerlink" title="创建&#x2F;添加&#x2F;删除&#x2F;替换&#x2F;查找节点"></a>创建&#x2F;添加&#x2F;删除&#x2F;替换&#x2F;查找节点</h4><p>语法：</p><ul><li><p>创建节点：因为这些元素原先是不存在的，是根据需要动态生成的，所以也称为<strong>动态创建元素节点</strong></p><ul><li><p><code>document.createElement(&#39;tagName&#39;)</code></p><ul><li>创建由tagName指定的HTML元素</li></ul></li><li><p><code>document.createDocumentFragment()</code></p><ul><li>创建一个DOM片段</li></ul></li><li><p><code>document.createTextNode() </code></p><ul><li>创建一个文本节点</li></ul></li></ul></li><li><p>添加节点</p><ul><li><code>node.appendChild(child)</code><ul><li>将一个节点添加到指定父节点的子节点列表的 <strong>末尾</strong> （node：父级，child子级）</li></ul></li><li><code>node.insertBefore(child, 指定元素)</code><ul><li>将一个节点添加到父节点的指定子节点<strong>前面</strong></li></ul></li></ul></li><li><p>删除节点</p><ul><li>语法：<code>node.removeChild(child)</code> 从父节点中删除一个子节点，返回删除的节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">&lt;button&gt;删除&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>11<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 1.获取元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.删除元素  node.removeChild(child)</span></span><br><span class="line"><span class="comment">// ul.removeChild(ul.children[0])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.点击按钮依次删除子节点</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 如果父节点下没有子节点了，按钮禁用，还有子节点则可以继续删除</span></span><br><span class="line">    ul.<span class="property">children</span>.<span class="property">length</span> == <span class="number">0</span> ?  <span class="variable language_">this</span>.<span class="property">disabled</span> = <span class="literal">true</span> :  ul.<span class="title function_">removeChild</span>(ul.<span class="property">children</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>替换节点</p><ul><li>replaceChild(new,old)</li></ul></li><li><p>拷贝节点</p><ul><li>语法：node.cloneNode() 返回调用该方法的节点的一个副本，也成为克隆节点&#x2F;拷贝节点</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>33<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>44<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="comment">// 复制ul下面第一个孩子li的节点</span></span><br><span class="line"><span class="keyword">var</span> lili = ul.<span class="property">children</span>[<span class="number">0</span>].<span class="title function_">cloneNode</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 添加到ul下的li列表的末尾</span></span><br><span class="line">ul.<span class="title function_">appendChild</span>(lili)</span><br><span class="line"><span class="comment">// 添加到ul下的li列表的第一个li的前面</span></span><br><span class="line">ul.<span class="title function_">insertBefore</span>(lili, ul.<span class="property">children</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>  注意：</p><ul><li><p>如果括号内的参数为<strong>空</strong>或者为 <strong>false</strong> ，则是 <strong>浅拷贝</strong> ，只克隆复制节点本身，<strong>只复制标签不复制里面的内容</strong></p></li><li><p>如果括号内为 <strong>true</strong> ，则是 <strong>深拷贝</strong> ，<strong>复制里面的标签和内容</strong></p></li><li><p>查找节点</p><ul><li>getElementById();</li><li>getElementsByName();</li><li>getElementsByTagName();</li><li>getElementsByClassName();</li><li>querySelector();</li><li>querySelectorAll();</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;99&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 1.创建节点 元素节点</span><br><span class="line">var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line"></span><br><span class="line">// 2.添加节点 node.appendChild(child) node 父级  child 子级</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">ul.appendChild(li)</span><br><span class="line"></span><br><span class="line">// 3.添加节点 node.insertBefore(child, 指定元素)</span><br><span class="line">var lili = document.createElement(&#x27;li&#x27;);</span><br><span class="line">ul.insertBefore(lili, ul.children[0]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果需要在页面添加一个新的元素（步骤）：</p><p>1.创建元素</p><p>2.添加元素</p><h4 id="留言板（创建-x2F-添加-x2F-删除节点案例）"><a href="#留言板（创建-x2F-添加-x2F-删除节点案例）" class="headerlink" title="留言板（创建&#x2F;添加&#x2F;删除节点案例）"></a>留言板（创建&#x2F;添加&#x2F;删除节点案例）</h4><p>核心思路：点击按钮之后，就动态创建一个li，添加到ul里面</p><p>创建li的同时，把文本域里面的值通过li.innerHTML赋值给li</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;button&gt;添加&lt;/button&gt;</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var text = document.querySelector(&#x27;textarea&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    if (text.value == &#x27;&#x27;) &#123;</span><br><span class="line">        alert(&#x27;您还没有输入留言~&#x27;);</span><br><span class="line">        return false; // 终止操作</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建元素节点</span><br><span class="line">        var li = document.createElement(&#x27;li&#x27;)</span><br><span class="line">        // 现有li 才能赋值</span><br><span class="line">        // console.log(text.value); // 留言的内容</span><br><span class="line">        li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;</span><br><span class="line"></span><br><span class="line">        // 添加元素节点 insertBefore 添加的元素永远在一个行</span><br><span class="line">        ul.insertBefore(li, ul.children[0])</span><br><span class="line">        // 添加留言完成之后，清空原来输入框的内容</span><br><span class="line">        text.value = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        // 删除元素节点 删除的是当前链接的父节点</span><br><span class="line">        var as = document.querySelectorAll(&#x27;a&#x27;);</span><br><span class="line">        for (var i = 0; i &lt; as.length; i++) &#123;</span><br><span class="line">            as[i].onclick = function () &#123;</span><br><span class="line">                // node.removeChild(child) 删除的是li  当前a所在的li  this.parentNode</span><br><span class="line">                // li 的父节点是ul ul.removeChild()</span><br><span class="line">                ul.removeChild(this.parentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="动态生成表格（综合案例）"><a href="#动态生成表格（综合案例）" class="headerlink" title="动态生成表格（综合案例）"></a>动态生成表格（综合案例）</h4><p>案例分析：</p><p>1、因为里面的数据是动态的，需要js动态生成。先模拟数据，定义好相应的数据，数据采取数组对象的形式存储</p><p>2、所有的数据都是放在tbody里面的行里面</p><p>3、因为行很多，需要循环创建多个行（多少人创建多少行）</p><p>4、每一个行里面有多个单元格（对应里面的数据），需要使用循环创建多个单元格，并且把数据存入里面（双重for循环）</p><p>5、最后一列单元格是删除，需要单独创建单元格</p><p>6、点击a删除当前a所在的行（链接的父级的父级） node.removeChild(child)，当前a的父级是列，列的父级是行，删除一整行： this.parentNode.parentNode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(k in obj)&#123;</span><br><span class="line">    // k 得到的是属性名</span><br><span class="line">    // obj[k] 得到的是属性值</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成表格案例</span><br><span class="line">&lt;table cellspacing=&quot;0&quot;&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;科目&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;成绩&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">// 1.先准备数据</span><br><span class="line">var datas = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;王权&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;沉稳五&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 90</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;灵梦&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 80</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">// 2.往tbody里面创建行：多少人创建多少行，通过数组的长度创建几行</span><br><span class="line">var tbody = document.querySelector(&#x27;tbody&#x27;);</span><br><span class="line">for (var i = 0; i &lt; datas.length; i++) &#123; // 外面的for循环决定多少行</span><br><span class="line">    // 创建tr行</span><br><span class="line">    var tr = document.createElement(&#x27;tr&#x27;);</span><br><span class="line">    // 在父节点tbody下添加子节点tr</span><br><span class="line">    tbody.appendChild(tr)</span><br><span class="line"></span><br><span class="line">    // 3.行里面创建单元格 td，单元格的数量取决于对象里面的属性个数 ，得到数组对象属性个数，也就是单元格列的个数</span><br><span class="line">    // for循环遍历对象（每个datas数组里面的元素对象都要遍历一遍，得到每一个元素对象属性的个数）</span><br><span class="line">    for (var k in datas[i]) &#123; // 里面的for循环决定多少列 td</span><br><span class="line">        // 创建单元格列</span><br><span class="line">        var td = document.createElement(&#x27;td&#x27;);</span><br><span class="line">        // 把对象里面的属性值给td  </span><br><span class="line">        td.innerHTML = datas[i][k];</span><br><span class="line">        // 单元格放在行里面</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.创建删除的单元格</span><br><span class="line">    var td = document.createElement(&#x27;td&#x27;);</span><br><span class="line">    // 给删除的单元格添加删除的文字</span><br><span class="line">    td.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;删 除&lt;/a&gt;&quot;</span><br><span class="line">    // 将删除的单元格放入行中</span><br><span class="line">    tr.appendChild(td)</span><br><span class="line">&#125;</span><br><span class="line">// 5.删除单元格操作</span><br><span class="line">var as = document.querySelectorAll(&#x27;a&#x27;)</span><br><span class="line">for (var i = 0; i &lt; as.length; i++) &#123;</span><br><span class="line">    as[i].onclick = function () &#123;</span><br><span class="line">        // 点击a删除当前a所在的行（链接的父级的父级） node.removeChild(child)</span><br><span class="line">        // 当前a的父级是列，列的父级是行，删除一整行： this.parentNode.parentNode</span><br><span class="line">        tbody.removeChild(this.parentNode.parentNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三种动态创建元素的区别"><a href="#三种动态创建元素的区别" class="headerlink" title="三种动态创建元素的区别"></a>三种动态创建元素的区别</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=245&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=245&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><ul><li>document.write()（了解）：直接将内容写入页面的内容流。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 例如：点击按钮在文档中写入一个内容是123的div,按钮点击之后，文档重绘，其他的内容都没有了，只有这个123的div</span><br><span class="line">document.write(&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>element.innerHTML：创建元素</li><li>document.createElement()：创建元素</li></ul><p>区别：</p><ul><li>document.write() 正常下是没有问题的，但是当文档流执行完毕，则它会导致页面全部重绘（原来的内容就没有了）</li><li>innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘</li><li>innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组push形式拼接，再转换成字符），结构稍微复杂</li><li>createElement() 创建多个元素效率稍微低一点，但是结构更清晰</li></ul><p>总结：不同浏览器下，innerHTML效率比createElement高</p><h3 id="DOM文档事件"><a href="#DOM文档事件" class="headerlink" title="DOM文档事件"></a>DOM文档事件</h3><h4 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h4><p>JavaScript可创建动态页面，事件是可被JavaScript侦测到的行为</p><p>事件三要素：</p><ul><li>事件源：被触发的对象（谁触发的事件）</li><li>事件类型：如何触发。比如：鼠标点击，鼠标经过、键盘按下</li><li>事件处理程序：通过函数赋值的方式 完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    alert(&#x27;点击&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h4><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><h4 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h4><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td><strong>onclick</strong></td><td><strong>鼠标点击左键触发</strong></td></tr><tr><td><strong>onmouseover</strong></td><td><strong>鼠标经过触发</strong></td></tr><tr><td>onmouseout</td><td>鼠标离开触发</td></tr><tr><td><strong>onfocus</strong></td><td><strong>获取鼠标焦点触发</strong></td></tr><tr><td>onblur</td><td>失去鼠标焦点触发</td></tr><tr><td>onmousemove</td><td>鼠标移动触发</td></tr><tr><td>onmouseup</td><td>鼠标弹起触发</td></tr><tr><td>onmousedown</td><td>鼠标按下触发</td></tr></tbody></table><h4 id="媒体事件"><a href="#媒体事件" class="headerlink" title="媒体事件"></a>媒体事件</h4><h4 id="其它事件"><a href="#其它事件" class="headerlink" title="其它事件"></a>其它事件</h4><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><h4 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h4><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DOM概述&quot;&gt;&lt;a href=&quot;#DOM概述&quot; class=&quot;headerlink&quot; title=&quot;DOM概述&quot;&gt;&lt;/a&gt;DOM概述&lt;/h3&gt;&lt;p&gt;DOM：文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="DOM" scheme="https://superq314.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS自定义对象</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/advancedObjects/JS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/advancedObjects/JS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-07-31T09:06:43.807Z</published>
    <updated>2022-07-31T09:38:49.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数组也是对象的一种，数组是一种用于表达有顺序关系的值的集合的语言结构，也就是同类数据元素的有序集合。</p><p>数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据。但是在JavaScript中是支持数组可以是不同的元素，这跟JavaScript的弱类型有关，此处不用纠结，我们大多数时候都是相同类型元素的集合。数组内的各个值被称作元素，每一个元素都可以通过索引（下标）来快速读取，索引是从零开始的整数。</p><p>使用typeof检查一个数组对象时，会返回object。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><h4 id="使用对象创建"><a href="#使用对象创建" class="headerlink" title="使用对象创建"></a>使用对象创建</h4><p>同类型有序数组创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();</span><br><span class="line">arr[0] = 1;</span><br><span class="line">arr[1] = 2;</span><br><span class="line">arr[2] = 3;</span><br><span class="line">arr[3] = 4;</span><br><span class="line">arr[4] = 5;</span><br><span class="line">arr[5] = 6;</span><br><span class="line">arr[6] = 7;</span><br><span class="line">arr[7] = 8;</span><br><span class="line">arr[8] = 9;</span><br></pre></td></tr></table></figure><p>不同类型有序数组创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();</span><br><span class="line">arr[0] = 1;</span><br><span class="line">arr[1] = &quot;2&quot;;</span><br><span class="line">arr[2] = 3;</span><br><span class="line">arr[3] = &quot;4&quot;;</span><br><span class="line">arr[4] = 5;</span><br><span class="line">arr[5] = &quot;6&quot;;</span><br><span class="line">arr[6] = 7;</span><br><span class="line">arr[7] = &quot;8&quot;;</span><br><span class="line">arr[8] = 9;</span><br></pre></td></tr></table></figure><h3 id="使用字面量创建"><a href="#使用字面量创建" class="headerlink" title="使用字面量创建"></a>使用字面量创建</h3><ul><li>同类型有序数组创建：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br></pre></td></tr></table></figure><ul><li>不同类型有序数组创建：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, &quot;2&quot;, 3, &quot;4&quot;, 5, &quot;6&quot;, 7, &quot;8&quot;, 9];</span><br></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>constructor属性演示：返回创建数组对象的原型函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];</span><br><span class="line">console.log(arr.constructor);</span><br></pre></td></tr></table></figure><p>length属性演示：设置或返回数组元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];</span><br><span class="line">console.log(arr.length);</span><br></pre></td></tr></table></figure><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>push()方法演示：该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var result = arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;, &quot;白骨精&quot;, &quot;玉兔精&quot;);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>pop()方法演示：该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var result = arr.pop();</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>unshift()方法演示：该方法向数组开头添加一个或多个元素，并返回新的数组长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var result = arr.unshift(&quot;牛魔王&quot;, &quot;二郎神&quot;);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>shift()方法演示：该方法可以删除数组的第一个元素，并将被删除的元素作为返回值返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var result = arr.shift();</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>forEach()方法演示：该方法可以用来遍历数组</p><p>forEach()方法需要一个函数作为参数，像这种函数，由我们创建但是不由我们调用的，我们称为回调函数。数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素，以实参的形式传递进来，我们可以来定义形参，来读取这些内容，浏览器会在回调函数中传递三个参数：</p><p>第一个参数：就是当前正在遍历的元素<br>第二个参数：就是当前正在遍历的元素的索引<br>第三个参数：就是正在遍历的数组<br>注意：这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持该方法，所以如果需要兼容IE8，则不要使用forEach()，还是使用for循环来遍历数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">arr.forEach(function (value, index, obj) &#123;</span><br><span class="line">    console.log(value + &quot; #### &quot; + index + &quot; #### &quot; + obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>slice()方法演示：该方法可以用来从数组提取指定元素，该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</p><p>参数：</p><p>第一个参数：截取开始的位置的索引，包含开始索引<br>第二个参数：截取结束的位置的索引，不包含结束索引，第二个参数可以省略不写，此时会截取从开始索引往后的所有元素<br>注意：索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1代表倒数第一个，-2代表倒数第二个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;, &quot;唐僧&quot;, &quot;白骨精&quot;];</span><br><span class="line">var result = arr.slice(1, 4);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.slice(3);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.slice(1, -2);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>splice()方法演示：该方法可以用于删除数组中的指定元素，该方法会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回</p><p>参数：</p><p>第一个参数：表示开始位置的索引<br>第二个参数：表示要删除的元素数量<br>第三个参数及以后参数：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;, &quot;唐僧&quot;, &quot;白骨精&quot;];</span><br><span class="line">var result = arr.splice(3, 2);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.splice(1, 0, &quot;牛魔王&quot;, &quot;铁扇公主&quot;, &quot;红孩儿&quot;);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>concat()方法演示：该方法可以连接两个或多个数组，并将新的数组返回，该方法不会对原数组产生影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var arr2 = [&quot;白骨精&quot;, &quot;玉兔精&quot;, &quot;蜘蛛精&quot;];</span><br><span class="line">var arr3 = [&quot;二郎神&quot;, &quot;太上老君&quot;, &quot;玉皇大帝&quot;];</span><br><span class="line">var result = arr.concat(arr2, arr3, &quot;牛魔王&quot;, &quot;铁扇公主&quot;);</span><br><span class="line">console.log(result);6</span><br></pre></td></tr></table></figure><p>join()方法演示：该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回，在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用，作为连接符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">var result = arr.join(&quot;@-@&quot;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>reverse()方法演示：该方法用来反转数组（前边的去后边，后边的去前边），该方法会直接修改原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>sort()方法演示：该方法可以用来对数组中的元素进行排序，也会影响原数组，默认会按照Unicode编码进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>注意：即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，所以对数字进排序时，可能会得到错误的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 2, 11, 5, 6];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>我们可以自己来指定排序的规则，我们可以在sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边，浏览器会根据回调函数的返回值来决定元素的顺序，如下：</p><p>如果返回一个大于0的值，则元素会交换位置<br>如果返回一个小于0的值，则元素位置不变<br>如果返回一个等于0的值，则认为两个元素相等，也不交换位置<br>经过上边的规则，我们可以总结下：</p><p>如果需要升序排列，则返回 a-b<br>如果需要降序排列，则返回 b-a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 2, 11, 5, 6];</span><br><span class="line">arr.sort(function (a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h3><p>call()和apply()这两个方法都是函数对象的方法，需要通过函数对象来调用，当对函数调用call()和apply()都会调用函数执行，在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this，call()方法可以将实参在对象之后依次传递，apply()方法需要将实参封装到一个数组中统一传递，如下演示：</p><p>call()方法演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fun(a, b) &#123;</span><br><span class="line">    console.log(&quot;a = &quot; + a);</span><br><span class="line">    console.log(&quot;b = &quot; + b);</span><br><span class="line">    console.log(&quot;fun = &quot; + this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &quot;obj&quot;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun(2, 3);</span><br><span class="line">console.log(&quot;===============&quot;);</span><br><span class="line">fun.call(obj, 2, 3);</span><br></pre></td></tr></table></figure><p>注意：默认fun()函数调用，this指向的是window对象，你可以使用call()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，实参将会依次传递</p><p>apply()方法演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fun(a, b) &#123;</span><br><span class="line">    console.log(&quot;a = &quot; + a);</span><br><span class="line">    console.log(&quot;b = &quot; + b);</span><br><span class="line">    console.log(&quot;fun = &quot; + this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &quot;obj&quot;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun(2, 3);</span><br><span class="line">console.log(&quot;===============&quot;);</span><br><span class="line">fun.apply(obj, [2, 3]);</span><br></pre></td></tr></table></figure><p>注意：默认fun()函数调用，this指向的是window对象，你可以使用apply()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，需要制定一个实参数组进行参数传递</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>以函数形式调用时，this永远都是window<br>以方法的形式调用时，this是调用方法的对象<br>以构造函数的形式调用时，this是新创建的那个对象<br>使用call和apply调用时，this是传入的那个指定对象</p><h3 id="arguments参数"><a href="#arguments参数" class="headerlink" title="arguments参数"></a>arguments参数</h3><p>在调用函数时，浏览器每次都会传递进两个隐含的参数：</p><p>函数的上下文对象： this<br>封装实参的对象： arguments<br>this对象我们已经学习过了，那arguments对象是什么呢？</p><p>arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度，在调用函数时，我们所传递的实参都会在arguments中保存，比如：arguments.length 可以用来获取实参的长度，我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦，例如：</p><p>arguments[0]：表示第一个实参<br>arguments[1]：表示第二个实参<br>…<br>它里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象。</p><p>arguments对象演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fun(a, b) &#123;</span><br><span class="line">    // 通过下标获取第一个参数</span><br><span class="line">    console.log(arguments[0]);</span><br><span class="line">    // 通过下标获取第二个参数</span><br><span class="line">    console.log(arguments[1]);</span><br><span class="line">    // 获取实参的个数</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    // 看看它的函数对象</span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line">    console.log(arguments.callee == fun);</span><br><span class="line">&#125;fun(&quot;Hello&quot;, &quot;World&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组对象&quot;&gt;&lt;a href=&quot;#数组对象&quot; class=&quot;headerlink&quot; title=&quot;数组对象&quot;&gt;&lt;/a&gt;数组对象&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="https://superq314.github.io/2022/07/31/frontEnd/JavaScript/prototype/%E5%8E%9F%E5%9E%8B/"/>
    <id>https://superq314.github.io/2022/07/31/frontEnd/JavaScript/prototype/%E5%8E%9F%E5%9E%8B/</id>
    <published>2022-07-31T08:08:25.357Z</published>
    <updated>2022-08-16T09:00:10.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐理解原型对象"><a href="#⭐理解原型对象" class="headerlink" title="⭐理解原型对象"></a>⭐理解原型对象</h3><h4 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h4><p>只要创建一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。<br>对于构造函数来说，prototype是作为构造函数的属性，指向构造函数的原型对象。</p><p>对于对象实例来说，prototype是对象实例的原型对象。所以prototype即是属性，又是对象。</p><blockquote><p><code>person1.__proto__</code>即为person1实例的原型对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>        </span><br><span class="line"><span class="comment">// 为true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property">protoytype</span>   </span><br><span class="line"><span class="comment">// 为true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>               </span><br><span class="line"><span class="comment">// 输出&#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1)             </span><br><span class="line"><span class="comment">// 为true</span></span><br></pre></td></tr></table></figure><h4 id="原型对象的constructor属性"><a href="#原型对象的constructor属性" class="headerlink" title="原型对象的constructor属性"></a>原型对象的constructor属性</h4><p>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。</p><blockquote><p>即Person.prototype.constructor指向Person。</p><p>通过这个构造函数，可以为原型对象添加其他属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型对象中由一个属性constructor，它指向函数对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Fun</span>) </span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Date</span>) </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="构造函数、原型对象、实例对象的关系"><a href="#构造函数、原型对象、实例对象的关系" class="headerlink" title="构造函数、原型对象、实例对象的关系"></a>构造函数、原型对象、实例对象的关系</h4><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，则都是从Object继承而来。当创建一个新实例后，该实例的内部将包含一个指针（内部属性 <code>[[Prototype]]</code>）指向构造函数的原型对象。脚本中没有标准的方式访问[[Prototype]]，但在Firefox、Safari和Chrome在每个对象上都支持一个属性 <code>__proto__</code>。</p><p>注意：这连接存在于实例与构造函数的原型对象之间，而非实例与构造函数之间。</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200430215620331-779497907.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200430215620331-779497907.png" alt="img"></a></p><h3 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h3><p>两种方式使用in操作符：单独使用、在for-in中使用。</p><h4 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h4><p>单独使用时，<code>&quot;name&quot; in person1</code>无论该属性存在于实例还是原型中，都会返回true。和 <code>.hasOwnProperty</code>不同。可以两者结合判断具体存在于实例还是原型中。</p><h4 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h4><p>返回的是所有能够通过对象访问的、可枚举的属性。包括实例中的和原型中的属性。屏蔽了不可枚举的属性（即将[[Enumerable]]标记的属性）的实例属性也会在for-in中循环返回。因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本例外。</p><blockquote><p>理解：屏蔽了不可枚举的属性（即将[[Enumerable]]标记的属性）的实例属性：<br><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162209788-286753116.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162209788-286753116.png"></a></p></blockquote><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162827445-1857997317.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162827445-1857997317.png"></a></p><p>要取得对象上 <strong>所有可枚举的实例属性</strong> ,，可以使用ECMAScript5的Object.keys()方法。</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162657396-1302113693.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329162657396-1302113693.png"></a></p><p>如果想要得到所有实例属性，无论是否可以枚举，都可以使用 <code>Object.getOwnPropertyNames()</code></p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329163250028-1386071882.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329163250028-1386071882.png"></a></p><h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164043628-1256517702.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164043628-1256517702.png"></a></p><p>在这里构造函数的prototype属性不再指向原型对象，而是指向了一个新对象。此时constructor属性不再指向Person了。这里的修改本质上是完全重写了默认的prototype对象，因此constructor属性也变成了新对象的constructor属性（指向Object构造函数），不再指向Person。此时：</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164617489-1058591707.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164617489-1058591707.png"></a></p><p>用 <code>Object.defineProperty(,)</code>constructor指向修改回Person</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164804414-1187336567.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329164804414-1187336567.png"></a></p><h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但不能重写整个原型对象：</p><p>记住：实例中的指针仅指向原型，而不指向构造函数（第二遍强调！！！）</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329165822090-883603341.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329165822090-883603341.png"></a></p><h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>原型模式的重要性仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式。例子：</p><p>在Array.prototype中可以找到sort()方法</p><p>在String.prototype中可以找到substring()方法</p><p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。例子：</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329170444105-656754825.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329170444105-656754825.png"></a></p><p><a href="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329170611666-766580019.png"><img src="https://img2020.cnblogs.com/blog/1019981/202003/1019981-20200329170611666-766580019.png"></a></p><h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>1.省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得想通的属性值。</p><p>2.共享属性对于函数合适，对于包含基本类型的属性也说得过去，但对于包含引用类型的属性来说，问题突出。实例一般都是要有属于自己的全部属性的，因此很少有人单独使用原型模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐理解原型对象&quot;&gt;&lt;a href=&quot;#⭐理解原型对象&quot; class=&quot;headerlink&quot; title=&quot;⭐理解原型对象&quot;&gt;&lt;/a&gt;⭐理解原型对象&lt;/h3&gt;&lt;h4 id=&quot;函数的prototype属性&quot;&gt;&lt;a href=&quot;#函数的prototype属性&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JS" scheme="https://superq314.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
