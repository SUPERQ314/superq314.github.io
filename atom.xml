<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-10-09T15:26:53.171Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://superq314.github.io/posts/1690d21b/"/>
    <id>https://superq314.github.io/posts/1690d21b/</id>
    <published>2022-10-09T14:53:54.000Z</published>
    <updated>2022-10-09T15:26:53.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、命令式编程  &#x3D;&gt;  2、面向对象编程  &#x3D;&gt;  3、函数式编程<br>考虑一个小功能：将数组最后一个元素大写，假设 log, head，reverse，toUpperCase 函数存在（我们通过 curry 可以很容易写出来）</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">命令式写法</button></li><li class="tab"><button type="button" data-href="#super-2">面向对象写法</button></li><li class="tab"><button type="button" data-href="#super-3">函数式组合——compose</button></li><li class="tab"><button type="button" data-href="#super-4">函数式组合——pipe</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><code>log(toUpperCase(head(reverse(arr))))</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">reverse</span>()</span><br><span class="line">  .<span class="title function_">head</span>()</span><br><span class="line">  .<span class="title function_">toUpperCase</span>()</span><br><span class="line">  .<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure><p>链式调用看起来顺眼多了，然而问题在于，原型链上可供我们链式调用的函数是有限的，而需求是无限的 ，这限制了我们的逻辑表现力。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p><code>const upperLastItem = compose(log, toUpperCase, head, reverse);</code><br>通过参数我们可以很清晰的看出发生了 uppderLastItem 做了什么，它完成了一套流水线，所有经过这条流水线的参数都会经历：reverse -&gt; head -&gt; toUpperCase-&gt; log 这些函数的加工，最后生成结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>很多函数库（Lodash，Ramda）中也提供了另一种组合方式：pipe（从左往右的组合）<br><code>const upperLastItem = R.pipe(reverse, head, toUppderCase, log);</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>对于箭头函数在函数式编程里面有一个高大上的名字，叫 lambda 表达式，对于这种匿名函数在学术上就是叫 lambda 表达式。</p><p>函数式编程</p><p>思维：着眼点是 <strong>函数</strong> ，而不是 <strong>过程</strong> ，强调的是如何通过函数的组合变换去解决问题，而不是通过写什么样的语句去解决问题。</p><p>函数式编程的目的</p><p>使用函数来 <strong>抽象作用在数据之上的控制流和操作</strong> ，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong></p><p>函数式编程的特点</p><ol><li>函数是“一等公民”</li></ol><blockquote><p>这是函数式编程得以实现的 <strong>前提</strong> ，因为我们基本的操作都是在操作函数。这个特性意味着函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></blockquote><p>例如：<code>const convert2Obj = compose(genObj(&#39;name&#39;), capitalizeName)</code></p><ol start="2"><li>声明式编程</li></ol><blockquote><p>函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为 <a href="https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B%EF%BC%9Foldformat=true">声明式编程</a> 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。</p></blockquote><p>React 是声明式的，只要描述你的 UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠你自己去渲染和优化 diff 算法。</p><ol start="3"><li>惰性执行</li></ol><blockquote><p>所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 <strong>convertName</strong> 产生实际的结果。</p></blockquote><ol start="4"><li>无状态和数据不可变</li></ol><p>这是函数式编程的核心概念：</p><p>· <strong>数据不可变：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</p><p>· <strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</p><p>为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。<br><img src="/image/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1665327567706.png" alt="1665327567706"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">没有副作用（No Side Effects）</button></li><li class="tab"><button type="button" data-href="#super-2">纯函数 (pure functions)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>副作用这个词我们可算听的不少，它的含义是：在完成函数主要功能之外完成的其他副要功能。在我们函数中最主要的功能当然是根据输入 <strong>返回结果</strong> ，而在函数中我们最常见的副作用就是 <strong>随意操纵外部变量</strong> 。由于 JS 中对象传递的是引用地址，哪怕我们用 <strong>const</strong> 关键词声明对象，它依旧是可以变的。而正是这个“漏洞”让我们有机会随意修改对象。</p><p>例如： <strong>map</strong> 函数的本来功能是将输入的数组根据一个函数转换，生成一个新的数组：</p><p><strong>map :: [a] -&gt; [b]</strong></p><p>而在 JS 中，我们经常可以看到下面这种对 <strong>map</strong> 的 “错误” 用法，把 <strong>map</strong> 当作一个循环语句，然后去直接修改数组中的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line">list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">type</span> = <span class="number">1</span>;</span><br><span class="line">    item.<span class="property">age</span>++;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样函数最主要的输出功能没有了，变成了直接修改了外部变量，这就是它的副作用。而没有副作用的写法应该是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line"><span class="keyword">const</span> newList = list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;...item, <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">age</span>:item.<span class="property">age</span> + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure><p>保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug。</p><p>传递引用一时爽，代码重构火葬场</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>纯函数算是在“没有副作用” 的要求上再进一步了。</p><p>其实纯函数的概念很简单就是两点：</p><ol><li>不依赖外部状态（无状态）：** 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。</li><li>没有副作用（数据不变）：** 不修改全局变量，不修改入参。</li></ol><p>所以纯函数才是真正意义上的“函数”， 它意味着 <strong>相同的输入，永远会得到相同的输出</strong> 。</p><p>以下几个函数都是不纯的，因为他们都依赖外部变量，试想一下，如果有人调用了 <strong>changeName</strong> 对 <strong>curUser</strong> 进行了修改，然后你在另外的地方调用了 <strong>saySth</strong> ，这样就会产生你预料之外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = str =&gt; curUser.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 引用了全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">obj, name</span>) =&gt; obj.<span class="property">name</span> = name;  <span class="comment">// 修改了输入参数</span></span><br><span class="line"><span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(<span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Jay: hello!</span></span><br></pre></td></tr></table></figure><p>如果改成纯函数的写法会是怎么样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = (<span class="params">user, str</span>) =&gt; user.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 不依赖外部变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">user, name</span>) =&gt; (&#123;...user, name &#125;);  <span class="comment">// 未修改外部变量 </span></span><br><span class="line"><span class="keyword">const</span> newUser = <span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(curUser, <span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Peter: hello!</span></span><br></pre></td></tr></table></figure><p>这样就没有之前说的那些问题了。</p><p>我们这么强调使用纯函数，纯函数的意义是什么？</p><ol><li>便于测试和优化：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。这十分符合<strong>测试驱动开发</strong> TDD****的思想，这样产生的代码往往健壮性更强。</li><li>可缓存性：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果，有很多库有所谓的 <strong>memoize</strong> 函数，下面以一个简化版的 <strong>memoize</strong> 为例，这个函数就能缓存函数的结果，对于像 <strong>fibonacci</strong> 这种计算，就可以起到很好的缓存效果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> value = cache[key];</span><br><span class="line">        <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">            value = [fn.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>)];  <span class="comment">// 放在一个数组中，方便应对 undefined，null 等异常情况</span></span><br><span class="line">            cache[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fibonacci = <span class="title function_">memoize</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">2</span> ? <span class="attr">n</span>: <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">4</span>))  <span class="comment">// 执行后缓存了 fibonacci(2), fibonacci(3),  fibonacci(4)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)) <span class="comment">// fibonacci(2), fibonacci(3),  fibonacci(4) 的结果直接从缓存中取出，同时缓存其他的</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自文档化：由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解（配合后面介绍的 [类型签名](#hindly-milner 类型签名）更佳)。</li><li>更少的Bug：使用纯函数意味着你的函数中 不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中$含义及用法</title>
    <link href="https://superq314.github.io/posts/51b050d3/"/>
    <id>https://superq314.github.io/posts/51b050d3/</id>
    <published>2022-10-06T13:58:55.000Z</published>
    <updated>2022-10-06T14:08:37.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$在JS中本身只是一个符号而异，在JS里什么也不是。但在JS的应用库jQuery中，将之做为一个自定义函数名了，这个函数是获取指定网页元素的函数。</p><p>在不用JQUERY的情况，一般会自定义一个$函数。即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">Nid</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="title class_">Nid</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后不用每次使用document.getElementById(“ID名”)来获取元素，只用$(‘ID名’)即可。</p><p>三种具体用法：</p><ol><li>$()可以是$(expresion)</li></ol><blockquote><p>即css选择器、Xpath或html元素，也就是通过上述表达式来匹配目标元素。<br>比如：$(“a”)构造的这个对象，是用CSS选择器构建了一个jQuery对象——它选择了所有的<code>&lt;a/&gt;</code>这个标签。</p></blockquote><p>如：<code>$(&quot;a&quot;).click(function()&#123;...&#125;)</code><br>就是在点击页面上的任何一个链接时的触发事件。确切地说，就是jQuery用<a/>这个标签构建了一个对象$(“a”)，函数 click()是这个jQuery对象的一个（事件）方法。<br>比如有这样一段HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>one<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>three<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">onClick</span>=<span class="string">&quot;jq()&quot;</span> &gt;</span>jQuery<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而操作这段HTML的是如下一条语句：<br><code>alert($(&quot;div&gt;p&quot;).html());</code></p><p>$()中的是一个查询表达式，也就是用“div&gt;p”这样一个查询表达式构建了一个jQuery对象，然后的“html()”意思是显示其html内容，也就是上面HTML代码段的[two]。<br>再如： $(“<code>&lt;div&gt;&lt;p&gt;</code>Hello<code>&lt;/p&gt;&lt;/div&gt;</code>“).appendTo(“body”);<br>$()中的是一个字符串，用这样一段字串构建了jQuery对象，然后向<body/>中添加这一字串。  </p><ol start="2"><li>$()可以是$(element)<blockquote><p>即一个特定的DOM元素。如常用的DOM对象有document、location、form等。<br>如这样一行代码： <code>$(document).find(&quot;div&gt;p&quot;).html());</code></p></blockquote></li></ol><p>$()中的document是一个DOM元素，即在全文寻找带<code>&lt;p&gt;</code>的<code>&lt;div&gt;</code>元素，并显示<code>&lt;p&gt;</code>中的内容。 </p><ol start="3"><li>$()可以是$(function)<blockquote><p>即一个函数，它是$(document).ready()的一个速记方式。如常见的形式是这样的：<br><code>$(document).ready(function()&#123; alert(&quot;Hello world!&quot;); &#125;);</code></p></blockquote></li></ol><p>可变形作：<br><code>$(function()&#123; alert(&quot;Hello world!&quot;); &#125;);</code></p><p>对于选择HTML文档中的elements，jQuery有两种方法：<br>1）如$(“div&gt;ul a”)，它的意思是div标签中的ul标签中的a标签<br>2）用jQuery对象的几个方法（如方法find()、each()等） $(“#orderedlist).find(“li”) 就像 $(“#orderedlist li”). each()一样迭代了所有的li，而表达式中的“#”表示HTML中的ID，如上例中的“#orderedlist”就表示“ID为orderedlist所在的标签”。  **************************************************************** </p><p>2、XPath选择器 如：选择所有带有title 属性的链接，我们会这样写：$(‘a[@title]’)<br>[]里带@，说明[]里的是元素的属性；是个属性选择器<br>[]里没@，说明[]里的是元素的子孙。<br>在XPath中，要找一个“以…开头”的属性，用^&#x3D;，如找一个name属性是以mail开头的input元素，就用<br>$(‘input[@name^&#x3D;”mail”]’)<br>要找一个“以…结尾”的属性，要用$&#x3D; 要找一个“不头不尾”的属性，用*&#x3D;  </p><p>3、不属于上述的CSS和XPath的选择器，就是自定义的选择器了，用“:”表示，这里要用的就是:first，:last，:parent ，:hidden，:visible，:odd，:even，:not(‘xxx’)， “:eq(0)”（始于0)，:nth(n），:gt(0)，:lt(0)，:contains(“xxx”) 如：$(‘tr:not([th]):even’)意为<tr>元素的子孙中不含<th>的所有子孙的偶数项 </p><p>5、要直接访问DOM元素，可用get(0)的方法，如<br>$(‘#myelement’).get(0)<br>也可缩写成<br>$(‘#myelement’)[0]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lodash高阶函数</title>
    <link href="https://superq314.github.io/posts/c123e559/"/>
    <id>https://superq314.github.io/posts/c123e559/</id>
    <published>2022-10-06T13:38:01.000Z</published>
    <updated>2022-10-06T14:08:37.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="lodash-高阶函数"><a href="#lodash-高阶函数" class="headerlink" title="lodash 高阶函数"></a>lodash 高阶函数</h2><p>lodash 大家肯定不陌生，它是最流行的 JavaScript 库之一，透过函数式编程模式为开发者提供常用的函数。</p><p>其中有一些封装的高阶函数，让一些平平无奇的普通函数也能有相应的高阶功能。</p><p>举几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖动</span></span><br><span class="line">_.<span class="title function_">debounce</span>(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line">_.<span class="title function_">throttle</span>(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个断言函数结果取反</span></span><br><span class="line">_.<span class="title function_">negate</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line">_.<span class="title function_">curry</span>(func, [arity=func.<span class="property">length</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分应用</span></span><br><span class="line">_.<span class="title function_">partial</span>(func, [partials])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个带记忆的函数</span></span><br><span class="line">_.<span class="title function_">memoize</span>(func, [resolver])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装函数</span></span><br><span class="line">_.<span class="title function_">wrap</span>(value, [wrapper=identity])</span><br></pre></td></tr></table></figure><p>研究源码你就会发现，_.debounce 防抖、_.throttle 节流上面说过，_.curry 柯里化上面说过、_.partial 在“缓存传参”里说过、_.memoize 在“缓存计算”里也说过……</p><p>再举一个例子：</p><p>现在要求一个函数在达到 n 次之前，每次都正常执行，第 n 次不执行。</p><p>也是非常常见的业务场景！JavaScript 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">before</span>(<span class="params">n, func</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result,</span><br><span class="line">    count = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            func = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn= <span class="title function_">before</span>(<span class="number">3</span>,<span class="function">(<span class="params">x</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(x))</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">3</span>) <span class="comment">// 不执行</span></span><br></pre></td></tr></table></figure><p>反过来：函数只有到 n 次的时候才执行，n 之前的都不执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">after</span>(<span class="params">n, func</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = n || <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn= <span class="title function_">after</span>(<span class="number">3</span>,<span class="function">(<span class="params">x</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(x))</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>) <span class="comment">// 不执行</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>) <span class="comment">// 不执行</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>全是“闭包”、全是把参数“柯里化”。</p><p>细细体会，在控制台上敲一敲、改一改、跑一跑，下次或许你就可以自己写出这些有特定功能的高阶函数了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一道前端JS面试题</title>
    <link href="https://superq314.github.io/posts/481a45e8/"/>
    <id>https://superq314.github.io/posts/481a45e8/</id>
    <published>2022-10-06T12:10:26.000Z</published>
    <updated>2022-10-06T14:08:37.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">3</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; alert (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>();              <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>();                  <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();            <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>();                  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>();          <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();        <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p><p>此题包含7小问，分别说下。</p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>代码部分，</p><p>首先定义了一个叫Foo的函数，<br>之后为Foo创建了一个叫getName的<strong>静态属性</strong>存储了一个匿名函数，<br>之后为Foo的<strong>原型对象</strong>新创建了一个叫getName的匿名函数。<br>之后又通过<strong>函数变量表达式</strong>创建了一个getName的函数，<br>最后再<strong>声明</strong>一个叫getName函数。</p><p>第一问的 Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2。</p><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>第二问，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以跟1 2 3都没什么关系。</p><p>此处有两个坑，一是变量声明提升，二是函数表达式。</p><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>即所有声明变量或声明函数都会被提升到当前函数的顶部。</p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p> var getName 与 function getName 都是声明语句，区别在于 vargetName 是 <strong>函数表达式</strong> ，而 function getName 是 <strong>函数声明</strong> 。关于JS中的各种函数创建方式可以看 <a href="http://www.cnblogs.com/xxcanghai/p/4991870.html">大部分人都会做错的经典<strong>JS</strong>闭包面试题</a> 这篇文章有详细说明。</p><p>函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。</p><p>原题中代码最终执行时的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        alert (<span class="number">1</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName;<span class="comment">//只提升变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提升函数声明，覆盖var的声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    alert (<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line">getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; alert (<span class="number">4</span>);&#125;;<span class="comment">//最终的赋值再次覆盖function getName声明</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//最终输出4</span></span><br></pre></td></tr></table></figure><h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><p>第三问的 Foo().getName(); 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。</p><p>Foo函数的第一句  getName &#x3D; function () { alert (1); };  是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。</p><p><strong>此处实际上是将外层作用域内的</strong>getName<strong>函数修改了。</strong></p><p>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。</p><p>之后Foo函数的返回值是this。</p><p><strong>简单</strong>的讲， <strong>this的指向是由所在函数的调用方式决定的</strong> 。而此处的直接调用方式，this指向window对象。</p><p>遂Foo函数返回的是window对象，相当于执行 window.getName() ，而window中的getName已经被修改为alert(1)，所以最终会输出1</p><p>此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。</p><h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><p>直接调用getName函数，相当于 window.getName() ，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1</p><h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><p>第五问 new Foo.getName(); ,此处考察的是js的运算符优先级问题。</p><p><strong>js运算符优先级:</strong></p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps1.jpg"></p><p>通过查上表可以得知点（.）的优先级高于new操作，遂相当于是:</p><p>new (Foo.getName)();</p><p>所以实际上将getName函数作为了构造函数来执行，遂弹出2。</p><h2 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h2><p>第六问 new Foo().getName() ，首先看运算符优先级括号高于new，实际执行为</p><p>(new Foo()).getName()</p><p>遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的构造函数返回值问题。</p><h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。</p><p>而在js中构造函数可以有返回值也可以没有。</p><p>1、没有返回值则按照其他语言一样返回实例化对象。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps2.jpg"></p><p>2、若有返回值则检查其返回值是否为 <strong>引用类型</strong> 。如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps3.jpg"></p><p>3、若返回值是引用类型，则实际返回值为这个引用类型。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml10956\wps4.jpg"></p><p>原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p><p>之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。</p><p>遂最终输出3。</p><h2 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h2><p>第七问, new new Foo().getName(); 同样是运算符优先级问题。</p><p>最终实际执行为：</p><p>new ((new Foo()).getName)();</p><p>先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。</p><p>遂最终结果为3</p><p>这里确实是(new Foo()).getName()，但是跟括号优先级高于成员访问没关系，实际上这里成员访问的优先级是最高的，因此先执行了 .getName，但是在进行左侧取值的时候， new Foo() 可以理解为两种运算：new 带参数（即 new Foo()）和函数调用（即 先 Foo() 取值之后再 new），而 new 带参数的优先级是高于函数调用的，因此先执行了 new Foo()，或得 Foo 类的实例对象，再进行了成员访问 .getName。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网页设计</title>
    <link href="https://superq314.github.io/posts/81984e4e/"/>
    <id>https://superq314.github.io/posts/81984e4e/</id>
    <published>2022-10-06T12:02:07.000Z</published>
    <updated>2022-10-06T14:08:37.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>合格的网页应该包含</p><p>页面分为页头、菜单导航栏（可下拉）、中间内容板块、页脚四大部分；</p><p>所有页面相互超链接，可到三级页面，有5-10个页面组成；</p><p>页面样式风格统一布局显示正常，不错乱，使用div+css技术；</p><p>菜单美观、醒目，二级菜单可正常弹出与跳转；</p><p>要有JS特效，如定时切换和手动切换图片新闻；</p><p>页面中有多媒体元素，如gif、视频、音乐，表单技术的使用；</p><p>这个网页是模仿淘宝、京东等购物商场的布局，加上在本学期所学的内容，制作了七个关于“零食巴士”主题的页面，并将其定义为一个零食销售的购物网站。</p><p>index.html 是网站的首页，内置的链接有buycar.html、regist.html、login.html、product.html、personcenter.html 几乎能访问到所有的链接网页。</p><p>网页中head与footer可以通用到其他页面，节省了其他页面的编写时间。</p><p>product.html 是商品的详细页，中间为商品的详细信息介绍。</p><p>buycar.html 是购物车的界面，中间绘制了一张表格完成了购物商城的购物车。</p><p>login.html 是登录页面。</p><p>regist.html 是注册页面。</p><p>personcenter.html 是个人中心页面，中间为购买商品的一些情况。</p><p>information.html 是个人信息页面，中间为用户的个人信息。</p><p>food.html 美食的列表，第二个模板块。</p><p>Newidea.html 创意构想，第三个模板块</p><p>主要技术实现：</p><p>网页采用了纯html+css+jquery，在完成网页的过程中，顺便补充了jquery方面的知识，方便自己编写动画特效，发现相对于js，jquery封装之后的使用的确方便了许多，许多方面本来应该十分繁复的地方，jquery封装之后再进行使用就变得十分的轻便，而且解释起来也十分的方便。</p><p>整体的HTML，采用了网页互通，串成了一个整体。</p><p>CSS样式用的最多的是文字以及布局的一些设置，常常因为一个样式的大小位置调来调去。</p><p>视频演示：web前端大作业 零食商城设计【附完整源码和报告】.MP4</p><p>功能截图：</p><p>1.首页 （ index.html ）</p><p>本页面用了做了页头，中间，和页尾部分。其中包括了类似叮叮书店的js图片轮播技术，使用js技术将定位响应连接了起来，做成了类似多级菜单的效果，还有返回顶部并隐藏top键的js特效，根据老师的建议，不应该直接滑动到顶部而应该缓慢有个过程。</p><p>具体js实现：</p><p>在右边是详细介绍，分为了三个板块：商品属性、商品详情、商品评论。通过定义id以及a href 点击即可到达对应区域。</p><p>#商品详情 添加了网页截图所得到的的图片</p><p>#用户评论</p><p>运用了meter展示所占百分比，通过构建一张类似购物车的table，完成客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS雪碧图</title>
    <link href="https://superq314.github.io/posts/48ac2f57/"/>
    <id>https://superq314.github.io/posts/48ac2f57/</id>
    <published>2022-10-06T11:59:54.000Z</published>
    <updated>2022-10-09T14:38:41.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSS雪碧"><a href="#CSS雪碧" class="headerlink" title="CSS雪碧"></a>CSS雪碧</h2><p>即 <code>CSS Sprite</code>，也叫 <code>CSS</code>精灵，是一种 <code>CSS</code>图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用 <code>CSS</code>的背景定位来显示需要显示的图片部分。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>CSS </code>雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的 <code>HTTP </code>请求数量。该图片使用 <code>CSS </code>的 <code>background </code>和 <code>background-position </code>属性渲染，这也就意味着你的标签变得更加复杂了，图片是在 <code>CSS </code>中定义，而非 <code>img</code>标签。</p><ol><li>前期准备下载工具：css sprit（css精灵）<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064328704.png" alt="1665064328704"><br>百度云链接：<code>http://pan.baidu.com/s/1nuOZDqT</code></li><li>使用方法<br>下载，打开之后。</li><li>首先要切一些图片，不会切的话，移步：《前端ps切图方法，图文详细》</li><li>打开雪碧图，选择图片。<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064341241.png" alt="1665064341241"></li><li>添加完图片之后，会自动生成代码，需要排列一下图片：<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064387332.png" alt="1665064387332"><br>注意：排列图片的时候要注意各个图片之间留点空隙，不然使用的时候，会相互覆盖。</li><li>保存图片以及雪碧图css代码<br>保存雪碧图<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064443713.png" alt="1665064443713"><br>生成的雪碧图：<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064447657.png" alt="1665064447657"><br>保存雪碧图-css代码（因为软件没有到导出css代码的功能，所以要自己新建一个txt文件，放在雪碧图旁边，以后打开txt就知道图片在雪碧图的位置。）<br><img src="/image/CSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/1665064455368.png" alt="1665064455368"></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>减少加载网页图片时对服务器的请求次数<blockquote><p>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</p></blockquote></li><li>提高页面的加载速度<blockquote><p>sprite 技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF 图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF 只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</p></blockquote></li><li>减少鼠标滑过的一些bug<blockquote><p>IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。</p></blockquote></li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>CSS雪碧的最大问题是内存使用<blockquote><p>除非这个雪碧图片是被非常小心的组织，你就会最终使用大量的无用的空白。</p></blockquote></li><li>影响浏览器的缩放功能<blockquote><p>如果一个使用CSS雪碧的页面使用一些浏览器提供的整页缩放功能缩放了，浏览器就需要做一些额外的工作来纠正这些图片边缘的行为——基本上来说，是为了避免雪碧中相邻的图片被“露进来”。这对于小图片没有什么问题，但是对于大图片会是一个性能下降。</p></blockquote></li><li>拼图维护比较麻烦<blockquote><p>拼合这么多图片，需要耐心。同时还要时刻思考如何在使用这个图片是不会产生相互的影响。将又瘦又高的图片和又宽又矮的图片放到一起时，不容易操作。如果要修改雪碧中的一个图片，你就要修改整张图片，这无疑会增大工作量。</p></blockquote></li><li>使CSS的编写变得困难<blockquote><p>如果CSS雪碧足够复杂，则大大增加了CSS的代码量和难度，让维护和修改变得困难起来。</p></blockquote></li><li>CSS 雪碧调用的图片不能被打印<blockquote><p>CSS 雪碧调用的图片不能被打印，除非在@media中特别添加 print声明。</p></blockquote></li><li>错误得使用 Sprites 影响可访问性<blockquote><p>一些刚入门的开发人员会为了节省 HTTP 请求数(这是使用 CSS Sprite 一直强调的好处)而把所有的图片都当背景图片来处理 – 甚至是那些传达重要信息的图片。结果会导致一个缺乏可访问性的网站，也会降低 HTML 中 title 和 alt 的潜在益处。<br>因此，CSS sprite 本身没错，而且也不会引发可访问性问题(事实上，正确得使用会提高可访问性)。但是不分对错得过度使用 sprite 会阻碍具有可访问性和生产率方面的网页建设进程。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>co源码分析</title>
    <link href="https://superq314.github.io/posts/b4573e17/"/>
    <id>https://superq314.github.io/posts/b4573e17/</id>
    <published>2022-10-03T09:36:42.000Z</published>
    <updated>2022-10-03T11:37:04.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Generator</button></li><li class="tab"><button type="button" data-href="#super-2">Promise</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><code>generator函数</code>是回调地狱的一种解决方案，跟 <code>promise</code>类似，但是却可以以同步的方式来书写代码，而避免了promise的链式调用。</p><p>它的执行过程在于调用生成器函数（function*）后，会返回一个iterator（迭代）对象，即Generator对象，但是它并不会立刻执行里面的代码。</p><p>它有几个方法，next(), throw()和return()。<br>调用next()方法后，它会找到第一个yield关键字（直到找到程序底部或者return语句），每次程序运行到yield关键字时，程序便会暂停，保存当前环境里面的变量的值，然后可以跳出当前运行环境去执行yield后面的代码，再把结果返回回来。</p><p>返回的结果是一个对象，类似于{value: ‘’, done: false}</p><ul><li>value表示本次yield后面执行之后返回的结果。如果是Promise实例，则是返回resolved后的值。</li><li>done表示迭代器是否执行完毕，若为true，则表示当前生成器函数已经产生了最后输出的值，即生成器函数已经返回。</li></ul><p>下面是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;All done.&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">constructor</span>);     <span class="comment">// output: GeneratorFunction &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 0, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: &#x27;All done.&#x27;, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());          <span class="comment">// output: &#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p><code>Promise对象</code>用于一个异步操作的最终完成（或失败）及其结果值的表示(简单点说就是处理异步请求）。</p><p>Promise核心就在于里面状态的变换，是rejected、resolved还是pending，还有就是原型链上的then()方法，它可以传递本次状态转换后返回的值。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="co源码分析"><a href="#co源码分析" class="headerlink" title="co源码分析"></a>co源码分析</h2><p>主要脉络</p><p> <strong>co函数调用后，返回一个Promise实例</strong> 。</p><blockquote><p>co的思想就是将一个传递进来的参数进行合法化，再通过转换成Promise实例返回出去。<br>如果参数fn是generator函数的话，里面还可以自动进行遍历，执行generator函数里面的yield关键字后面的内容，并返回结果，也就是不断地调用fn().next()方法，再通过传递返回的Promise实例resolved后的值，从而达到同步执行generator函数的效果。</p></blockquote><p>注意：<strong>co里面最主要的是要理解Promise实例和Generator对象，它们是co函数里面的程序自动遍历执行的关键</strong> 。</p><p>下面解释一下co模块里面的最重要的两部分，一个是generator函数的自动调用，另外一个是参数的Promise化。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">co完整源码</button></li><li class="tab"><button type="button" data-href="#super-2">generator函数的自动调用</button></li><li class="tab"><button type="button" data-href="#super-3">参数Promise化(co中的toPromise的实现)</button></li><li class="tab"><button type="button" data-href="#super-4">着重来分析一下objectToPromise</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * slice() reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the generator function or a generator</span></span><br><span class="line"><span class="comment"> * and return a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">  <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">res</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="keyword">throw</span>(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">     * return a promise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">ret</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">onRejected</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">        + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="title class_">String</span>(ret.<span class="property">value</span>) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a `yield`ed value into a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPromise</span>(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isGeneratorFunction</span>(obj) || <span class="title function_">isGenerator</span>(obj)) <span class="keyword">return</span> co.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) <span class="keyword">return</span> arrayToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> objectToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a thunk to a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thunkToPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fn.<span class="title function_">call</span>(ctx, <span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">2</span>) res = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an array of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(obj.<span class="title function_">map</span>(toPromise, <span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an object of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectToPromise</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);  <span class="comment">//Object.create()</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);  <span class="comment">//[&quot;a&quot;,&quot;b&quot;]</span></span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];   <span class="comment">//a   b</span></span><br><span class="line">    <span class="keyword">var</span> promise = toPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj[key]);</span><br><span class="line">    <span class="keyword">if</span> (promise &amp;&amp; <span class="title function_">isPromise</span>(promise)) <span class="title function_">defer</span>(promise, key);</span><br><span class="line">    <span class="keyword">else</span> results[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Promise.resolve(4) Promise.resolve(5)  </span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">defer</span>(<span class="params">promise, key</span>) &#123;</span><br><span class="line">    <span class="comment">// predefine the key in the result</span></span><br><span class="line">    results[key] = <span class="literal">undefined</span>;   <span class="comment">//&#123;&#125;.a  &#123;&#125;.b</span></span><br><span class="line">    promises.<span class="title function_">push</span>(promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      results[key] = res;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">then</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a generator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isGenerator</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">next</span> &amp;&amp; <span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj.<span class="property">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a generator function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isGeneratorFunction</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> constructor = obj.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">if</span> (!constructor) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="property">name</span> || <span class="string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="property">displayName</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isGenerator</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check for plain object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span> == val.<span class="property">constructor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * slice() reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the generator function or a generator</span></span><br><span class="line"><span class="comment"> * and return a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存当前的执行环境</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 切割出函数调用时传递的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">    <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果gen是一个函数，则返回一个新的gen函数的副本，里面绑定了this的指向，即ctx</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果gen不存在或者gen.next不是一个函数，就说明gen已经调用完成，那么直接可以resolve(gen)，返回Promise</span></span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首次调用gen.next()函数，假如存在的话</span></span><br><span class="line">        <span class="title function_">onFulfilled</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">res</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试着获取下一个yield后面代码执行后返回的值</span></span><br><span class="line">                ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理结果</span></span><br><span class="line">            <span class="title function_">next</span>(ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试抛出错误</span></span><br><span class="line">                ret = gen.<span class="keyword">throw</span>(err);</span><br><span class="line">            &#125; <span class="keyword">catch</span> **(e) &#123;</span><br><span class="line">                <span class="keyword">return</span> **<span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理结果</span></span><br><span class="line">            <span class="title function_">next</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">         * return a promise.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">ret</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这个next()函数是最为关键的一部分，里面几乎包含了generator自动调用实现的核心</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果ret.done === true，证明generator函数已经执行完毕。即已经返回了值</span></span><br><span class="line">            <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把ret.value转换成Promise对象继续调用</span></span><br><span class="line">            <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果存在，则把控制权交给onFulfilled和onRejected，实现递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则最后直接抛出错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">onRejected</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span>+ <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="title class_">String</span>(ret.<span class="property">value</span>) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码中的onFulfilled和onRejected，可以把它们看成是co模块对于resolve和reject封装的加强版。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a `yield`ed value into a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Mixed</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toPromise</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的 obj 是假值，返回这个假值 如 undefined , false, null</span></span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 如果是 Promise 实例，返回这个 promise 实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPromise</span>(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 如果是 generator 函数或者 一个generator</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isGeneratorFunction</span>(obj) || <span class="title function_">isGenerator</span>(obj)) <span class="keyword">return</span> co.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是 thunk 函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) <span class="keyword">return</span> arrayToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是一个 plain object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> objectToPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">    <span class="comment">// 如果是原始值，则返回这个原始值。</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toPromise的本质上就是通过判定参数的类型，然后再通过转移控制权给不同的参数处理函数，从而获取到期望返回的值。</p><p>关于参数的类型的判断，看一下源码就能理解了，比较简单。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an object of &quot;yieldables&quot; to a promise.</span></span><br><span class="line"><span class="comment"> * Uses `Promise.all()` internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectToPromise</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="comment">// 定义一个和传入的对象一样构造器的空对象</span></span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取对象的所有可以遍历的key（属性）</span></span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="comment">// 用于盛放 每个属性值生成的对应的 promise 实例</span></span><br><span class="line">    <span class="keyword">var</span> promises = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于数组的每一个项都调用一次toPromise方法，变成Promise对象</span></span><br><span class="line">        <span class="keyword">var</span> promise = toPromise.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj[key]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果里面是Promise对象的话，则取出e里面resolved后的值</span></span><br><span class="line">        <span class="keyword">if</span> (promise &amp;&amp; <span class="title function_">isPromise</span>(promise)) <span class="title function_">defer</span>(promise, key);</span><br><span class="line">        <span class="keyword">else</span> results[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行，按顺序返回结果，返回一个数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 将 results 作为 onFulfilled 函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key来获取Promise实例resolved后的结果，从而push进结果数组results中</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">defer</span>(<span class="params">promise, key</span>) &#123;</span><br><span class="line">        <span class="comment">// predefine the key in the result</span></span><br><span class="line">        results[key] = <span class="literal">undefined</span>;</span><br><span class="line">        promises.<span class="title function_">push</span>(promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义promise 实例的 resolve 函数</span></span><br><span class="line">            results[key] = res;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面理解的关键就在于把key遍历，如果key对应的value也是Promise对象的话，那么调用defer()方法来获取resolved后的值。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="编写自己的generator函数运行器"><a href="#编写自己的generator函数运行器" class="headerlink" title="编写自己的generator函数运行器"></a>编写自己的generator函数运行器</h2><p>通过以上的简单介绍，我们就可以尝试来写一个属于自己的generator函数运行器了，目标功能是能够自动运行function* 函数，并且里面的yield子句后面跟着的都是Promise实例。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">具体代码(my-co.js)</button></li><li class="tab"><button type="button" data-href="#super-2">在test.js文件中调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-co.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = my-co;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my-co = <span class="keyword">function</span> (<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="comment">// gen是一个具有Promise的生成器函数</span></span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">gen</span>(); <span class="comment">// 迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次调用next</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = g.<span class="title function_">next</span>(val); <span class="comment">// 调用ret</span></span><br><span class="line">        <span class="keyword">if</span> (ret.<span class="property">done</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; <span class="string">&#x27;function&#x27;</span> === <span class="keyword">typeof</span> ret.<span class="property">value</span>.<span class="property">then</span>) &#123;</span><br><span class="line">            ret.<span class="property">value</span>.<span class="title function_">then</span>( <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 继续循环下去</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">next</span>(data); <span class="comment">// promise resolved</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.jsconst</span></span><br><span class="line">myCo = <span class="built_in">require</span>(<span class="string">&#x27;./my-co&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">yield</span> <span class="title function_">pro1</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data1: &#x27;</span> + data1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">yield</span> <span class="title function_">pro2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data2: &#x27;</span> + data2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">yield</span> <span class="title function_">pro3</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data3: &#x27;</span> + data3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data4 = <span class="keyword">yield</span> <span class="title function_">pro4</span>(data1 + <span class="string">&#x27;\n&#x27;</span> + data2 + <span class="string">&#x27;\n&#x27;</span> + data3);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data4: &#x27;</span> + data4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;All done.&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用myCo</span></span><br><span class="line"><span class="title function_">myCo</span>(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟两秒</span></span><br><span class="line">resolve<span class="keyword">function</span> <span class="title function_">pro1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;promise1 resolved&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟一秒</span></span><br><span class="line">resolve<span class="keyword">function</span> <span class="title function_">pro2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;promise2 resolved&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入Hello World到./1.txt文件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pro3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="string">&#x27;Hello World\n&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;write-1 success&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入content到./1.txt文件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pro4</span>(<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>, content, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;write-2 success&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果：<br><code>// output data1: promise1 resolved data2: promise2 resolved data3: write-1 success data4: write-2 success</code><br>.&#x2F;1.txt文件内容：<br><code>Hello World promise1 resolved promise2 resolved write-1 success</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>虽然这个运行器很简单，后面只支持Promise实例，并且也不支持多种参数，但是却引导出了一个思路，促使我们思考怎么去展示我们的代码，还有就是很有效地避免了多重then，以 <strong>同步的方式来书写异步代码</strong> 。Promise解决的是回调地狱的问题（callback hell）,而Generator解决的是代码的书写方式。孰优孰劣，全在于个人意愿。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上分析了co部分源码的精髓，讲到了co函数里面generator函数自动遍历执行的机制，还讲到了co里面最为关键的objectToPromise()方法。</p><p>在文章的后面我们编写了一个属于自己的generator函数遍历器，其中主要的是next()方法，它可以检测我们yield后面Promise操作是否完成。<br>如果generator的状态done还没有置为true，那么继续调用next(val)方法，并把上一次yield操作获取到的值传递下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo更新方式</title>
    <link href="https://superq314.github.io/posts/15858/"/>
    <id>https://superq314.github.io/posts/15858/</id>
    <published>2022-09-30T11:35:29.000Z</published>
    <updated>2022-10-06T12:07:44.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/litten/</span>hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/yilia</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>使用cd命令进入博客根目录<br>常规操作，不做解释</p><p>更新插件和Hexo版本<br>npm update</p><h2 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h2><ol><li>使用cd命令进入博客根目录<br>常规操作，不做解释</li><li>检查插件更新<br>npm outdated</li><li>运行后可以检查Hexo和插件的最新版本<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537849838.png" alt="1664537849838"></li><li>更改版本文件<br>修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537868070.png" alt="1664537868070"></li><li>开始更新<br>npm install –save</li><li>查看当前版本号<br>hexo version<br><img src="/image/hexo%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/1664537946133.png" alt="1664537946133"></li></ol><p>真实有效</p><p>升级方法：在主題目录下，进行 <code>git pull</code></p><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为butterfly。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo</span> g <span class="comment"># 生成</span></span><br><span class="line">hexo s <span class="comment"># 启动本地web服务器</span></span><br></pre></td></tr></table></figure><p>现在打开<a href="http://localhost:4000/">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP中get和post的区别</title>
    <link href="https://superq314.github.io/posts/d73b0b5a/"/>
    <id>https://superq314.github.io/posts/d73b0b5a/</id>
    <published>2022-09-28T12:15:16.000Z</published>
    <updated>2022-10-06T12:08:56.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p><p>到这里，大家应该有个大概的了解了，GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息。</p><p>1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>*注意：这里安全的含义仅仅是指是非修改信息。</p><p>(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：</p><p>幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。</p><p>幂等有一下几种定义：</p><p>对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)&#x3D;abs(abs(a))。</p><p>对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x)&#x3D;x。</p><p>看完上述解释后，应该可以理解GET幂等的含义了。</p><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><p>2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。</p><p>上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：</p><p>1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。</p><p>2.对资源的增，删，改，查操作，其实都可以通过GET&#x2F;POST完成，不需要用到PUT和DELETE。</p><p>3.另外一个是，早期的WebMVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的WebMVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。</p><p>*简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</p><p>以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(RepresentationalStateTransfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTfulWebServices》。</p><p>说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：</p><p>1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name&#x3D;hyddd&amp;password&#x3D;idontknow&amp;verify&#x3D;%E4%BD%A0%E5%A5%BD。如果数据是英文字母&#x2F;数字，原样发送，如果是空格，转换为+，如果是中文&#x2F;其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST把提交的数据则放置在是HTTP包的包体中。</p><p>2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p><p>以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：</p><p>(1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。</p><p>(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K&#x2F;100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。</p><p>对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。</p><p>由这个延伸出去，对于IIS6.0，微软出于安全考虑，加大了限制。我们还需要注意：</p><p>1).IIS6.0默认ASPPOST数据量最大为200KB，每个表单域限制是100KB。</p><p>2).IIS6.0默认上传文件的最大大小是4MB。</p><p>3).IIS6.0默认最大请求头是16KB。</p><p>IIS6.0之前没有这些限制。</p><p>所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。</p><p>3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(&quot;XXXX&quot;)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name&#x3D;hyddd&amp;password&#x3D;hyddd，用request.getQueryString()得到的是：name&#x3D;hyddd&amp;password&#x3D;hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。</p><p>4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-siterequestforgery攻击。</p><p>总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！</p><p>从<strong>数据包</strong>、<strong>编码方式</strong>、<strong>请求参数</strong>、<strong>收藏为书签</strong>、<strong>历史记录</strong>、<strong>安全性</strong>等几方面回答。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoulHqEe98uNmf1Jcj0p5Wvj8sA2bAJeobXuPcXF7kuf9RUvuW9iabmrCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><table><thead><tr><th>请求方式</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>数据包</td><td>产生一个 <code>TCP</code>数据包</td><td>可能产生两个 <code>TCP</code>数据包</td></tr><tr><td>数据位置</td><td>query string</td><td>request body</td></tr><tr><td>编码方式</td><td>只能进行 <code>url</code>编码</td><td>支持多种编码方式</td></tr><tr><td>请求参数</td><td>把参数包含在 <code>url</code>中，用 <code>&amp;</code>连接起来</td><td>通过 <code>request body</code>传递参数</td></tr><tr><td>请求缓存</td><td>会被主动 <code>Cache</code></td><td>不会缓存,除非手动设置</td></tr><tr><td>收藏为书签</td><td>支持</td><td>不支持</td></tr><tr><td>历史记录</td><td>参数会被完整保留在浏览历史记录里</td><td>不会保留</td></tr><tr><td>参数数据类型</td><td><code>ASCII</code>的字符</td><td></td></tr><tr><td>语义</td><td>在服务器上查询数据并返回</td><td>增加新资源，修改已有资源</td></tr><tr><td>安全性</td><td>低于post</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>compose和pipe函数</title>
    <link href="https://superq314.github.io/posts/82dafe4d/"/>
    <id>https://superq314.github.io/posts/82dafe4d/</id>
    <published>2022-09-23T06:48:12.000Z</published>
    <updated>2022-09-30T13:34:43.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Compose函数</button></li><li class="tab"><button type="button" data-href="#super-2">Pipe函数</button></li><li class="tab"><button type="button" data-href="#super-3">链式调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>定义：为了便于连续执行方法，把调用传值整个过程封装成函数，即为compose函数。只需要告诉compose函数需要执行哪些方法，其会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// arguments</span></span><br><span class="line">    <span class="keyword">const</span> args = [].<span class="property">slice</span>.<span class="title function_">apply</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _result = num;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(var i = args.length - 1; i &gt;= 0; i—) &#123;</span></span><br><span class="line"><span class="comment">            _result = args[i](_result);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return _result; </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        <span class="keyword">return</span> args.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">res, cb</span>) =&gt;</span> <span class="title function_">cb</span>(res), num); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(addThree, addTwo, minusOne, multiplyTwo)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>和compose函数功能一样，执行方向相反</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>用promise组成链式调用（此处和面向对象的链式调用有所区别）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>reflect反射机制</title>
    <link href="https://superq314.github.io/posts/41365fed/"/>
    <id>https://superq314.github.io/posts/41365fed/</id>
    <published>2022-09-23T01:16:27.000Z</published>
    <updated>2022-09-30T13:34:43.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>MDN定义：<br>Reflect是一个内置的对象，用来提供方法去拦截JavaScript的操作。Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，你不能通过 <code>new</code>操作符去新建或者将其作为一个函数去调用Reflect对象。Reflect的所有属性和方法都是静态的。</p></blockquote><p>反射机制指的是程序在运行时能够获取自身的信息。js 中的 apply 就是反射机制。</p><p><strong>Reflect API 汇总</strong><br>Reflect 提供了一套用于操作对象的 API（静态方法）</p><table><thead><tr><th><strong>handler⽅法</strong></th><th><strong>默认设置调⽤</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>get</td><td>Reflect.get(target, name, receiver)</td><td>获得目标的身上某一特性的值</td></tr><tr><td>set</td><td>Reflect.set(target, name, value, receiver)</td><td>在目标上设定特性</td></tr><tr><td>has</td><td>Reflect.has(obj, name)</td><td>分辨一个目标是不是存有某一特性</td></tr><tr><td>deleteProperty</td><td>Reflect.deleteProperty(obj, name)</td><td>删掉目标上的特性</td></tr><tr><td>getProperty</td><td>Reflect.getPrototypeOf(obj)</td><td>获得特定目标原形的涵数</td></tr><tr><td>setProperty</td><td>Reflect.setPrototypeOf(obj, newProto)</td><td>设定或更改目标原形的涵数</td></tr><tr><td>isExtensible</td><td>Reflect.isExtensible(target)</td><td>分辨一个目标是不是可拓展（即是不是可以加上新的特性）</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions(target)</td><td>阻拦新特性加上到目标</td></tr><tr><td>getOwnPropertyDescriptor</td><td>Reflect.getOwnPropertyDescriptor(target, propertyKey)</td><td>获得给出特性的特性描述符</td></tr><tr><td>defineProperty</td><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>界定或改动一个目标的特性</td></tr><tr><td>ownKeys</td><td>Reflect.ownKeys()</td><td>回到由总体目标目标本身的特性键构成的二维数组</td></tr><tr><td>apply</td><td>Reflect.apply(func, thisArg, args)</td><td>对一个涵数开展启用实际操作，另外能够传到一个二维数组做为启用主要参数</td></tr><tr><td>construct</td><td>Reflect.construct(target, args)</td><td>对构造方法开展new实际操作，完成建立类的案例</td></tr><tr><td>preventExtensions</td><td>Reflect.preventExtensions()</td><td>阻拦新特性加上到目标</td></tr></tbody></table><p><strong>Reflect对象的作用&#x2F;优点</strong></p><ol><li>把实现反射机制的方法重新归结在一起并且简化操作，保持JS语意清晰和语法简单</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> k = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; [s]: <span class="number">1</span>, [k]: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// getOwnPropertyNames获取到String类型的key</span></span><br><span class="line"><span class="comment">// getOwnPropertySymbols获取到Symbol类型的key</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// 使用Reflect的话：</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o);</span><br></pre></td></tr></table></figure><ol start="2"><li>补充一些Object对象没有的方法（如Reflect.apply）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">…rest</span>)&#123;</span><br><span class="line">  consloe.<span class="title function_">log</span>(rest);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello:`</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="property">apply</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(fn, &#123;<span class="attr">name</span>: <span class="string">`小明`</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="attr">hello</span>: <span class="string">`小明`</span></span><br></pre></td></tr></table></figure><ol start="3"><li>让Object操作都变为函数行为，比如使用Reflect.has(obj, name)替换name in obj</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">`id`</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, <span class="string">`id`</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ok`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>proxy</title>
    <link href="https://superq314.github.io/posts/7372c9be/"/>
    <id>https://superq314.github.io/posts/7372c9be/</id>
    <published>2022-09-23T01:14:37.000Z</published>
    <updated>2022-09-30T13:34:43.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Proxy是ES6中提供的新的API<br>proxy代理：在目标对象的前面设置一个拦截层，外界在访问这个对象的时候，必须经过拦截层。</p><blockquote><p>我们可以在拦截层做一些过滤或者是改写的操作。<br>语法<br><code>var proxy = new Proxy(target, handler);</code><br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中：</p></blockquote><ul><li>new Proxy() 表示生成一个 Proxy 实例</li><li>target 参数表示所要拦截的目标对象可以是一个object或者function</li><li>handler 参数也是一个对象，用来定制拦截行为;如果handler没有设置任何拦截，那就等同于直接通向原对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="Proxy" scheme="https://superq314.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>generator生成器</title>
    <link href="https://superq314.github.io/posts/8706750a/"/>
    <id>https://superq314.github.io/posts/8706750a/</id>
    <published>2022-09-22T14:51:13.000Z</published>
    <updated>2022-10-06T12:28:01.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Generatror函数有两个特征：</p><ul><li>function关键字与函数名之间有一个星号</li><li>函数体内部使用yield语句，定义不同的内部状态</li></ul><p>生成器它能像迭代一样返回一个迭代器对象，然后调用 next 方法进行抽取。<br>Generator函数有多种理解角度。从语法上，可以把它理解成一个状态机，封装了多个内部状态。<br>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">createIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>　　在这个示例中，createlterator()前的星号表明它是一个生成器；yield关键字也是ES6的新特性，可以通过它来指定调用迭代器的next()方法时的返回值及返回顺序。生成迭代器后，连续3次调用它的next()方法返回3个不同的值，分别是1、2和3。生成器的调用过程与其他函数一样，最终返回的是创建好的迭代器<br>　　生成器函数最有趣的部分是，每当执行完一条yield语句后函数就会自动停止执行。举个例子，在上面这段代码中，执行完语句yield 1之后，函数便不再执行其他任何语句，直到再次调用迭代器的next()方法才会继续执行yield 2语句。生成器函数的这种中止函数执行的能力有很多有趣的应用<br>　　使用yield关键字可以返回任何值或表达式，所以可以通过生成器函数批量地给迭代器添加元素。例如，可以在循环中使用yield关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在此示例中，给生成器函数createlterator()传入一个items数组，而在函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个yield语句循环都会停止；每次调用迭代器的next()方法，循环会继续运行并执行下一条yield语句<br>　　生成器函数是ES6中的一个重要特性，可以将其用于所有支持函数使用的地方</p><h2 id="【使用限制】"><a href="#【使用限制】" class="headerlink" title="【使用限制】"></a>【使用限制】</h2><p>yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从字面上看，yield关键字确实在createlterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误</p><h2 id="【生成器函数表达式】"><a href="#【生成器函数表达式】" class="headerlink" title="【生成器函数表达式】"></a>【生成器函数表达式】</h2><p>　　也可以通过函数表达式来创建生成器，只需在function关键字和小括号中间添加一个星号(*)即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: 3, done: false &#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>　　在这段代码中，createlterator()是一个生成器函数表达式，而不是一个函数声明。由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间。此外，这个示例基本与前例相同，使用的也是for循环<br>　　[注意]不能用箭头函数来创建生成器</p><h2 id="【生成器对象的方法】"><a href="#【生成器对象的方法】" class="headerlink" title="【生成器对象的方法】"></a>【生成器对象的方法】</h2><p>　　由于生成器本身就是函数，因而可以将它们添加到对象中。例如，在ES5风格的对象字面量中，可以通过函数表达式来创建生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">createIterator</span>: <span class="keyword">function</span> *(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　也可以用ES6的函数方法的简写方式来创建生成器，只需在函数名前添加一个星号(*)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  *<span class="title function_">createIterator</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = o.<span class="title function_">createIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>　　这些示例使用了不同于之前的语法，但它们的功能实际上是等价的。在简写版本中，由于不使用function关键字来定义createlterator()方法，因此尽管可以在星号和方法名之间留白，但还是将星号紧贴在方法名之前</p><h2 id="【状态机】生成器的一个常用功能是生成状态机"><a href="#【状态机】生成器的一个常用功能是生成状态机" class="headerlink" title="【状态机】生成器的一个常用功能是生成状态机"></a>【状态机】生成器的一个常用功能是生成状态机</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = <span class="title function_">state</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;C&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;A&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(status.<span class="title function_">next</span>().<span class="property">value</span>);<span class="comment">//&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="应用场景：通过yield-实现非线性迭代"><a href="#应用场景：通过yield-实现非线性迭代" class="headerlink" title="应用场景：通过yield*实现非线性迭代"></a>应用场景：通过yield*实现非线性迭代</h2><p>yield关键字后面可以跟随另一个generator对象或其他可迭代对象。<br>可以利用这个特性实现非线性结构的遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘a1’</span><br><span class="line">  <span class="keyword">yield</span> ‘a2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> ‘b1’</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">a</span>()</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">yield</span> ‘b2’</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="title function_">b</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b1 a1 a2 1 2 b2</span></span><br></pre></td></tr></table></figure><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">next</button></li><li class="tab"><button type="button" data-href="#super-2">throw</button></li><li class="tab"><button type="button" data-href="#super-3">return</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>ES6规范中规定迭代器必须有一个next方法，这个方法会返回一个对象，这个对象具有done和value两个属性，done表示当前迭代器内容是否已经执行完，执行完为true，否则为false，value表示当前步骤返回的值。在generator具体运用中，每次遇到yield关键字都会暂停执行，当调用迭代器的next时，会将yield后面表达式的值作为返回对象的value，比如上面生成器的执行结果如下:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795897786.png" alt="1664795897786"><br>我们可以看到第一次调next返回的就是第一个yeild后面表达式的值，也就是1。需要注意的是，整个迭代器目前暂停在了第一个yield这里，给变量a赋值都没执行，要调用下一个next的时候才会给变量a赋值，然后一直执行到第二个yield。那应该给a赋什么值呢？从代码来看，a的值应该是yield语句的返回值，但是yield本身是没有返回值的，或者说返回值是undefined，如果要给a赋值需要下次调next的时候手动传进去，我们这里传一个4，4就会作为上次yield的返回值赋给a:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795908411.png" alt="1664795908411"><br>可以看到第二个yield后面的表达式a + 2的值是6，这是因为我们传进去的4被作为上一个yield的返回值了，然后计算a + 2自然就是6了。<br>我们继续next，把这个迭代器走完：<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795913662.png" alt="1664795913662"><br>上图是接着前面运行的，图中第一个next返回的value是NaN是因为我们调next的时候没有传参数，也就是说b为undefined，undefined + 3就为NaN了 。最后一个next其实是把函数体执行完了，这时候的value应该是这个函数return的值，但是因为我们没有写return，默认就是return undefined了，执行完后done会被置为true。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>迭代器还有个方法是throw，这个方法可以在函数体外部抛出错误，然后在函数里面捕获，还是上面那个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();  </span><br></pre></td></tr></table></figure><p>我们这次不用next执行了，直接throw错误出来:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795946858.png" alt="1664795946858"><br>这个错误因为我们没有捕获，所以直接抛到最外层来了，我们可以在函数体里面捕获他，稍微改下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();  </span><br></pre></td></tr></table></figure><p>然后再来throw下：<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795968330.png" alt="1664795968330"><br>这个图可以看出来，错误在函数里里面捕获了，走到了catch里面，这里面只有一个console同步代码，整个函数直接就运行结束了，所以done变成true了，当然catch里面可以继续写yield然后用next来执行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>迭代器还有个return方法，这个方法就很简单了，他会直接终止当前迭代器，将done置为true，这个方法的参数就是迭代器的value，还是上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">gen</span>();</span><br></pre></td></tr></table></figure><p>这次我们直接调用return:<br><img src="/image/generator%E7%94%9F%E6%88%90%E5%99%A8/1664795994234.png" alt="1664795994234"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>iterator迭代器</title>
    <link href="https://superq314.github.io/posts/a5155495/"/>
    <id>https://superq314.github.io/posts/a5155495/</id>
    <published>2022-09-22T14:50:35.000Z</published>
    <updated>2022-10-06T12:25:24.568Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="遍历和迭代的区别"><a href="#遍历和迭代的区别" class="headerlink" title="遍历和迭代的区别"></a>遍历和迭代的区别</h2><p>迭代：从目标源依次按逐个抽取的方式来提取数据，其中目标源满足：</p><blockquote><p>1、有序的<br>2、连续的<br>遍历：没有这些要求，对于不同数据类型有着不同的遍历方式。</p></blockquote><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>迭代器对象是一种接口，也可以说是一种规范。<br>为各种不同的数据结构提供统一的访问机制。<br>任何数据结构只要部署Iterator接口，就可以完成遍历操作。<br>本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。<br>只要拥有了该属性，就能够用迭代器的方式进行遍历。</p></blockquote><h2 id="数组的Symbol-iterator属性"><a href="#数组的Symbol-iterator属性" class="headerlink" title="数组的Symbol.iterator属性"></a>数组的Symbol.iterator属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">// 获取数组中的迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="手动实现Symbol-iterator"><a href="#手动实现Symbol-iterator" class="headerlink" title="手动实现Symbol.iterator"></a>手动实现Symbol.iterator</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> make <span class="title class_">Iterator</span>(arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next () &#123;</span><br><span class="line">      <span class="keyword">if</span>(idx &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: arr[idx++],</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现对象的自定义迭代器对象"><a href="#实现对象的自定义迭代器对象" class="headerlink" title="实现对象的自定义迭代器对象"></a>实现对象的自定义迭代器对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mp = <span class="keyword">new</span> <span class="title class_">Map</span>([[‘a’, <span class="number">1</span>], [‘b’, <span class="number">2</span>], [’c’, <span class="number">3</span>]]);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        <span class="keyword">let</span> mpEntries = […, mp.<span class="title function_">entries</span>()];</span><br><span class="line">        <span class="keyword">if</span>(idx &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: mp[idx++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>iterator必须实现next方法，该方法每次被调用时返回一个迭代器结果。</p><ul><li>next()：被调用时返回一个iteratorResult对象</li><li>return()：被调用时返回一个iteratorResult对象，通常在调用者希望提前结束迭代时调用</li><li>throw()：被调用时返回一个iteratorResult对象，通常在调用者检测到错误时被调用</li></ul><h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><p>对象必须提供一个next()，执行该方法后 &#x3D;&gt; 要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代<br>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性</p><ul><li>value属性：迭代未完成时，返回当前位置的元素；迭代完成后，返回迭代器返回值或者缺省</li><li>done属性：一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()<br>  对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</li></ul><h2 id="遍历过程："><a href="#遍历过程：" class="headerlink" title="遍历过程："></a>遍历过程：</h2><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ol><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of使用</li></ol><h2 id="原生具备-Iterator-接口的数据结构"><a href="#原生具备-Iterator-接口的数据结构" class="headerlink" title="原生具备 Iterator 接口的数据结构"></a>原生具备 Iterator 接口的数据结构</h2><p>可用<code>for..of</code>直接迭代出来的有:</p><ul><li><code>Array</code></li><li><code>Map</code></li><li><code>Set</code></li><li><code>String</code></li><li><code>TypedArray</code></li><li>函数的<code>arguments</code>（类数组对象）</li><li><code>DOM</code>中的<code>NodeList</code>（类数组对象）</li></ul><p>如果一个数据类型能迭代的话，会在原型上存在 Symbol(Symbol.iterator)方法</p><blockquote><p>总结：调用Symbol(Symbol.iterator)方法将会返回一个 迭代器对象，而这个迭代器对象具备 next() 方法，通过这个方法来实现逐步调用，同时每次调用的时候会返回一个对象，包括 value 和 done 两个属性，当value为 undefined，done 为 true 时迭代完成。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://superq314.github.io/posts/58add7e9/"/>
    <id>https://superq314.github.io/posts/58add7e9/</id>
    <published>2022-09-22T14:47:01.000Z</published>
    <updated>2022-09-30T13:34:43.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>跨域问题的解决方式<br>1、通过Jsonp<br>2、Document.domain + Iframe跨域<br>3、Iocation.hash + Iframe跨域<br>4、Window.name+Iframe跨域<br>5、PostMessage跨域<br>6、跨域资源共享（CORS）<br>7、nginx代理跨域<br>8、nodeJavaScripr中间代理跨域<br>9、WebSocket协议跨域</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://superq314.github.io/posts/3bf3e06d/"/>
    <id>https://superq314.github.io/posts/3bf3e06d/</id>
    <published>2022-09-22T14:46:36.000Z</published>
    <updated>2022-09-30T13:34:43.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jQuery<br>sass、less &#x3D;&gt; CSS预处理器<br>less：动态样式语言，给CSS赋予动态语言特性<br>动态语言特性：变量、继承、嵌套</p><p>跨域原因：<br>由于前后端分离 &#x3D;&gt; 前后端域名不一致 &#x3D;&gt; 出现跨越访问问题<br>同源策略 &#x3D;&gt; 只有协议 + 主机名 + 端口号相同（允许访问）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="https://superq314.github.io/posts/c5a6a264/"/>
    <id>https://superq314.github.io/posts/c5a6a264/</id>
    <published>2022-09-22T14:46:20.000Z</published>
    <updated>2022-09-30T13:34:43.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AJAX &#x3D;&#x3D;&gt; 创建快速动态网页 &#x3D;&#x3D;&gt; 网页异步更新<br>核心：XMLHttpRequest对象<br>创建过程：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest) &#123;xhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// code for IE5,IE6  </span></span><br><span class="line">  xhttp = <span class="keyword">new</span> <span class="type">ActiveXobject</span>(“Microsoft.XMLHTTP”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax使用过程（5个步骤）<br>1、创建XMLHTTPRequest对象<br>2、使用open方法创建http请求，并设置请求地址xhr.open(get&#x2F;post, url, asynchronous,true异步, false同步)<br>3、设置发送的数据，用send发送请求<br>4、注册事件（给Ajax设置事件）<br>5、获取响应并更新页面</p><p>AJAX的XMLHttpRequest对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">new XMLHttpRequest()</td><td>创建新的XMLHttpRequest对象</td></tr><tr><td align="center">abort()</td><td>取消当前请求</td></tr><tr><td align="center">getAllResponseHeaders()</td><td>返回头部信息</td></tr><tr><td align="center">getResponseHeader()</td><td>返回特定的头部信息</td></tr><tr><td align="center">open(method, url, async, user, psw)</td><td>method：规定请求类型GET或POST<br />url：文件位置<br />async：true(异步)或false(同步)<br />user：可选的用户名<br />psw：可选的密码</td></tr><tr><td align="center">send()</td><td>将请求发送到服务器，用于GET 请求</td></tr><tr><td align="center">send(string)</td><td>将请求发送到服务器，用于POST 请求</td></tr><tr><td align="center">setRequestHeader()</td><td>向要发送的报头添加标签&#x2F;值对</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>class的继承</title>
    <link href="https://superq314.github.io/posts/405302ea/"/>
    <id>https://superq314.github.io/posts/405302ea/</id>
    <published>2022-09-22T14:38:38.000Z</published>
    <updated>2022-09-30T13:34:43.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>class的继承<br>JavaScript 实现继承是件麻烦事，构造函数继承有加上原型上的函数不能复用的问题；原型链继承又存在引用值属性的修改不独立的问题；组合继承又存在两次调用构造函数的问题，寄生组合继承，写起来又太麻烦了</p><p>class的继承围绕三点进行展开描述：extends实现继承，super()引用父类的构造函数，多重继承。<br>1、如何实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>通过关键字<span class="keyword">extends</span>实现继承。具体操作步骤如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitename</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">present</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我喜欢&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sitename</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Site</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">present</span>() + <span class="string">&#x27;, 它创建了 &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; 年。&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> noob = <span class="keyword">new</span> <span class="title class_">Runoob</span>(<span class="string">&quot;菜鸟教程&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>子类必须在constructor方法中调用super方法<br>为什么必须要调用super方法呢？<br>这是因为这里的继承是先塑造父类，再塑造子类。也就是先将父类的东西都拿过来之后，再进行子类的添加。而super负责的就是将父类的东西拿过来。所以必须先调用super。</li><li>调用super之后才能使用this。也就是说在子类构造函数constructor里面，super函数要放在最上面。<br>为什么要这样呢？<br>刚才提到过，class的继承是先将父类拿过来再进行子类的添加，之前在讲借用构造函数实现继承的时候也提到过，如果想要给自身添加属性和方法，需要在调用call或者apply之后添加。否则如果存在同名属性，后面的会覆盖前面的。这里其实也是同样的道理。<br>2、super<br>class里面的super有两种使用方式，一种是当方法用，一种是当对象用。</li><li>当方法用<br>当方法用就像上面提到的，在constructor里面调用，负责将父类的实例属性拿过来。这个时候，super里面的this指向的是子类。<br>为什么这样呢？其实和借用构造函数实现继承是一样的，子类继承超类的实例属性时，就是通过call或者apply在子类调用超类构造函数。这个时候，this自然指向的就是子类。<br>还要注意一点 的是，其实上面也提到了，当方法用的时候，super必须放到constructor构造函数的最上层</li><li>当对象用<br>上一点说了，当方法用是为了将父类的实例属性继承过来(其实就是复制一份过来)。实例属性是拿到了，但方法呢，比如说有时候子类的方法想要调用父类的某个方法，这个时候要如何做？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;speak&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">speak</span>() <span class="comment">// speak</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">a.<span class="title function_">sayName</span>()</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">speak</span>()</span><br></pre></td></tr></table></figure><p>这个时候，super作为对象的所用就体现出来了，通过它可以调用父类的方法(包括静态方法)。<br>注意，不同类型的方法要在不同类型的方法里面调用。有点绕，其实就是子类的静态方法里面通过super只能调用父类的静态方法，不能调用父类的原型方法。同理，子类的原型方法通过super也只能调用父类的原型方法，不能调用父类的静态方法。<br>有点像组合继承，super方法就是借用构造函数继承，继承实例属性，super对象就是原型链继承，继承原型上的属性和方法。也就是说super对象是无法访问父类的实例属性的。<br>那么还有一个问题，通过super调用父类的方法，那么该方法内的this指向的是谁呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayName</span>() <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857835921.png" alt="1663857835921"><br>结果就是，this指向的是当前类(子类)的实例。所以我们通过super对某个属性进行修改，修改的就是子类实例的属性。<br>3、多重继承<br>有些面向对象编程语言是支持多重继承(即一个子类继承多个父类)，如c++， py。java不支持多继承，但可以通过实现多接口或者内部类的方式实现类似的效果。es6的class继承本质上还是基于原型链的继承，所以也是不支持多继承的。但就像java那样，我们也可以通过其他方式达到相同或者类似的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Person&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;说话&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&#x27;19&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进食&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="comment">// 多重继承 一个子类继承多个父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">...mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        <span class="comment">// 拷贝实例属性</span></span><br><span class="line">        <span class="title function_">copyProperties</span>(<span class="variable language_">this</span>, <span class="keyword">new</span> <span class="title function_">mixin</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>, mixin) <span class="comment">// 拷贝静态属性</span></span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>.<span class="property"><span class="keyword">prototype</span></span>, mixin.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 拷贝原型属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mix</span>&#125;<span class="keyword">function</span> <span class="title function_">copyProperties</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="comment">// Reflect.ownKeys 返回所有属性key</span></span><br><span class="line">  <span class="comment">// Object.keys 返回属性key，不包括不可枚举属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;constructor&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;prototype&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// Object.getOwnPropertyDescriptor 返回指定对象上一个自有属性对应的属性描述符。</span></span><br><span class="line">      <span class="comment">// 自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性</span></span><br><span class="line">      <span class="comment">// 属性描述符指的是configurable、enumerable、writable、value这些</span></span><br><span class="line">      <span class="keyword">const</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, key)</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, desc)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;<span class="keyword">class</span> <span class="title class_">Other</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixin</span>(<span class="title class_">Animal</span>, <span class="title class_">Person</span>) &#123;&#125;<span class="keyword">const</span> oo = <span class="keyword">new</span> <span class="title class_">Other</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oo)</span><br></pre></td></tr></table></figure><p><img src="/image/class%E7%9A%84%E7%BB%A7%E6%89%BF/1663857864873.png" alt="1663857864873"><br>通过以上方式，也可以间接地实现类似多重继承的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="继承" scheme="https://superq314.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="class" scheme="https://superq314.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="https://superq314.github.io/posts/7ec024ea/"/>
    <id>https://superq314.github.io/posts/7ec024ea/</id>
    <published>2022-09-22T14:31:56.000Z</published>
    <updated>2022-09-30T13:34:43.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在es5中主要是通过构造函数方式和原型方式来定义一个类<br>在es6中可以通过class来定义类。<br>一个类只能拥有一个名为”constructor”构造函数，不能出现多个；<br>如果没有定义”constructor”构造函数，class会默认添加一个空的“constructor”构造函数。</p><h3 id="1、class类必须进行new调用，不能直接执行"><a href="#1、class类必须进行new调用，不能直接执行" class="headerlink" title="1、class类必须进行new调用，不能直接执行"></a>1、class类必须进行new调用，不能直接执行</h3><p>使用new调用类的构造函数会执行如下操作。<br>1.在内存中创建一个新对象；<br>2.这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性；<br>3.构造函数内部的this被赋值为这个新对象（即this指向新对象）；<br>4.执行构造函数内部的代码（给新对象添加属性）；<br>5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；</p><h3 id="2、class类不存在变量提升"><a href="#2、class类不存在变量提升" class="headerlink" title="2、class类不存在变量提升"></a>2、class类不存在变量提升</h3><h3 id="3、class类无法遍历其实例原型链上的属性和方法"><a href="#3、class类无法遍历其实例原型链上的属性和方法" class="headerlink" title="3、class类无法遍历其实例原型链上的属性和方法"></a>3、class类无法遍历其实例原型链上的属性和方法</h3><p>不可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ES6</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">newTest2</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// [ ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">ES6</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">// [&quot;constructor&quot;,&quot;newTest&quot;,&quot;newTest2&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="4、new-target属性"><a href="#4、new-target属性" class="headerlink" title="4、new.target属性"></a>4、new.target属性</h3><p>es6为new命令引入了一个new.target属性，它会返回new命令作用于的那个构造函数。<br>如果不是通过new调用或Reflect.construct()调用的，new.target会返回undefined</p><h3 id="5、class类有static静态方法"><a href="#5、class类有static静态方法" class="headerlink" title="5、class类有static静态方法"></a>5、class类有static静态方法</h3><p>static静态方法只能通过类调用，不会出现在实例上；<br>静态方法包含 this 关键字，这个 this 指的是类，而不是实例<br>static声明的静态属性和方法都可以被子类继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">baz</span>(); <span class="comment">// 此处的this指向类</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 不会出现在实例中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">bar</span>() <span class="comment">// undefined</span></span><br><span class="line">foo.<span class="title function_">baz</span>() <span class="comment">// world</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">bar</span>() <span class="comment">// this Foo hello </span></span><br></pre></td></tr></table></figure><p>getter 与 setter <br>在 class 内部可以使用 get 与 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (test) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = test || <span class="string">&#x27;默认值&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    get prop () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">test</span></span><br><span class="line">    &#125;</span><br><span class="line">    set prop (value) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setter prop value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">test</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 1</span></span><br><span class="line">p.<span class="property">prop</span> = <span class="string">&#x27;2&#x27;</span> <span class="comment">// setter prop value: 2</span></span><br><span class="line">p.<span class="property">prop</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>默认严格模式<br>内部定义inside<br>立即执行<br>二次声明<br>实例无法调用static<br>static this指向类<br>继承包含static<br>Class内部只有静态方法，没有静态属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ES新特性" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="ES6" scheme="https://superq314.github.io/tags/ES6/"/>
    
    <category term="class" scheme="https://superq314.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>尾调用</title>
    <link href="https://superq314.github.io/posts/44a5189f/"/>
    <id>https://superq314.github.io/posts/44a5189f/</id>
    <published>2022-09-22T13:59:27.000Z</published>
    <updated>2022-09-30T13:34:43.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>定义：在执行某个函数时，如果最后一步是一个函数调用，并且被调用函数的返回值直接被函数返回，被称为尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>();<span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下两种情况，都不属于尾调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line"><span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内存中形成一个”调用记录”，又称”调用帧”，保存调用位置和内部变量等信息。</p><ol><li>函数A内部调用函数B，那么在A的调用记录上方，会形成一个B的调用记录。</li><li>等到B运行结束，将结果返回到函数A，B的调用记录才会消失。</li><li>如果函数B内部还调用了函数C，那还有一个C的调用记录栈，以此类推。</li><li>所有的调用记录形成一个”调用栈”。<br><img src="/image/%E5%B0%BE%E8%B0%83%E7%94%A8/1663855333356.png" alt="1663855333356"><br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。<br>尾调用的要求</li><li>尾调用不需要访问当前stackframe中的变量，也就是没有闭包。</li><li>返回到尾调用处时，不用再做其他事情。</li><li>尾调用的返回值，直接返回给调用它所在函数的调用者。</li></ol><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p><blockquote><p>因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>arguments：返回调用时函数的参数。</li><li>func.caller：返回调用当前函数的那个函数。<br>严格模式下开启尾调用优化，函数的调用栈会改写，从而会禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="函数式编程" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="尾调用" scheme="https://superq314.github.io/tags/%E5%B0%BE%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>
