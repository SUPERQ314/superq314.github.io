<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-11-09T07:06:45.801Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS遍历方法</title>
    <link href="https://superq314.github.io/posts/47c8cf9c/"/>
    <id>https://superq314.github.io/posts/47c8cf9c/</id>
    <published>2022-11-09T05:50:55.000Z</published>
    <updated>2022-11-09T07:06:45.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/image/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/1667973588992.png" alt="1667973588992"></p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">数组遍历</button></li><li class="tab"><button type="button" data-href="#super-2">对象遍历</button></li><li class="tab"><button type="button" data-href="#super-3">其他遍历</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">for of</button></li><li class="tab"><button type="button" data-href="#super-2">.forEach()</button></li><li class="tab"><button type="button" data-href="#super-3">.map()</button></li><li class="tab"><button type="button" data-href="#super-4">.filter()</button></li><li class="tab"><button type="button" data-href="#super-5">.some()</button></li><li class="tab"><button type="button" data-href="#super-6">.every()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><strong>语法</strong>：<code>for (variable of iterable)</code><br>两个参数：<br>    * variable：每个迭代的属性值被分配给该变量。<br>    * iterable：一个具有可枚举属性并且可以迭代的对象。</p><p><strong>注意</strong>：</p><blockquote><ul><li>只会遍历当前对象的属性，不会遍历其原型链上的属性</li><li>适用遍历可迭代（数组Array、Map、Set、String、arguments对象、Nodelist对象）</li><li>不支持遍历普通对象，因为其没有迭代器对象。如果想要遍历一个对象的属性，可以用 for in 方法</li><li>可以使用break、continue、return来中断循环遍历</li></ul></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p><strong>作用</strong>：遍历数组中的每个元素，对每个元素执行回调函数<br><strong>语法</strong>：<code>array.forEach(function(currentValue, index, arr), thisArg)</code></p><pre><code>第一个参数为回调函数（必选），有三个参数：    * currentValue：必需。当前元素    * index：可选。当前元素的索引值。    * arr：可选。当前元素所属的数组对象第二个参数thisArg，用来绑定回调函数中的this指向（可选）</code></pre><p><strong>返回值</strong>：无</p><p><strong>注意</strong>：</p><blockquote><ul><li>不会改变原数组，也没有返回值；</li><li>无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue一致；</li><li>无法遍历对象，仅适用于数组的遍历。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, index, obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value + <span class="string">&quot; #### &quot;</span> + index + <span class="string">&quot; #### &quot;</span> + obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p><strong>作用</strong>：返回一个新数组，其中元素为执行回调函数后返回的值（按照原始数组元素顺序依次处理元素）。</p><p><strong>语法</strong>：<code>array.map(function(currentValue,index,arr), thisArg)</code><br>    第一个参数为回调函数（必选），有三个参数：<br>        * currentValue：必须。当前元素的值；<br>        * index：可选。当前元素的索引值；<br>        * arr：可选。当前元素属于的数组对象。<br>    第二个参数thisArg，用来绑定参数函数内部的this变量（可选）</p><p><strong>返回值</strong>：新数组（其中元素为执行callbackFn函数后的返回值）</p><p><strong>注意</strong>：</p><blockquote><ul><li>不会对空数组进行检测；</li><li>遍历数组时会返回一个新数组，不会改变原始数组；</li><li>有返回值，可以return出来，map的回调函数中支持return返回值；</li><li>无法遍历对象，仅适用于数组的遍历。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">65</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = numbers.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers);   <span class="comment">// [65, 20, 11, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);       <span class="comment">// [130, 40, 22, 10]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p><strong>作用</strong>：用于过滤数组，满足条件的元素会被返回</p><p><strong>语法</strong>：<code>array.filter(function(currentValue,index,arr), thisValue)</code><br>    第一个参数为回调函数（必选），有三个参数：<br>        * currentValue：必须。当前元素的值；<br>        * index：可选。当前元素的索引值；<br>        * arr：可选。当前元素属于的数组对象。<br>    第二个参数thisValue，用来绑定参数函数内部的this变量（可选）。</p><p><strong>返回值</strong>：由通过测试的元素组成的新数组，或者[]</p><p><strong>注意</strong>：</p><blockquote><ul><li>可用来移除数组中的undefined、null、NAN等值：</li><li>会返回一个新的数组，不会改变原数组；</li><li>不会对空数组进行检测；</li><li>仅适用于检测数组。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = ages.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// [32, 40]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ages);      <span class="comment">// [10, 20, 24, 32, 40]</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line">result = ages.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// []</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p><strong>作用</strong>：对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，且剩余的元素不会再进行检测，否则就返回false。</p><p><strong>语法</strong>：<code>array.some(function(currentValue,index,arr),thisValue)</code><br>    第一个参数为回调函数（必选），有三个参数：<br>        * currentValue：必须。当前元素的值；<br>        * index：可选。当前元素的索引值；<br>        * arr：可选。当前元素属于的数组对象。<br>    第二个参数thisValue，用来绑定参数函数内部的this变量（可选）。</p><p><strong>返回值</strong>：布尔值（true&#x2F;false）</p><p><strong>注意</strong>：</p><blockquote><ul><li>不会改变原数组，会返回一个布尔值；</li><li>不会对空数组进行检测；</li><li>仅适用于检测数组。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = ages.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line">result = ages.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-6"><p><strong>作用</strong>：对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p><p><strong>语法</strong>：<code>array.every(function(currentValue,index,arr), thisValue)</code><br>    第一个参数为回调函数（必选），有三个参数：<br>        * currentValue：必须。当前元素的值；<br>        * index：可选。当前元素的索引值；<br>        * arr：可选。当前元素属于的数组对象。<br>    第二个参数thisValue，用来绑定参数函数内部的this变量（可选）。</p><p><strong>返回值</strong>：布尔值（true&#x2F;false）</p><p><strong>注意</strong>：</p><blockquote><ul><li>不会改变原数组，会返回一个布尔值；</li><li>不会对空数组进行检测；</li><li>仅适用于检测数组。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = ages.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line">result = ages.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">25</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="/image/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/1667977594610.png" alt="1667977594610"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">for in</button></li><li class="tab"><button type="button" data-href="#super-2">Object.keys()、Object.values()、Object.entries()</button></li><li class="tab"><button type="button" data-href="#super-3">Object.getOwnPropertyNames()</button></li><li class="tab"><button type="button" data-href="#super-4">Object.getOwnPropertySymbols()</button></li><li class="tab"><button type="button" data-href="#super-5">Reflect.ownKeys()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><strong>作用</strong>：用于循环对象属性。循环中的代码每执行一次，就会对对象的属性进行一次操作。</p><p><strong>语法</strong>：<code>for (var in object) {执行的代码块}</code><br>    其中两个参数：<br>        * var：必须。指定的变量可以是数组元素，也可以是对象的属性。<br>        * object：必须。指定迭代的的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;键名：&#x27;</span>, i); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;键值：&#x27;</span>, obj[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">键名：a</span><br><span class="line">键值：<span class="number">1</span></span><br><span class="line">键名：b</span><br><span class="line">键值：<span class="number">2</span></span><br><span class="line">键名：c</span><br><span class="line">键值：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><ul><li>不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。</li></ul></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p><strong>作用</strong>：用来遍历对象，会返回一个由给定对象的自身可枚举属性（不含继承的和Symbol属性）组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致。</p><p><strong>返回值</strong>：</p><blockquote><ul><li>Object.keys()：返回包含对象键名的数组；</li><li>Object.values()：返回包含对象键值的数组；</li><li>Object.entries()：返回包含对象键名和键值的数组。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>, </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>, </span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));   <span class="comment">// 输出结果: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// 输出结果: [1, &#x27;hello&#x27;, 18]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));   <span class="comment">// 输出结果: [[&#x27;id&#x27;, 1], [&#x27;name&#x27;, &#x27;hello&#x27;], [&#x27;age&#x27;, 18]</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>Object.keys()方法返回的数组中的值都是字符串，也就是说不是字符串的key值会转化为字符串。<br>结果数组中的属性值都是对象本身可枚举的属性，不包括继承来的属性。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>与Object.keys()类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回不可枚举的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以用来计算对象中属性的个数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="number">2</span>: <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p><strong>作用</strong>：返回对象自身的 Symbol 属性组成的数组，不包括字符串属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象添加一个不可枚举的 Symbol 属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>)]: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Symbol baz&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给对象添加一个可枚举的 Symbol 属性</span></span><br><span class="line">obj[<span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)] = <span class="string">&#x27;Symbol foo&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[key]) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：Symbol baz Symbol foo</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p><strong>作用</strong>：返回一个数组，包含对象自身的所有属性。</p><p>和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;method&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Non enumerable property&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj))</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj))</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;method&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><ul><li>Object.keys() ：相当于返回对象属性数组；</li><li>Reflect.ownKeys() :相当于Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)</li></ul></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="/image/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/1667977568290.png" alt="1667977568290"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">for循环</button></li><li class="tab"><button type="button" data-href="#super-2">while</button></li><li class="tab"><button type="button" data-href="#super-3">do while</button></li><li class="tab"><button type="button" data-href="#super-4">for await of</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>for循环是应该是最常见的循环方式了，它由三个表达式组成，分别是声明循环变量、判断循环条件、更新循环变量。这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++ )&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行的时候，会先判断执行条件，再执行。for循环可以用来遍历数组，字符串，类数组，DOM节点等。可以改变原数组。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>while循环中的结束条件可以是各种类型，但是最终都会转为布尔值，转换规则如下。<br>    * Boolean：true为真，false为假；<br>    * String：空字符串为假，所有非空字符串为真；<br>    * Number：0为假，非0数字为真；<br>    * null&#x2F;Undefined&#x2F;NaN：全为假；<br>    * Object：全为真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">    num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while和for一样，都是先判断，再执行。只要指定条件为 true，循环就可以一直执行代码。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>先执行再判断，即使初始条件不成立，do&#x2F;while循环也至少会执行一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">    num--;</span><br><span class="line">&#125; <span class="keyword">while</span>(num &gt;= <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>不建议使用do &#x2F; while来遍历数组。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>异步迭代器，该方法是主要用来遍历异步对象。它是ES2018中引入的方法。</p><p>for await…of 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，类数组，Map， Set和自定义的异步或者同步可迭代对象。这个语句只能在 async function内使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Gen</span> (time) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(time)</span><br><span class="line">        &#125;,time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="title class_">Gen</span>(<span class="number">2000</span>),<span class="title class_">Gen</span>(<span class="number">100</span>),<span class="title class_">Gen</span>(<span class="number">3000</span>)]</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>(),item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/image/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/1667977014452.png" alt="1667977014452"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>盒模型</title>
    <link href="https://superq314.github.io/posts/fdff8ae1/"/>
    <id>https://superq314.github.io/posts/fdff8ae1/</id>
    <published>2022-11-07T09:22:58.000Z</published>
    <updated>2022-11-07T15:26:05.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盒模型：在网页中，一个元素占有空间的大小由四个部分组成。</p><blockquote><ul><li>元素的内容（content）</li><li>元素的内边距（padding）</li><li>元素的边框（border）</li><li>元素的外边距（margin）</li></ul></blockquote><p>这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了 <code>css</code>中元素的盒模型。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">二维视图</button></li><li class="tab"><button type="button" data-href="#super-2">三维视图</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p><img src="/image/%E7%9B%92%E6%A8%A1%E5%9E%8B/1665061654322.png" alt="1665061654322"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p><img src="/image/%E7%9B%92%E6%A8%A1%E5%9E%8B/1665061668874.png" alt="1665061668874"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在CSS中，盒子模型可以分成：</p><ul><li>W3C标准盒模型</li><li>IE盒模型<br>默认情况下，盒子模型为W3C标准盒模型</li></ul><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">W3C标准盒模型</button></li><li class="tab"><button type="button" data-href="#super-2">IE怪异盒模型</button></li><li class="tab"><button type="button" data-href="#super-3">两边距重叠问题（margin合并）</button></li><li class="tab"><button type="button" data-href="#super-4">解决纵向重叠问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>标准盒模型是浏览器默认的盒子模型<br>标准模式：按照W3C标准解析执行代码<br><img src="/image/%E7%9B%92%E6%A8%A1%E5%9E%8B/1665061804714.png" alt="1665061804714"><br>在标准盒模型下：</p><ul><li>盒子总宽度 &#x3D; 宽度 + 内边距 + 边框 + 外边距</li><li>盒子总高度 &#x3D; 高度 + 内边距 + 边框 + 外边距<br>即width&amp;height仅仅只包含内容高度，不包含外边距与边框，所以width有240px</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>怪异模式：浏览器各自有解析方式<br><img src="/image/%E7%9B%92%E6%A8%A1%E5%9E%8B/1665061814354.png" alt="1665061814354"><br>从图中可以得到，IE盒模型中：</p><ul><li>盒子总宽度 &#x3D; 宽度 + 外边距</li><li>盒子总高度 &#x3D; 高度 + 外边距<br>即width&amp;height包含内边距&amp;边框，所以如果在IE盒模型下，width是200px</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><ul><li>垂直排列时<ul><li>间距取较大值</li><li>皆为正数 &#x3D;&#x3D;&gt; 取较大值</li><li>皆为负数 &#x3D;&#x3D;&gt; 取绝对值的较大值</li><li>一正一负 &#x3D;&#x3D;&gt; 取和</li></ul></li><li>水平排列时<ul><li>间距取相加值</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>兄弟元素重叠:</p><ul><li>底部元素变为行内盒子: display: inline-block</li><li>底部元素设置浮动: float</li><li>底部元素的position的值为absolute&#x2F; fixed</li></ul><p>父子元素重叠:</p><ul><li>父元素加入: overflow: hidden</li><li>父元素添加透明边框: border:1px solidtr ansparent</li><li>子元素变为行内盒子: display: inline _block子元素加入浮动属性或定位</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">box-sizing属性</button></li><li class="tab"><button type="button" data-href="#super-2">border-radius属性(CSS3)</button></li><li class="tab"><button type="button" data-href="#super-3">overflow属性</button></li><li class="tab"><button type="button" data-href="#super-4">box-shadow属性（CSS3）</button></li><li class="tab"><button type="button" data-href="#super-5">outline属性</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>作用：更改用于计算元素宽&#x2F;高的默认的CSS盒模型</p><ul><li>content-box 默认值<ul><li>盒子实际宽度 &#x3D; padding + border + width</li><li>盒子实际高度 &#x3D; padding + border + height</li></ul></li><li>border-box 默认值<ul><li>盒子实际宽度 &#x3D; width</li><li>盒子实际高度 &#x3D; height</li></ul></li><li>inherit 从父元素继承</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>设置边框圆角<br>纯圆：50% 宽高一样<br>半圆角：<code>height/2 + px</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>作用：定义内容溢出后的处理方式（是否裁剪）。</p><ol><li>visible  &#x3D;&#x3D;&gt;   不做处理（溢出）</li><li>hidden   &#x3D;&#x3D;&gt;   隐藏溢出内容且不出现滚动条（直接裁剪）。</li><li>scroll   &#x3D;&#x3D;&gt;   隐藏溢出内容且溢出内容以滚动条方式呈现（间接裁剪）。</li><li>auto     &#x3D;&#x3D;&gt;   当内容没有溢出时不出现滚动条；当内容溢出容器时出现滚动条，按需出现滚动条。此为body对象和textarea的默认值。</li><li>clip     &#x3D;&#x3D;&gt;   当内联内容溢出块容器时，将溢出部分裁剪。</li><li>ellipsis &#x3D;&#x3D;&gt;   当内联内容溢出块容器时，将溢出部分替换为（…）。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>以逗号分割列表来描述一个或多个阴影效果。<br><img src="/image/%E7%9B%92%E6%A8%A1%E5%9E%8B/1665326340716.png" alt="1665326340716"><br><code>box-shadow: 5px 5px 10px 0 rgba(0, 0, 0, .2);</code><br>属性值介绍：前两个是偏移量（水平位置 + 垂直位置），第三个是模糊区域度，第四个是拓展区域度，第五个是颜色（最后一个是透明度）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p>用来设置一个或多个单独的轮廓属性的简写属性。<br>轮廓和边框的区别：</p><blockquote><p>轮廓不占据空间，不影响布局，其被描绘在内容之上。<br><code>outline: [&lt;outline-width&gt; || &lt;outline-style&gt; || &lt;outline-color&gt;]</code><br><code>outline-width: &lt;length&gt; | thin | medium | thick</code><br><code>outline-style: solid | dashed | dotted | ...</code><br><code>outline-color: &lt;color&gt; | invert</code></p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编程式路由</title>
    <link href="https://superq314.github.io/posts/585d4f9c/"/>
    <id>https://superq314.github.io/posts/585d4f9c/</id>
    <published>2022-11-06T08:55:15.000Z</published>
    <updated>2022-11-07T06:18:22.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>如果要跳转一个路由，可以使用router-link的方式进行跳转，可是这样做有一定的局限性，假设，我们希望在进行路由跳转传入一些参数进去，这个时候，应该怎么操作呢？</p><p>为了解决这一个问题，vue-router就推出了编程式路由，以编程的形式解决路由的跳转问题</p></blockquote><p>编程式路由的跳转常用的两种方式如下：</p><ol><li><p>通过path去跳转</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="symbol">$router</span>.<span class="built_in">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>通过name去跳转</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    backBtn()&#123;</span><br><span class="line">        this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">            name: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">            <span class="regexp">//</span> 传值</span><br><span class="line">            query: &#123;</span><br><span class="line">            id: user.id</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="regexp">//</span> this.<span class="variable">$router</span>.back();<span class="regexp">//</span>回退，类似history.back()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面的两种方式都可以进行路由的跳转，但是它们的应用点不一样，区别主要是在路由的传值方式不一样。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue-生成二维码</title>
    <link href="https://superq314.github.io/posts/57d2b0c5/"/>
    <id>https://superq314.github.io/posts/57d2b0c5/</id>
    <published>2022-11-06T07:55:34.000Z</published>
    <updated>2022-11-07T06:18:22.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="qrcodejs2-生成二维码"><a href="#qrcodejs2-生成二维码" class="headerlink" title="qrcodejs2 生成二维码"></a>qrcodejs2 生成二维码</h2><p>下载qrcodejs2<br><code>cnpm i -S qrcodejs2</code></p><p>使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&quot;qrCodeUrl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">QRCode</span> <span class="keyword">from</span> <span class="string">&quot;qrcodejs2&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">creatQrCode</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">creatQrCode</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">QRCode</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">qrCodeUrl</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">text</span>: <span class="string">&quot;hello 大家好&quot;</span>, <span class="comment">// 需要转换为二维码的内容</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">width</span>: <span class="number">100</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">height</span>: <span class="number">100</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">colorDark</span>: <span class="string">&quot;black&quot;</span>, <span class="comment">//#000000为黑色</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">colorLight</span>: <span class="string">&quot;white&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;二维码:&quot;</span>, a);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/image/Vue-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/1667722575240.png" alt="1667722575240"></p><h2 id="vue-qr-在二维码中心添加图片"><a href="#vue-qr-在二维码中心添加图片" class="headerlink" title="vue-qr 在二维码中心添加图片"></a>vue-qr 在二维码中心添加图片</h2><p>下载:<br><code>cnpm i -S vue-qr</code></p><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vue-qr</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:logoSrc</span>=<span class="string">&quot;imageUrl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">text</span>=<span class="string">&quot;https://blog.csdn.net/qq_40323256/&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:size</span>=<span class="string">&quot;150&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:margin</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">colorDark</span>=<span class="string">&quot;black&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">colorLight</span>=<span class="string">&quot;white&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">vue-qr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> vueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    vueQr,</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">imageUrl</span>: <span class="built_in">require</span>(<span class="string">&quot;@/assets/logo.png&quot;</span>), <span class="comment">//欲嵌入至二维码中心的 LOGO 地址</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/image/Vue-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/1667722648939.png" alt="1667722648939"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vite和webpack优胜劣汰</title>
    <link href="https://superq314.github.io/posts/a8ca6595/"/>
    <id>https://superq314.github.io/posts/a8ca6595/</id>
    <published>2022-10-28T12:53:00.000Z</published>
    <updated>2022-11-03T12:16:36.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vite是什么？"><a href="#Vite是什么？" class="headerlink" title="Vite是什么？"></a>Vite是什么？</h2><p>Vite（法语意思是 “快”）是一种全新的前端构建工具。可以把它理解为一个开箱即用的开发服务器 + 打包工具的组合，类似webpack + webpack-dev-server，但是更轻更快。<br>Vite 利用浏览器原生的 ES 模块支持和用编译到原生的语言开发的工具（如 esbuild）来提供一个快速且现代的开发体验。</p><h2 id="Vite优点是什么"><a href="#Vite优点是什么" class="headerlink" title="Vite优点是什么"></a>Vite优点是什么</h2><p>💡 极速的服务启动</p><blockquote><p>使用原生 ESM 文件，无需打包!</p></blockquote><p>⚡️ 轻量快速的热重载</p><blockquote><p>无论应用程序大小如何，都始终极快的模块热重载（HMR）</p></blockquote><p>🛠️ 丰富的功能</p><blockquote><p>对 TypeScript、JSX、CSS 等支持开箱即用</p></blockquote><p>📦 优化的构建</p><blockquote><p>可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建</p></blockquote><p>🔩 通用的插件</p><blockquote><p>在开发和构建之间共享 Rollup-superset 插件接口</p></blockquote><p>🔑 完全类型化的API</p><blockquote><p>灵活的 API 和完整 TypeScript 类型</p></blockquote><h2 id="Vite与Webpack对比"><a href="#Vite与Webpack对比" class="headerlink" title="Vite与Webpack对比"></a>Vite与Webpack对比</h2><p>Webpack 和 Vite 同是打包工具，有什么区别呢？</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p><img src="/image/vite%E5%92%8Cwebpack%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/1666961805553.png" alt="1666961805553"><br>Webpack 会遍历你的应用程序中的所有文件，并启动一个开发服务器，然后将整个代码渲染到开发环境中。</p><ul><li>webpack从一个entry.js文件开始，将其依赖的所有js或者其他assets通过loader打包成一个文件， 随后这个打包后的文件将被从server传递到客户端浏览器运行。</li><li>为这样的处理规则，当保存文件时，整个 JavaScript 包将由 Webpack 重新构建，这就是为什么更改可能需要长达 10 秒才能反映在浏览器中，更新速度会随着应用体积增长而直线下降。</li></ul><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p><img src="/image/vite%E5%92%8Cwebpack%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/1666961873348.png" alt="1666961873348"><br>Vite 的工作方式不同，它不会遍历整个应用程序，Vite 只是转换当时正在使用的文件&#x2F;模块。</p><ul><li>Vite的核心理念：非捆绑开发构建</li><li>Vite 的核心思想：浏览器请求它时，使用 ES 模块转换并提供一段应用程序代码。</li><li>开始开发构建时，Vite首先将JavaScript 模块分为两类：依赖模块和源码模块。</li><li>依赖项模块是第三方依赖的代码，从node_modules文件夹中导入的JavaScript 模块。这些模块将使用esbuild进行处理和捆绑，esbuild是一个用 Go 编写的 JavaScript 打包工具，执行速度比 Webpack 快 10-100 倍。</li><li>源码模块是源代码，即业务代码，通常涉及特定库的扩展，如：.jsx、.vue、.scss文件。</li><li>它使用基于路由的代码拆分来了解代码的哪些部分实际需要加载，因此，它不必重新打包所有内容。</li><li>它还使用现代浏览器中的原生 ES 模块支持来交付代码，这让浏览器可以在开发中承担打包工作。</li><li>在生产方面，虽然现在所有主流浏览器都支持原生 ES 模块，但它实现了诸如 tree-shaking、延迟加载和通用块拆分等性能优化技术，仍然比非打包应用程序带来更好的整体性能。出于这个原因，Vite附带了一个预先配置的build命令，该命令使用Rollup打包来打包和实现各种性能优化。<br>Webpack 这样的基于打包器的工作流必须在单个浏览器请求之前处理整个 JavaScript 模块，但 Vite 只在单个浏览器请求之前处理依赖模块。这就是为什么 Vite 能够比 Webpack 更快地处理开发构建。</li></ul><h2 id="Storybook对Webpack和Vite的测试"><a href="#Storybook对Webpack和Vite的测试" class="headerlink" title="Storybook对Webpack和Vite的测试"></a>Storybook对Webpack和Vite的测试</h2><p>Storybook是行业标准的 UI 组件工作室。全球数以千计的应用程序和设计系统团队大部分时间都在 Storybook 中工作——构建、记录和测试他们的 UI 组件。因此，Storybook 需要尽可能快地运行项目。Webpack 是 Storybook 的默认构建器。<br>为了比较这Vite和Webpack两个构建器的性能，他们选择针对Carbon Design System运行基准测试。<br>本文从原文中截取了Webpack 5.0 和 Vite的差异，还有 Webpack 4&#x2F;Webpack 5(lc&#x2F;cs)&#x2F;Vite(cs)的差异对比，可以到原文中详细阅读~<br>对比项如下：</p><table><thead><tr><th>场景</th><th align="center">Webpack 5.0</th><th align="center">Vite</th><th>差异</th></tr></thead><tbody><tr><td>开发（冷启动）</td><td align="center">61s</td><td align="center">103s</td><td>Vite首页加载时速度较慢。<br />是因为vite使用浏览器承载部分打包与模块加载工作。<br />因此即使开发服务器快速启动，但是浏览器也需要更多时间来下载和处理所有这些请求</td></tr><tr><td>生产构建时间</td><td align="center">77s</td><td align="center">96s</td><td>Vite 比 Webpack 需要更长的时间来打包资源<br />Vite 不是为单个模块提供服务，而是将所有内容打包在一起，在底层，它使用 Rollup 来完成</td></tr><tr><td>生产构建加载的大小</td><td align="center">11.6M</td><td align="center">9.4M</td><td>Rollup打包的结果会把Dead Code一些无用的代码以及一些不可达的代码清除掉<br />webpack打包的结果这些代码依然存在，打包体积也大<br />所以Vite生产打包加载速度会稍微快一些</td></tr><tr><td>重建时间（热模块重新加载）</td><td align="center">3.67s</td><td align="center">0.53s</td><td>以上Vite并没有z展示出真正的优点<br />真正的优势是保存时在浏览器中查看更改的近乎即时的反馈</td></tr></tbody></table><p>以上是Storybook对项目使用Vite和Webpack不同构建工具的性能的差异测试，可以看出来Vite的真正闪光点在于，开发时浏览器接近实时反馈的效果。</p><h2 id="Vite-入门"><a href="#Vite-入门" class="headerlink" title="Vite 入门"></a>Vite 入门</h2><p>我们浅显的学习一下Vite和Vue3.0创建一个项目，Vite支持流行的前端库，包括 React、Vue 和 Svelte。</p><ol><li><p><code>vite+ts+vue3</code>，执行以下命令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init @vitejs/<span class="keyword">app</span> vite-<span class="keyword">test</span>-<span class="keyword">app</span> --template vue-ts</span><br></pre></td></tr></table></figure></li><li><p>配置路由</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue<span class="operator">-</span>router<span class="variable">@4</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>src</code>下新建<code>router</code>目录，新建<code>index.ts</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter, createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/Home.vue&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">        <span class="attr">redirect</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果设置标题就显示，没设置使用默认</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> != to.<span class="property">meta</span> &amp;&amp; <span class="literal">null</span> != to.<span class="property">meta</span>.<span class="property">title</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> !== to.<span class="property">meta</span>.<span class="property">title</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> || <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_TITLE</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_TITLE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常放行</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li><li><p><code>main.ts</code>挂载路由</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line">createApp(App)</span><br><span class="line">.use(router)</span><br><span class="line">.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>配置数据中心<code>vuex</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i vuex@next --save</span><br></pre></td></tr></table></figure></li><li><p>配置网络请求<code>axios</code><br>在<code>src</code>创建<code>utils</code>文件夹，并在<code>utils</code>下创建<code>axios.ts</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i -s axios</span><br></pre></td></tr></table></figure></li><li><p>配置请求代理<code>vite.config.ts</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line">import vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line">import path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="title function_ invoke__">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_ invoke__">vue</span>()],</span><br><span class="line">  <span class="attr">base</span>:<span class="string">&quot;./&quot;</span>,//打包路径</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>:&#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_ invoke__">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)//设置别名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,</span><br><span class="line">    <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>页面展示：<br><img src="/image/vite%E5%92%8Cwebpack%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/1666962579166.png" alt="1666962579166"><br>以上，一个vite+ts+vue3最基本的移动端开发配置完成。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>Vite</code>是新一代的<code>JavaScript</code>构建工具，通过使用基于<code>ESM</code>的工作流程进行本地开发，确保开发服务器即使在处理大型<code>JavaScript</code>应用程序时也能保持快速</li><li><code>Vite</code>还提供了一个合理的生产构建配置，可以处理基于库的语法，如<code>JSX</code>、<code>Vue</code>和<code>TypeScript</code></li><li>通过在底层使用<code>Rollup</code>，确保生产构建实现性能优化技术，如<code>tree-shaking</code>、延迟加载和常见的块拆分</li></ol><p>虽然<code>Webpack</code>仍然是许多流行应用程序的默认<code>JavaScript</code>构建工具，有很多扩展和一个非常庞大的开发者社区，鉴于社区的积极反馈，<code>Vite</code>很有可能成为未来最受欢迎的选择，但是在社区可以中看到很多新库或框架，有多快或多好并不重要，重要的是社区如何采用它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="Vue项目" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/Vue%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>彻底弄懂Vuex</title>
    <link href="https://superq314.github.io/posts/95c3532e/"/>
    <id>https://superq314.github.io/posts/95c3532e/</id>
    <published>2022-10-27T09:10:23.000Z</published>
    <updated>2022-10-27T09:43:56.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是-Vuex？"><a href="#什么是-Vuex？" class="headerlink" title="什么是 Vuex？"></a>什么是 <code>Vuex</code>？</h2><h3 id="官方的解释"><a href="#官方的解释" class="headerlink" title="官方的解释"></a>官方的解释</h3><blockquote><p><code>Vuex</code>是一个专为<code>Vue.js</code>应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>所谓的 <code>Vuex</code>其实就是一个为 <code>Vue.js</code>设计的数据仓库，就是把各个组件公用的数据放到一个仓库里面进行统一的管理，这样既使得非父子组件间的数据共享变得简单明了，也让程序变得更加可维护（将数据抽离了出来）,而且只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新。</p><h2 id="为什么要使用-Vuex？"><a href="#为什么要使用-Vuex？" class="headerlink" title="为什么要使用 Vuex？"></a>为什么要使用 <code>Vuex</code>？</h2><h3 id="组件间传值复杂"><a href="#组件间传值复杂" class="headerlink" title="组件间传值复杂"></a>组件间传值复杂</h3><p>如果你之前用过 <code>Vue.js</code>开发过项目，你一定会被各个组件之间的传值搞得晕头转向，特别是非父子组件之间传值时。利用 <code>Vuex</code>我们可以将组件之间共享的数据抽取出来，单独存放在一个 <code>store</code>（仓库）中去，这样各个组件需要数据的时候直接去仓库里面拿就好了，不用组件之间复杂的传值了，而且需要改变数据的时候，只需要将仓库里面的数据更改即可，各个组件里面引用的地方会自动更新。</p><h3 id="Vue中的单项数据流"><a href="#Vue中的单项数据流" class="headerlink" title="Vue中的单项数据流"></a><code>Vue</code>中的单项数据流</h3><p><strong>与单向数据流对应的就是双向数据流</strong> ：双向数据流在 <code>Vue</code>中也叫做‘双向绑定’，其实现主要是依靠 <code>MVVM</code>框架，在 <code>Vue</code>中主要由三个部分组成：<code>View</code>、<code>ViewModel</code>、<code>Model</code>。其中 <code>View</code>可以简单的理解为视图层，<code>Model</code>可以简单的理解为数据层，其中View与Model之间是不能直接通信的，必须得依靠ViewModel中间件来完成。通过 <code>ViewModel</code>就可以实现数据双向绑定，也就是 <code>View</code>与 <code>Model</code>之间的同步是自动的，<code>Model</code>数据改变了 <code>View</code>视图上的数据也会跟着改变，而不必手动去更新。具体的原理在这里不是重点，就不细说了，感兴趣的小伙伴可以参考：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862045819.png" alt="1666862045819"></p><p><strong><code>Vue</code>中的单向数据流</strong>：理解单项数据流，我们先来简单看一下官网给出的一张图：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862052359.png" alt="1666862052359"></p><p>我们先来简单理解一下图中三个层说明的什么：<code>View</code>（视图）、<code>Actions</code>（响应状态变化，可以简单理解为 <code>methods</code>等等）、<code>State</code>（数据源，简单理解就是数据）。从图中的箭头我们可以看出，我们通过 <code>Actions</code>改变 <code>State</code>（数据），然后 <code>View</code>（视图）更新，这一个过程是单向的，不会发生 <code>View</code>（视图）改变了，然后 <code>State</code>（数据）更新的情况，这使得我们的数据可控。我们再来看一下官网给出的实例代码，简单明了：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: `</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;&#123;&#123; <span class="keyword">count</span> &#125;&#125;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  `,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上面代码中可以很清楚的反映出图片中的流程。在 <code>Vue</code>中，数据从父组件传递给子组件，只能是单向绑定，子组件内部不能直接修改从父级传过来的数据，这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”（<code>ViewModel</code>）。但是，当我们遇到多个组件同时共享一个状态（数据）时，并且都需要改变状态（数据）时，单项数据的简洁性很容易被破坏，即使我们使用了父子组件的单向数据绑定，但这种模式在这种情况下也会变得非常脆弱，使代码不易维护。</p><p>总结出来就以下两个问题容易破坏单向数据流：</p><blockquote><p>多个视图依赖于同一状态。<br>来自不同视图的行为需要变更同一状态。</p></blockquote><p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p><p>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。</p><h2 id="什么情况下该使用Vuex？"><a href="#什么情况下该使用Vuex？" class="headerlink" title="什么情况下该使用Vuex？"></a>什么情况下该使用Vuex？</h2><blockquote><p><code>Vuex</code> 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。<br>如果您不打算开发大型单页应用，使用 <code>Vuex</code> 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 <code>Vuex</code>。一个简单的store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，<code>Vuex</code> 将会成为自然而然的选择。</p></blockquote><h2 id="构建项目和引入-Vuex"><a href="#构建项目和引入-Vuex" class="headerlink" title="构建项目和引入 Vuex"></a>构建项目和引入 <code>Vuex</code></h2><p>前面为什么要花这么大力气去讲这么多基础知识呢？俗话说：‘万丈高楼拔地起’，只有地基打得牢，后面才能进行得更加顺利。说了这么多，现在终于步如正题了，了解了为什么要使用 <code>Vuex</code>，现在我们就一起探讨一下如何使用它：</p><h3 id="4-1-构建vue-cli项目"><a href="#4-1-构建vue-cli项目" class="headerlink" title="4.1 构建vue-cli项目"></a>4.1 构建vue-cli项目</h3><p>为了方便我们后续的讲解和开发，这里我们使用vue的脚手架工具vue-cli来构建我们的项目，简单列一下操作步骤：</p><ol><li>开发工具：<code>VSCode</code></li><li>开发环境：<code>Node.js</code>环境（<code>npm</code>包管理工具）</li><li>安装 <code>vue-cli</code></li><li>创建 <code>vue-cli</code>项目</li></ol><p><strong>（1）安装 <code>vue-cli</code></strong></p><p>执行命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>安装成功：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862085625.png" alt="1666862085625"></p><p>检查是否安装成功，执行命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue -V</span></span><br></pre></td></tr></table></figure><p>出现版本号则安装成功：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862099375.png" alt="1666862099375"></p><p><strong>（2）构建vue-cli项目</strong></p><p>执行命令：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create <span class="selector-attr">[项目名称]</span> 或者 vue init <span class="built_in">webpack</span>(老版本)</span><br></pre></td></tr></table></figure><p>如图按需勾选是否安装（<code>router</code>建议安装）：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862111292.png" alt="1666862111292"></p><p>安装完成后我们的项目结构大致如下样子，使用 <code>vue-cli3.X</code>版本构建的可能会有所不同：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862118515.png" alt="1666862118515"><br>最后检查项目是否能够正常启动：</p><p>执行命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>出现如图则构建成功：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862130320.png" alt="1666862130320"></p><h3 id="4-2-安装-Vuex并引入项目"><a href="#4-2-安装-Vuex并引入项目" class="headerlink" title="4.2 安装 Vuex并引入项目"></a>4.2 安装 <code>Vuex</code>并引入项目</h3><p><strong>（1）安装 <code>vuex</code></strong></p><p>执行命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex <span class="attr">--save</span></span><br></pre></td></tr></table></figure><p>如图：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862139184.png" alt="1666862139184"></p><p><strong>（2）引入 <code>vuex</code></strong></p><p><strong>1.</strong> 在 <code>src</code>目录下新建一个 <code>store</code>文件夹，并在 <code>store</code>目录下新建 <code>index.js</code><br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862145535.png" alt="1666862145535"></p><p><strong>2.</strong> 在 <code>index.js</code>里面使用 <code>vuex</code>，添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 在main.js中引入store，然后全局注入一下，这样就可以在任何一个组件里面使用它了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">//注册store</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">App</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="开始使用-Vuex"><a href="#开始使用-Vuex" class="headerlink" title="开始使用 Vuex"></a>开始使用 <code>Vuex</code></h2><h3 id="5-1-简单看图理解"><a href="#5-1-简单看图理解" class="headerlink" title="5.1 简单看图理解"></a>5.1 简单看图理解</h3><p>在正式开始之前，我们先简单看一张图，这一张图很清晰的描述了使用vuex的整个流程，在这里也不用搞得多明白，心里有个概念就好了，到了后面的代码部分自然就会理解了：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862161935.png" alt="1666862161935"></p><p>我们可以看到最左边是我们的组件，可以简单理解为我们的视图，虚线框则是我们的 <code>vuex</code>，这里面有一个 <code>State</code>，可以把它理解为数据。以前我们将数据放在组件里面，要修改数据直接在组件里面修改就好了，现在数据放在了 <code>vuex</code>仓库里面，我们要修改数据就得走一定的流程：</p><ul><li>我们需要在我们组件里面调用 <code>Dispatch()</code>方法提交 <code>Actions</code>（还记得最开始我们如何说的 <code>Actions</code>吗？）\</li><li>Actions再通过Commit()方法提交Mutations（简单理解为真正的修改数据的方法）\</li><li>通过Mutations里面的方法改变state（数据）\</li><li>响应（渲染）到组件里面。\</li></ul><h3 id="5-2-简单理解-State、Actions、Mutations"><a href="#5-2-简单理解-State、Actions、Mutations" class="headerlink" title="5.2 简单理解 State、Actions、Mutations"></a>5.2 简单理解 <code>State</code>、<code>Actions</code>、<code>Mutations</code></h3><p>看了上面的图可能有一些小伙伴不太理解图里面的 <code>State</code>、<code>Actions</code>、<code>Mutations</code>，这里我们就详细理解一下：</p><ul><li><code>state</code>是什么?</li></ul><p>官方的话可能有些晦涩，我们可以简单的理解为：存数据的地方，所有的数据都要存在state里面。这样理解起来就简单多了</p><ul><li><code>Actions</code>是什么？</li></ul><p>Actions和Mutations比较类似，包含的都是一些方法，不同的是Actions不能直接更改数据，它的作用是提交Mutations，Mutations里面包含的才是具体操作数据的方法。</p><ul><li><code>Mutations</code>是什么？</li></ul><p>在 <code>vuex</code>中，唯一能够修改数据的方法就是提交 <code>mutation</code>，简单来说 <code>mutations</code>里面存的就是一些操作数据的方法。</p><h3 id="5-3-代码实例"><a href="#5-3-代码实例" class="headerlink" title="5.3 代码实例"></a>5.3 代码实例</h3><p><strong>1.</strong> 将项目自动生成的 <code>HelloWorld.vue</code>删除，新建三个我们自己的组件，分别是：<code>ChildA.vue</code>、<code>ChildB.vue</code>和 <code>Parent.vue</code>，并配置路由：</p><p>项目结构变为：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862171345.png" alt="1666862171345"></p><p><strong><code>ChildA.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ChildA:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>ChildA-Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ChildA&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//我们不再将数据放到组件里</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//count: 0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>ChildB.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-b&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ChildB:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>ChildB-Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ChildB&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//count: 0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>Parent.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child-a</span>&gt;</span><span class="tag">&lt;/<span class="name">child-a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child-b</span>&gt;</span><span class="tag">&lt;/<span class="name">child-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildA</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildA&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildB</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildB&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ChildA</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ChildB</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改 <code>router</code>下的 <code>index.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Parent</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Parent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Parent</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个时候我们启动项目，浏览器访问：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862182760.png" alt="1666862182760"></p><p>我们可以看到，浏览器上面并没有显示 <code>&#123;&#123;count&#125;&#125;</code>的内容，因为我们并没有在组件里面定义 <code>count</code>，考虑到 <code>ChildA</code>和 <code>ChildB</code>公用一个数据 <code>count</code>，所以我么们将 <code>count</code>提出来，利用 <code>vuex</code>的仓库进行管理，所以我们需要在 <code>store</code>目录下里面的 <code>index.js</code>里面定义 <code>count</code>，那么怎么定义呢，我们一起来看看：</p><p>修改 <code>src/store/index.js</code>文件代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">//将数据定义在state里面，state是一个对象</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们已经定义好了count，那么要怎么在各个组件里面使用这个数据呢？我们可以在组件里面这样调用：</p><p><strong><code>CHildA.vue</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ChildA&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//count: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//通过计算属性来获得count</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">//通过vue的this.$store来获得state</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>ChildB.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ChildB&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//count: 0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">count</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的代码我们可以很清楚的看到是如何获取到state里面的count的，很多小伙伴可能就有疑惑了，为什么要使用计算属性呢，而不把count定义在data里面，然后通过方法获取呢？在这里我们就要回顾一下vuex里面state的特性了，state状态是响应式的，也就是说如果state里面的count发生了变化，组件里面的数据是自动更新的，所以就需要用到computed属性了。对computed属性不熟的小伙伴可以参考：</p><ul><li>计算属性：<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//cn.vuejs.org/v2/guide/computed.html" title="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/computed.html">计算属性</a></li></ul><p>关于 <code>this.$store</code>：我们最开始把vuex挂载到了根组件上去，所以我们在任何地方都可以调用 <code>$store</code>，和 <code>$router</code>一个道理，就像是调用 <code>store</code>这个大仓库里面的属性一样。</p><p>此时我们看到浏览器页面上已经出现了 <code>count</code>的值：<br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862203990.png" alt="1666862203990"></p><p><strong>2.给两个button添加点击事件，以此来更改count的值：</strong></p><p>ChildA.vue（ChildB修改代码相同，所以不在这里重复展示）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ChildA:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick(10)&quot;</span>&gt;</span>ChildA-Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ChildA&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//count: 0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">count</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">handleClick</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//通过dispatch触发actions中的方法countAdd，actions提交mutations，num是携带的参数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;countAdd&#x27;</span>,num)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改src&#x2F;store&#x2F;index.js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//组件通过dispatch方法触发actions里面的countAdd方法，然后actions提交mutations里面的countAdd方法。</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//接收组件传过来的参数num，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">        <span class="title function_">countAdd</span>(<span class="params">context,num</span>)&#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;countAdd&#x27;</span>,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">//传入一个state对象，接收传过来的参数num</span></span><br><span class="line">        <span class="title function_">countAdd</span>(<span class="params">state,num</span>)&#123;</span><br><span class="line">            state.<span class="property">count</span>+=num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码还是比较清晰明了的，较为重要的部分我也添加了注释。在这里我们给 <code>button</code>按钮添加了一个点击事件 <code>handleClick()</code>，这个方法的作用就是增加count的值，增加多少以传入的参数决定，在方法里面我们通过 <code>disptch()</code>方法触发 <code>actions</code>，然后 <code>actions</code>在提交 <code>mutations</code>，最终实现 <code>state</code>数据的更改。在 <code>actions</code>里面我们接收了一个 <code>context</code>对象，可以简单将这个对象理解为 <code>store</code>对象（其实不同）。</p><p><strong>最终效果：</strong><br><img src="/image/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Vuex/1666862214087.png" alt="1666862214087"></p><p>我们可以看到，点击任意组件的按钮，页面上的其他组件的 <code>count</code>值也会跟着改变，因为这些组件通过 <code>vuex</code>实现了 <code>count</code>的共享，并且 <code>count</code>的值是自动更新的，有没有觉得很奇妙！</p><p>3.直接出发 <code>actions</code></p><p>在刚才的组件中，我们通过 <code>dispatch</code>方法出发 <code>actions</code>的，那能不能直接触发 <code>actions</code>呢？答案是可以的，此时我们的 <code>handleClick()</code>方法可以改写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">handleClick</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="comment">//直接调用commit触发actions</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;countAdd&#x27;</span>,num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然我们直接触发了 <code>actions</code>，那么 <code>src/store/index.js</code>里面的 <code>actions</code>就可以去掉了，因为我们直接 <code>commit</code>了。</p><p>那么 <code>src/store/index.js</code>里面的代码就可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">countAdd</span>(<span class="params">state,num</span>)&#123;</span><br><span class="line">            state.<span class="property">count</span>+=num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动项目可以发现效果是一样的。</p><p>到这里可能就有小伙伴疑问了，为什么不能直接执行mutations里面的方法？这样多简单，答案是不能的，具体原因就不再这里深究了，有兴趣的小伙伴可以参考：<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//vuex.vuejs.org/zh/guide/mutations.html" title="https://link.zhihu.com/?target=https%3A//vuex.vuejs.org/zh/guide/mutations.html">Mutations详解</a></p><h3 id="5-4-使用对象展开运算符简化代码"><a href="#5-4-使用对象展开运算符简化代码" class="headerlink" title="5.4 使用对象展开运算符简化代码"></a>5.4 使用对象展开运算符简化代码</h3><p>代码写到这里，可能有小伙伴发现：如果我们很多地方需要用到 <code>store</code>里面的数据，那我们就要在很多地方写this.$store。这样看起来代码是十分冗余的。所以为了解决这个问题，我们引入了对象展开运算符 <code>mapState</code> 、<code>mapMutations</code>来简化。</p><p>运用 <code>mapState</code> 、<code>mapMutations</code>，我们组件里面的代码就可以这样写：</p><p>ChileA.vue（Child.vue里面修改的代码与之类似）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-a&quot;</span>&gt;</span></span><br><span class="line">  //使用新的countA</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ChildA:&#123;&#123;countA&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick(10)&quot;</span>&gt;</span>ChildA-Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//要想使用展开运算符，就要先引入</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;ChildA&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//通过mapState获得state里面的count，并赋值给countA</span></span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapState</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">countA</span>: <span class="string">&#x27;count&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">handleClick</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//this.$store.commit(&#x27;countAdd&#x27;,num)</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">countAdd</span>(num)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//通过展开运算符提交mutations里面的方法countAdd</span></span></span><br><span class="line"><span class="language-javascript">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;countAdd&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这里有没有觉得代码简洁了不少呢，没有烦人的this.$store，当state里面的数据更多的时候，更能体现出此种方法的优势。</p><p>展开运算符是ES6的语法，不太了解的小伙伴可以参考：</p><ul><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" title="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">js中的展开运算符</a></li><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//vuex.vuejs.org/zh/guide/state.html" title="https://link.zhihu.com/?target=https%3A//vuex.vuejs.org/zh/guide/state.html">对象展开运算符-mapState</a></li><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//blog.csdn.net/dkr380205984/article/details/82185740" title="https://link.zhihu.com/?target=https%3A//blog.csdn.net/dkr380205984/article/details/82185740">state,mapState,…mapState对象展开符详解</a></li></ul><p>在这里我们只用到了 <code>mapState</code>和 <code>mapMutations</code>,其实还有其他对象展开符，比如 <code>mapActions</code>等等，在这里就不深究了。</p><h3 id="5-5-Getter与Module"><a href="#5-5-Getter与Module" class="headerlink" title="5.5 Getter与Module"></a>5.5 Getter与Module</h3><p>文章写到这儿，vuex基础知识应该差不多了，虽然我们的代码很简单，但是我们需要理解其中的原理，理解其中每一个知识点，比如对象展开符等等，只有理解透彻了，vuex才算是上手了。</p><p>下面我们简单讲解一下vuex里面的Getter和Module模块思想，这里我们粗略的过一遍，深入探讨我们放在下一篇文章。</p><ul><li>Getter</li></ul><p>可以简单的理解为store的计算属性，就和computed差不多。<code>mapGetters</code> 辅助函数仅仅是将 <code>store</code> 中的 <code>getter</code> 映射到局部计算属性，也就是说我们可以在组件里面使用与mapState类似的使用方法去使用。</p><p>大家可以参考：</p><ul><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//vuex.vuejs.org/zh/guide/getters.html" title="https://link.zhihu.com/?target=https%3A//vuex.vuejs.org/zh/guide/getters.html">Getter</a></li><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//blog.csdn.net/gao_xu_520/article/details/79694148" title="https://link.zhihu.com/?target=https%3A//blog.csdn.net/gao_xu_520/article/details/79694148">Vuex之理解Getters的用法</a></li></ul><p>具体内容我放在下一篇文章</p><ul><li>Module</li></ul><p>Module其实很简单，我们只要看一下官网的以下代码就明白了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex<span class="selector-class">.Store</span>(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store<span class="selector-class">.state</span><span class="selector-class">.a</span> // -&gt; moduleA 的状态</span><br><span class="line">store<span class="selector-class">.state</span><span class="selector-class">.b</span> // -&gt; moduleB 的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个代码很明了，就是一个分模块的思想，之前我们都是用的单一的store，但是一旦项目很庞大的时候，一个store就会显得非常复杂，所以我们就使用的分模块的思想。具体内容看一下官网就能明白了：</p><ul><li><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//vuex.vuejs.org/zh/guide/modules.html" title="https://link.zhihu.com/?target=https%3A//vuex.vuejs.org/zh/guide/modules.html">Module</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整篇文章写下来，我对vuex又有了更加深入的理解，我总结了几点（也不算总结），算是一个知识点的唤醒吧：</p><ul><li>vuex：状态共享</li><li>为什么要使用vuex</li><li>store：共享仓库</li><li>state：数据存储</li><li>dispatch、actions、mutations</li><li>数据修改流程</li><li>对象展开符</li><li>getter：store的计算属性</li><li>module：模块化思想</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端技术学习路线图</title>
    <link href="https://superq314.github.io/posts/8b53a6bb/"/>
    <id>https://superq314.github.io/posts/8b53a6bb/</id>
    <published>2022-10-26T05:42:20.000Z</published>
    <updated>2023-05-24T14:49:34.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下 是Web 开发人员的学习路线图，来自 Github <a href="https://github.com/kamranahmedse/developer-roadmap">developer-roadmap</a> 项目。</p><p>主要有三个方向，分别为前端开发、后端开发和运维。图片中不同颜色的意义：</p><ul><li><strong>黄色</strong> ：推荐；</li><li><strong>灰色</strong> ：尽可能学习；</li><li><strong>橙色</strong> ：任选其一。</li></ul><p>可以看到，作为 Web 开发者，不管从事什么职位，下面这些技能点是必须掌握的：</p><ul><li>Git，代码版本管理</li><li>SSH；</li><li>HTTP&#x2F;HTTPs 和 API，想要真正成为一名 Web 开发者，对 HTTP 协议的了解是必不可少的；</li><li>基础命令行的使用；</li><li>学会钻研，养成碰到问题，通过自我学习的方式来寻找问题的解决方案，这一点有尤其重要；</li><li>数据结构和算法，相信在通常的大学计算机学科这两门课都是要学习的；</li><li>字符编码；</li><li>Github，Github（包括 Google、Stack Overflow）是 Web 开发者的宝矿，好好利用。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2022/05/frontend.png"><img src="https://www.runoob.com/wp-content/uploads/2022/05/frontend.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试之React篇</title>
    <link href="https://superq314.github.io/posts/7b988332/"/>
    <id>https://superq314.github.io/posts/7b988332/</id>
    <published>2022-10-25T10:29:23.000Z</published>
    <updated>2022-10-26T06:04:04.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="react的生命周期"><a href="#react的生命周期" class="headerlink" title="react的生命周期"></a>react的生命周期</h3><p>生命周期是什么？</p><p>react 实例的生命周期，就是react实例从初始化，更新，到销毁的过程</p><p>react实例生命周期经历三个阶段</p><p>初始化阶段：完成从react组件创建到首次渲染的过程</p><p>更新阶段：当调用setState函数时，会引起组件的重新渲染</p><p>销毁阶段：完成组件的销毁</p><p>三个阶段分别对应的构造函数有</p><p>初始化阶段：</p><p>constructor</p><p>构造函数里，可以做状态的初始化，接收props的传值</p><p>componentWillMount： 在渲染前调用，相当于vue中的beforeMount</p><p>render</p><p>渲染函数，不要在这里修改数据。 vue中也有render函数。</p><p>componentDidMount</p><p>渲染完毕，在第一次渲染后调用。</p><p>运行中阶段（更新）</p><p>当组件的 props 或 state 发生变化时会触发更新（严谨的说，是只要调用了setState（）或者改变了props时）。组件更新的生命周期调用顺序如下：</p><p>shouldComponentUpdate</p><p>是否更新？ 需要返回true或者false。如果是false，那么组件就不会继续更新了。</p><p>componentWillUpdate</p><p>即将更新。</p><p>componentWillReceiveProps(nextProps)： 在组件接收到一个新的 prop (更新后)时被调用。</p><p>这个方法在初始化render时不会被调用。nextProps 是props的新值，而 this.props是旧值。</p><p>render</p><p>不要在这里修改数据</p><p>componentDidUpdate</p><p>在组件完成更新后立即调用。在初始化时不会被调用。 相当于vue中的updated</p><p>销毁阶段（卸载）</p><p>componentWillUnmount()</p><p>即将卸载，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p><h3 id="为什么虚拟DOM-会提高性能"><a href="#为什么虚拟DOM-会提高性能" class="headerlink" title="为什么虚拟DOM 会提高性能"></a>为什么虚拟DOM 会提高性能</h3><p> 首先，（虚拟DOM是什么） 虚拟DOM就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&quot;p&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">style</span>: <span class="string">&quot;width:200px;height: 100px;&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">innerHTML</span>: <span class="string">&quot;我是p&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其次，操作虚拟DOM，就是在操作javascript对象，所以，并不会引起页面的重绘和重排。而操作真实DOM是会引起页面的重绘和重排的。</p><h3 id="React的diff原理"><a href="#React的diff原理" class="headerlink" title="React的diff原理"></a>React的diff原理</h3><p>传统diff算法</p><p>需要遍历整棵树的节点然后进行比较，是一个深度递归的过程，运算复杂度常常是O(n^3)</p><p>react diff的优化策略</p><p>DOM节点跨层级的操作不做优化，因为很少这么做，这是针对的tree层级的策略；</p><p>对于同一个类的组件，会生成相似的树形结构，对于不同类的组件，生成不同的树形结构，这是针对conponent层级的策略；</p><p>对于同一级的子节点，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；</p><h3 id="调用setState之后，发生了什么？"><a href="#调用setState之后，发生了什么？" class="headerlink" title="调用setState之后，发生了什么？"></a>调用setState之后，发生了什么？</h3><p>合并state</p><p>把传入setState（）里的参数对象和当前的state进行（属性）合并。 触发调和过程</p><p>（Reconciliation）</p><p>重新渲染组件</p><p>React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面</p><p>React 会自动计算出新的树与老树的节点差异（用diff算法），然后根据差异对界面进行最小化重</p><p>渲染</p><h3 id="state和props的区别"><a href="#state和props的区别" class="headerlink" title="state和props的区别"></a>state和props的区别</h3><p>state是组件的状态，也叫组件内部的数据</p><p>props是组件的属性，也可以认为是外部给组件传入的数据</p><h3 id="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"><a href="#React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？" class="headerlink" title="React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？"></a>React中的setState是同步执行还是异步执行？如果是异步的？怎么拿到执行后的state？</h3><p>setState是异步的。</p><p>如果要拿到修改后的状态，需要使用回调函数的方式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//改变状态后想做一些事情：</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"></span><br><span class="line">  属性名:属性值</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一般是用于在setState之后做一些操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//this.state == 修改之后的state</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么不能直接用以下办法更新state"><a href="#为什么不能直接用以下办法更新state" class="headerlink" title="为什么不能直接用以下办法更新state"></a>为什么不能直接用以下办法更新state</h3><p>this.state.msg &#x3D; “hello”;</p><p>因为，这样不会引起组件的重新渲染，所以，数据修改后没法 呈现在页面上。</p><p>而调用setState()函数，会引起组件的重新渲染，这样更新的数据就会呈现在页面上。</p><h3 id="React-Class-组件有哪些周期函数？分别有什么作用？"><a href="#React-Class-组件有哪些周期函数？分别有什么作用？" class="headerlink" title="React Class 组件有哪些周期函数？分别有什么作用？"></a>React Class 组件有哪些周期函数？分别有什么作用？</h3><h3 id="React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？"><a href="#React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？" class="headerlink" title="React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？"></a>React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？</h3><h3 id="React-Class-组件和-React-Hook-的区别有哪些？"><a href="#React-Class-组件和-React-Hook-的区别有哪些？" class="headerlink" title="React Class 组件和 React Hook 的区别有哪些？"></a>React Class 组件和 React Hook 的区别有哪些？</h3><h3 id="React-中高阶函数和自定义-Hook-的优缺点？"><a href="#React-中高阶函数和自定义-Hook-的优缺点？" class="headerlink" title="React 中高阶函数和自定义 Hook 的优缺点？"></a>React 中高阶函数和自定义 Hook 的优缺点？</h3><h3 id="简要说明-React-Hook-中-useState-和-useEffect-的运行原理？"><a href="#简要说明-React-Hook-中-useState-和-useEffect-的运行原理？" class="headerlink" title="简要说明 React Hook 中 useState 和 useEffect 的运行原理？"></a>简要说明 React Hook 中 useState 和 useEffect 的运行原理？</h3><h3 id="React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"><a href="#React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？" class="headerlink" title="React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"></a>React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？</h3><h3 id="React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？"><a href="#React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？" class="headerlink" title="React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？"></a>React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？</h3><h3 id="React-的-useEffect-是如何监听数组依赖项的变化的？"><a href="#React-的-useEffect-是如何监听数组依赖项的变化的？" class="headerlink" title="React 的 useEffect 是如何监听数组依赖项的变化的？"></a>React 的 useEffect 是如何监听数组依赖项的变化的？</h3><h3 id="React-Hook-和闭包有什么关联关系？"><a href="#React-Hook-和闭包有什么关联关系？" class="headerlink" title="React Hook 和闭包有什么关联关系？"></a>React Hook 和闭包有什么关联关系？</h3><h3 id="React-中-useState-是如何做数据初始化的？"><a href="#React-中-useState-是如何做数据初始化的？" class="headerlink" title="React 中 useState 是如何做数据初始化的？"></a>React 中 useState 是如何做数据初始化的？</h3><h3 id="列举你常用的-React-性能优化技巧？"><a href="#列举你常用的-React-性能优化技巧？" class="headerlink" title="列举你常用的 React 性能优化技巧？"></a>列举你常用的 React 性能优化技巧？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试之ES6新特性篇</title>
    <link href="https://superq314.github.io/posts/d103d789/"/>
    <id>https://superq314.github.io/posts/d103d789/</id>
    <published>2022-10-25T10:28:11.000Z</published>
    <updated>2022-10-26T06:03:30.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>新增块级作用域let定义变量和const定义常量</p><p>变量的解构赋值</p><p>模板字符串 （‘${}’）</p><p>默认参数（key&#x3D;value）</p><p>箭头函数（&#x3D;&gt;）</p><p>扩展运算符（…）</p><p>模块（import&#x2F;export）</p><p>类（class&#x2F;extends）</p><p>Promise</p><p>Proxy</p><p>Symbol</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>React-自学之路</title>
    <link href="https://superq314.github.io/posts/99bc0d07/"/>
    <id>https://superq314.github.io/posts/99bc0d07/</id>
    <published>2022-10-25T08:59:50.000Z</published>
    <updated>2022-11-07T08:58:29.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试之Vue篇</title>
    <link href="https://superq314.github.io/posts/8a6e9864/"/>
    <id>https://superq314.github.io/posts/8a6e9864/</id>
    <published>2022-10-25T07:29:29.000Z</published>
    <updated>2022-10-27T09:37:33.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？"><a href="#MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？" class="headerlink" title="MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？"></a>MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？</h3><p>MVC</p><ul><li>Model(模型)：负责从数据库中取数据</li><li>View(视图)：负责展示数据的地方</li><li>Controller(控制器)：用户交互的地方，例如点击事件</li><li>思想：Controller将Model的数据展示在View上</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4636ebbfa25049179c27a6b5ab8bb308~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>MVVM</p><ul><li><p>VM：也就是View-Model，做了两件事达到了数据的双向绑定</p><ul><li>一、将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</li><li>二、将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li></ul></li><li><p>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac31b27392b4b0e90ca2f67c64c59c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>区别</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><h3 id="说说对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="如何理解-Vue-是一个渐进式框架？"><a href="#如何理解-Vue-是一个渐进式框架？" class="headerlink" title="如何理解 Vue 是一个渐进式框架？"></a>如何理解 Vue 是一个渐进式框架？</h3><p>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的 <code>ref</code>可以做到这点</p><h3 id="vue的两个核⼼点"><a href="#vue的两个核⼼点" class="headerlink" title="vue的两个核⼼点"></a>vue的两个核⼼点</h3><ul><li><strong>数据驱动</strong>：ViewModel，保证数据和视图的⼀致性</li><li><strong>组件系统</strong>：应⽤类UI可以看做全部是由组件树构成的</li></ul><h3 id="Vue的优点？Vue的缺点？"><a href="#Vue的优点？Vue的缺点？" class="headerlink" title="Vue的优点？Vue的缺点？"></a>Vue的优点？Vue的缺点？</h3><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p><p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h3 id="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><a href="#Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？" class="headerlink" title="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"></a>Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</h3><ul><li>jQuery直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可</li><li>在操作DOM频繁的场景里，jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能</li><li>Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</li><li>Vue集成的一些库，大大提高开发效率，比如Vuex，Router等</li></ul><h3 id="Vue和React的异同点？"><a href="#Vue和React的异同点？" class="headerlink" title="Vue和React的异同点？"></a>Vue和React的异同点？</h3><p>相同点：</p><ul><li>使用虚拟dom</li><li>组件化开发</li><li>单向数据流(父子组件之间，不建议子修改父传递的数据)</li><li>支持服务端渲染</li></ul><p>不同点：</p><ul><li>React的JSX，Vue的template</li><li>数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)</li><li>React单向绑定，Vue双向绑定</li><li>React的Redux，Vue的Vuex</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><h3 id="computed和watch的区别？"><a href="#computed和watch的区别？" class="headerlink" title="computed和watch的区别？"></a>computed和watch的区别？</h3><p>computed：计算属性，依赖其它属性值，并且computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p><p>watch： 更多的是观察的作用，支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>*<code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是 <code>多个变量</code>凑在一起计算出 <code>一个变量</code>，并且 <code>computed</code>具有 <code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行 <code>异步操作</code></p><p>*<code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是 <code>一个变量</code>的变化决定 <code>多个变量</code>的变化，<code>watch</code>可以进行 <code>异步操作</code></p><ul><li>简单记就是：一般情况下 <code>computed</code>是 <code>多对一</code>，<code>watch</code>是 <code>一对多</code></li></ul><h3 id="computed如何实现传参？"><a href="#computed如何实现传参？" class="headerlink" title="computed如何实现传参？"></a>computed如何实现传参？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div&gt;&#123;&#123; <span class="title function_">total</span>(<span class="number">3</span>) &#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">total</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">      returnn * <span class="variable language_">this</span>.<span class="property">num</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch有哪些属性，分别有什么用？"><a href="#watch有哪些属性，分别有什么用？" class="headerlink" title="watch有哪些属性，分别有什么用？"></a>watch有哪些属性，分别有什么用？</h3><p>当我们监听一个基本数据类型时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  value () &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们监听一个引用数据类型时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    handler () &#123; <span class="comment">// 执行回调</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 是否进行深度监听</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span><span class="comment">// 是否初始执行handler函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch的immediate属性有什么用？"><a href="#watch的immediate属性有什么用？" class="headerlink" title="watch的immediate属性有什么用？"></a>watch的immediate属性有什么用？</h3><blockquote><p>比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="title function_">searchInputValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>immediate</code>完全可以这么写，当它为 <code>true</code>时，会初始执行一次</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">searchInputValue</span>:&#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="string">&#x27;getList&#x27;</span>,</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch监听一个对象时，如何排除某些属性的监听"><a href="#watch监听一个对象时，如何排除某些属性的监听" class="headerlink" title="watch监听一个对象时，如何排除某些属性的监听"></a>watch监听一个对象时，如何排除某些属性的监听</h3><blockquote><p>下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">      <span class="attr">c</span>:<span class="number">3</span>,</span><br><span class="line">      <span class="attr">d</span>:<span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">params</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> ![<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>].<span class="title function_">includes</span>(_)) <span class="comment">// 排除对c，d属性的监听</span></span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span>vm.<span class="property">params</span>[_], handler, &#123;</span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">      <span class="attr">c</span>:<span class="number">3</span>,</span><br><span class="line">      <span class="attr">d</span>:<span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-if和v-show的作用和区别"><a href="#v-if和v-show的作用和区别" class="headerlink" title="v-if和v-show的作用和区别"></a>v-if和v-show的作用和区别</h3><ul><li><p><code>v-if</code>：通过控制 <code>dom</code>元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</p><blockquote><p>v-if的值为true时，元素才会存在于html页面中。</p></blockquote></li><li><p><code>v-show</code>：通过控制 <code>dom</code>元素的 <code>CSS</code>样式（<code>display</code>）来实现显隐，不会销毁</p><blockquote><p>无论v-show的值为true或者false，元素都会存在于html页面中;</p></blockquote></li><li><p>一般来说，v-if有更高的切换开销，而v-show则有更高的初始渲染开销</p><blockquote><p>因此，如果需要非常频繁地切换，使用v-show比较好，如果在运行时条件不会改变时，用v-if比较好</p></blockquote></li></ul><h3 id="vue常⽤的修饰符"><a href="#vue常⽤的修饰符" class="headerlink" title="vue常⽤的修饰符"></a>vue常⽤的修饰符</h3><ul><li><code>.stop</code>: 等统⼀JavaScript中的 <code>event.stopPropagation()</code>，防⽌事件冒泡</li><li><code>.prevent</code>: 等同于JavaScript中的 <code>event.preventDefault()</code>，防⽌执⾏预设的⾏为(如果事件可取消，则取消该事件，⽽不停⽌事件的进⼀步传播)；</li><li><code>.capture</code>: 与事件冒泡的⽅向相反，事件捕获由外到内</li><li><code>.self</code>: 只会触发⾃⼰范围内的事件，不包含⼦元素；</li><li><code>.once</code>: 只会触发⼀次。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1c911988f74cea91da79af3c6049c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="截屏2021-07-11 下午9.56.53.png"></li></ul><h3 id="Vue的内部指令"><a href="#Vue的内部指令" class="headerlink" title="Vue的内部指令"></a>Vue的内部指令</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39d348e686b449e8931f5a85802e3c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="Vue-2-x模板中的指令是如何解析实现的？"><a href="#Vue-2-x模板中的指令是如何解析实现的？" class="headerlink" title="Vue 2.x模板中的指令是如何解析实现的？"></a>Vue 2.x模板中的指令是如何解析实现的？</h3><h3 id="简要说明Vue-2-x的全链路运作机制？"><a href="#简要说明Vue-2-x的全链路运作机制？" class="headerlink" title="简要说明Vue 2.x的全链路运作机制？"></a>简要说明Vue 2.x的全链路运作机制？</h3><h3 id="用过vue的哪些组件？"><a href="#用过vue的哪些组件？" class="headerlink" title="用过vue的哪些组件？"></a>用过vue的哪些组件？</h3><p>1、vue-route</p><p>2、axios</p><p>3、vuex</p><p>4、Element UI</p><p>5、swiper</p><p>6、vue-echarts</p><p>7、vue-video-player</p><p>8、vue-photo-preview等等</p><h3 id="Vue组件如何通信（常见）"><a href="#Vue组件如何通信（常见）" class="headerlink" title="Vue组件如何通信（常见）"></a>Vue组件如何通信（常见）</h3><ul><li>父子组件 props 和 this.$emit</li><li>自定义事件 event.$no event.$off event.$emit</li><li>vuex</li></ul><h3 id="描述组件渲染和更新的过程"><a href="#描述组件渲染和更新的过程" class="headerlink" title="描述组件渲染和更新的过程"></a>描述组件渲染和更新的过程</h3><p><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666706013162.png" alt="1666706013162"><br>如上图所示，vue原理三大模块：响应式、模板渲染、vdom</p><ol><li>初次渲染过程</li></ol><ul><li>解析模板为 render 函数 （或在开发环境已完成，vue-loader）</li><li>触发响应式，监听 data 属性 getter、 setter</li><li>执行 render 函数，生成 vnode ，patch(elem,vnode)</li></ul><ol start="2"><li>更新过程</li></ol><ul><li>修改 data，触发 setter（此前在 getter 中已被监听）</li><li>重新执行 render 函数，生成 newVnode<br>patch(vnode,newVnode)</li></ul><ol start="3"><li>with 语法<br><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666706066246.png" alt="1666706066246"></li></ol><ul><li>改变 <code>&#123; &#125;</code> 内自由变量的查找规则，当做 obj 属性来查找</li><li>如果找不到匹配的 obj 属性，就会报错</li><li>with 要慎用，它打破了作用域规则，易读性变差</li></ul><h3 id="相同的路由组件如何重新渲染？"><a href="#相同的路由组件如何重新渲染？" class="headerlink" title="相同的路由组件如何重新渲染？"></a>相同的路由组件如何重新渲染？</h3><blockquote><p>开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">constroutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;/a&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">MyComponent</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;/b&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">MyComponent</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>如果依然想重新渲染，怎么办呢？可以使用 <code>key</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml">&lt;router-view:key=&quot;$route.path&quot;&gt;<span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="vue为何是异步渲染"><a href="#vue为何是异步渲染" class="headerlink" title="vue为何是异步渲染"></a>vue为何是异步渲染</h3><ul><li>减少DOM操作次数，提高性能</li></ul><blockquote><p>$nextTick 待 DOM 渲染完后再回调，页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次。</p></blockquote><p><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666706768835.png" alt="1666706768835"></p><h3 id="组件之间如何传值"><a href="#组件之间如何传值" class="headerlink" title="组件之间如何传值"></a>组件之间如何传值</h3><ul><li>Vue父子 组件之间传值<ul><li>子组件通过 <code>props</code>来接受数据</li><li>子组件通过 <code>$emit</code>来触发父组件的自定义事件（即传值）</li></ul></li><li>组件中可以使用 <code>$parent</code>和 <code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li><li>使用 <code>$attrs</code>和 <code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li><li>使用 <code>$refs</code>获取组件实例，进而获取数据</li><li>使用 <code>Vuex</code>进行状态管理</li><li>使用 <code>eventBus</code>进行跨组件触发事件，进而传递数据</li><li>使用 <code>provide</code>和 <code>inject</code>，官方建议我们不要用这个，我在看 <code>ElementUI</code>源码时发现大量使用</li><li>使用浏览器本地缓存，例如 <code>localStorage</code></li></ul><h3 id="路由之间如何传参"><a href="#路由之间如何传参" class="headerlink" title="路由之间如何传参"></a>路由之间如何传参</h3><ul><li>通过 <code>router-link</code>路由导航跳转传递<br><code>&lt;router-link to=</code>&#x2F;a&#x2F;${id}<code>&gt;routerlink传参&lt;/router-link&gt;</code></li><li>跳转时使用push方法拼接携带参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">`/getlist/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>通过路由属性中的name来确定匹配的路由，通过params来传递参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Getlist&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>:id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用path来匹配路由，然后通过query来传递参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/getlist&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>:id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：query有点像ajax中的get请求，而params像post请求。</p></blockquote><p>params在地址栏中不显示参数，刷新页面，参数丢失,</p><p>其余方法在地址栏中显示传递的参数，刷新页面，参数不丢失。</p><h3 id="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"><a href="#vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）" class="headerlink" title="vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）"></a>vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）</h3><p>首先了解父子组件生命周期执行顺序</p><p>加载渲染数据过程</p><p>父组件 beforeCreate</p><p>父组件 created</p><p>父组件 beforeMount</p><p>子组件 beforeCreate</p><p>子组件 created</p><p>子组件 beforeMount</p><p>子组件 mounted</p><p>父组件 mounted</p><p>原因：因为生命周期只会执行一次，数据是要等到异步请求以后才能拿到，那么子组件的mounted钩子执行的时候，还没有拿到父组件传递过来的数据，但是又必须要打印出来结果，那这样的话，就只能去打印props中的默认值空字符串了，所以打印的结果是一个空字符串。</p><p>解决办法：</p><p>1、使用v-if控制组件渲染的时机</p><p>初始还没拿到后端接口的异步数据的时候，不让组件渲染，等拿到的时候再去渲染组件。使用v-if&#x3D;”变量”去控制，初始让这个变量为false，这样的话，子组件就不会去渲染，等拿到数据的时候，再让这个变量变成true，</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">isTrue</span>:<span class="literal">false</span><span class="comment">// 初始为false</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="title function_">monted</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$post</span>.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>.<span class="title function_">getData</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(res.<span class="property">result</span>)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">isTrue</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、使用watch监听数据的变化</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">tableData</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>: [],</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">tableData</span>(<span class="params">val</span>)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、使用VueX</p><h3 id="如果子组件改变props里的数据会发生什么"><a href="#如果子组件改变props里的数据会发生什么" class="headerlink" title="如果子组件改变props里的数据会发生什么"></a>如果子组件改变props里的数据会发生什么</h3><ul><li>改变的props数据是基本类型</li></ul><blockquote><p>如果修改的是基本类型，则会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047859eda3bf47a5930dd0b28e842017~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="0458e2ff1538ee85d42953cec9a94ca.png"></p><ul><li>改变的props数据是引用类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">item</span>: &#123;</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 不报错，并且父级数据会跟着变</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">name</span> = <span class="string">&#x27;sanxin&#x27;</span>;</span><br><span class="line">  <span class="comment">// 会报错，跟基础类型报错一样</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">item</span> = <span class="string">&#x27;sss&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何将组件所有props传递给子组件"><a href="#如何将组件所有props传递给子组件" class="headerlink" title="如何将组件所有props传递给子组件"></a>如何将组件所有props传递给子组件</h3><p><code>$pros</code><br>用法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;User <span class="attribute">v-bind</span>=<span class="string">&quot;<span class="variable">$props</span>&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue里实现跨组件通信的方式有哪些？"><a href="#Vue里实现跨组件通信的方式有哪些？" class="headerlink" title="Vue里实现跨组件通信的方式有哪些？"></a>Vue里实现跨组件通信的方式有哪些？</h3><h3 id="自定义v-model"><a href="#自定义v-model" class="headerlink" title="自定义v-model"></a>自定义v-model</h3><blockquote><p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="attr">default</span>: &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span>,  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h3><p>通过数据劫持结合发布—订阅模式，通过Object.defineProperty()为各个属性定义get、set方法，在数据发生改变时给订阅者发布消息，触发相应的事件回调。</p><h3 id="Vue响应式是怎么实现的？"><a href="#Vue响应式是怎么实现的？" class="headerlink" title="Vue响应式是怎么实现的？"></a>Vue响应式是怎么实现的？</h3><p>整体思路：数据劫持+观察者模式<br>对象内部通过 <code> defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 <code>dep</code>属性，存放他所依赖的 <code> watcher</code>（依赖收集），当属性变化后会通知自己对应的 <code> watcher</code> 去更新(派发更新)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; arrayMethods &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./array&#x27;</span>)</span><br><span class="line"></span><br><span class="line">classObserver &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>:<span class="variable language_">this</span>,</span><br><span class="line">      <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      value.<span class="property">__proto__</span> = arrayMethods</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    letkeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">    <span class="keyword">for</span>(leti = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      constkey = keys[i]</span><br><span class="line">      constvalue = data[key]</span><br><span class="line">      <span class="title function_">defineReactive</span>(data, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">observeArray</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">functiondefineReactive</span>(data, key, value) &#123;</span><br><span class="line">  constchildOb = <span class="title function_">observe</span>(value)</span><br><span class="line">  constdep = <span class="title function_">newDep</span>()</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      returnvalue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) <span class="keyword">return</span></span><br><span class="line">      <span class="title function_">observe</span>(newVal)</span><br><span class="line">      value = newVal</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">functionobserve</span>(value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="title function_">returnnewObserver</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">functiondependArray</span>(value) &#123;</span><br><span class="line">  <span class="keyword">for</span>(lete, i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.<span class="property">__ob__</span> &amp;&amp; e.<span class="property">__ob__</span>.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;</span><br><span class="line">      <span class="title function_">dependArray</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.js</span></span><br><span class="line">constarrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">constarrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line">constmethodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span>=&gt;</span> &#123;</span><br><span class="line">  arrayMethods[method] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    constresult = arrayProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    constob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">    varinserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span><span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span><span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span><span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    returnresult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为什么只对对象劫持，而要对数组进行方法重写？"><a href="#为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="为什么只对对象劫持，而要对数组进行方法重写？"></a>为什么只对对象劫持，而要对数组进行方法重写？</h3><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p><h3 id="不需要响应式的数据应该怎么处理？"><a href="#不需要响应式的数据应该怎么处理？" class="headerlink" title="不需要响应式的数据应该怎么处理？"></a>不需要响应式的数据应该怎么处理？</h3><p>在我们的Vue开发中，会有一些数据，从始至终都 <code>未曾改变过</code>，这种 <code>死数据</code>，既然 <code>不改变</code>，那也就 <code>不需要对他做响应式处理</code>了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的 <code>死数据</code>，如果都进行响应式处理，那会消耗大量性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：将数据定义在data之外</span></span><br><span class="line">data () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list1</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list2</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list3</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list4</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list5</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：Object.freeze()</span></span><br><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">list1</span>:<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; xxxxxxxxxxxxxxxxxxxxxxxx &#125;),</span><br><span class="line">    <span class="attr">list2</span>:<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; xxxxxxxxxxxxxxxxxxxxxxxx &#125;),</span><br><span class="line">    <span class="attr">list3</span>:<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; xxxxxxxxxxxxxxxxxxxxxxxx &#125;),</span><br><span class="line">    <span class="attr">list4</span>:<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; xxxxxxxxxxxxxxxxxxxxxxxx &#125;),</span><br><span class="line">    <span class="attr">list5</span>:<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; xxxxxxxxxxxxxxxxxxxxxxxx &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么使用虚拟DOM-常问"><a href="#为什么使用虚拟DOM-常问" class="headerlink" title="为什么使用虚拟DOM(常问)"></a>为什么使用虚拟DOM(常问)</h3><p>创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。</p><p>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。</p><p>虚拟dom由于本质是一个js对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。</p><p>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</p><h3 id="请用vnode描述一个DOM结构"><a href="#请用vnode描述一个DOM结构" class="headerlink" title="请用vnode描述一个DOM结构"></a>请用vnode描述一个DOM结构</h3><p>场景：<br><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666708100702.png" alt="1666708100702"><br>vnode:<br><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666708108586.png" alt="1666708108586"></p><h3 id="nextTick的原理"><a href="#nextTick的原理" class="headerlink" title="nextTick的原理"></a>nextTick的原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">letcallbacks = []; <span class="comment">//回调函数</span></span><br><span class="line">letpending = <span class="literal">false</span>;</span><br><span class="line"><span class="title function_">functionflushCallbacks</span>() &#123;</span><br><span class="line">  pending = <span class="literal">false</span>; <span class="comment">//把标志还原为false</span></span><br><span class="line">  <span class="comment">// 依次执行回调</span></span><br><span class="line">  <span class="keyword">for</span> (leti = <span class="number">0</span>; i &lt; callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    callbacks[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lettimerFunc; <span class="comment">//先采用微任务并按照优先级优雅降级的方式实现异步刷新</span></span><br><span class="line"><span class="keyword">if</span> (typeofPromise !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果支持promise</span></span><br><span class="line">  constp = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeofMutationObserver !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// MutationObserver 主要是监听dom变化 也是一个异步方法</span></span><br><span class="line">  letcounter = <span class="number">1</span>;</span><br><span class="line">  constobserver = <span class="title function_">newMutationObserver</span>(flushCallbacks);</span><br><span class="line">  consttextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>:<span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeofsetImmediate !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果前面都不支持 判断setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 最后降级采用setTimeout</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  callbacks.<span class="title function_">push</span>(cb);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">timerFunc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextTick的用处"><a href="#nextTick的用处" class="headerlink" title="nextTick的用处"></a>nextTick的用处</h3><p>我举个例子，在vue中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><p>我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是 <code>异步更新</code>的策略，通俗点说就是，<code>同一事件循环内</code>多次修改，会 <code>统一</code>进行一次 <code>视图更新</code>，这样才能节省性能嘛<br>看懂了上面，那你应该也看得懂下面的例子了吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;divref=<span class="string">&quot;testDiv&quot;</span>&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 这里是啥呢</span></span><br></pre></td></tr></table></figure><p>答案是“小林”，前面说了，Vue是 <code>异步更新</code>，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 林三心</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vue中数据变了但是视图不跟新怎么解决？"><a href="#vue中数据变了但是视图不跟新怎么解决？" class="headerlink" title="vue中数据变了但是视图不跟新怎么解决？"></a>vue中数据变了但是视图不跟新怎么解决？</h3><p>vue不能检测以下变动的数组：<br>1、当你利用索引直接设置一个项时，vm.items[indexOfItem] &#x3D; newValue<br>2、当你修改数组的长度时，例如： vm.items.length &#x3D; newLength</p><p>对象属性的添加或删除<br>由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>解决办法：<br>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上<br>Vue.set(vm.someObject, ‘b’, 2) 或者 this.$set(this.someObject,‘b’,2) （这也是全局 Vue.set 方法的别名）</p><p>异步更新队列<br>在最新的项目中遇到了这种情况，数据第一次获取到了，也渲染了，但是第二次之后数据只有在再一次渲染页面的时候更新，并不能实时更新。</p><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>解决办法：<br>可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用</p><h3 id="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="headerlink" title="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"></a>对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3><ul><li>原因：<code>Object.defineProperty</code>没有对对象的新属性进行属性劫持</li><li>对象新属性无法更新视图：使用 <code>Vue.$set(obj, key, value)</code>，组件中 <code>this.$set(obj, key, value)</code></li><li>删除属性无法更新视图：使用 <code>Vue.$delete(obj, key)</code>，组件中 <code>this.$delete(obj, key)</code></li></ul><h3 id="直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？"><a href="#直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？" class="headerlink" title="直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？"></a>直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？</h3><ul><li>原因：Vue没有对数组进行 <code>Object.defineProperty</code>的属性劫持，所以直接arr[index] &#x3D; xxx是无法更新视图的</li><li>使用数组的splice方法，<code>arr.splice(index, 1, item)</code></li><li>使用 <code>Vue.$set(arr, index, value)</code></li></ul><h3 id="Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？"><a href="#Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？" class="headerlink" title="Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？"></a>Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？</h3><h3 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h3><p>原理：Vuex是专门为vue.js应用程序设计的状态管理工具。</p><p>1、state   保存vuex中的数据源，通过this.$store.state获取</p><p>2、getters 用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来</p><p>3、mutations  是修改store中的值得唯一方式   &#x2F;&#x2F;this.$store.commit(‘add’)</p><p>4、action  官方建议提交一个actions，在actions中提交mutations再去修改状态值。this.$store.dispatch(‘add’)</p><p>5、modules 模块化</p><h3 id="vuex的有哪些属性？用处是什么？"><a href="#vuex的有哪些属性？用处是什么？" class="headerlink" title="vuex的有哪些属性？用处是什么？"></a>vuex的有哪些属性？用处是什么？</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9566927e955c4d0ba19df942534e5b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="如何解决vuex页面刷新数据丢失问题？"><a href="#如何解决vuex页面刷新数据丢失问题？" class="headerlink" title="如何解决vuex页面刷新数据丢失问题？"></a>如何解决vuex页面刷新数据丢失问题？</h3><p>原因：因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被清空。</p><p>解决方法：将vuex中的数据直接保存到浏览器缓存中。（一般是用sessionStorage）</p><h3 id="vue-router的路由模式有？"><a href="#vue-router的路由模式有？" class="headerlink" title="vue-router的路由模式有？"></a>vue-router的路由模式有？</h3><p>1、hash模式，用URL hash值来做路由，支持所有浏览器；该模式实现的路由，在通过链接后面添加““#”+路由名字”，触发 <code>hashchange</code>事件，实现路由切换</p><p>2、history模式，由h5提供的history对象实现，依赖H5 History API和服务器配置，通过 <code>pushState</code>和 <code>replaceState</code>切换url，实现路由切换，需要后端配合</p><p>3、abstract模式，支持所有JS运行环境，如Node服务器端，如果发现没有浏览器的API，路由会自动强制进入该模式。</p><h3 id="route和router的区别"><a href="#route和router的区别" class="headerlink" title="route和router的区别"></a>route和router的区别</h3><p>route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。</p><p>router:是路由实例对象，包括了路由跳转方法，钩子函数等。</p><h3 id="如何配置Vue-router异步加载"><a href="#如何配置Vue-router异步加载" class="headerlink" title="如何配置Vue-router异步加载"></a>如何配置Vue-router异步加载</h3><p><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666708047724.png" alt="1666708047724"></p><h3 id="Vue路由跳转方式"><a href="#Vue路由跳转方式" class="headerlink" title="Vue路由跳转方式"></a>Vue路由跳转方式</h3><p>router-link 标签跳转</p><p>this.$router.push()</p><p>this.$router.replace()</p><p>this.$router.go(n)：（0：当前页，-1上一页，+1下一页，n代表整数）</p><h3 id="Vue中for循环为什么加key？"><a href="#Vue中for循环为什么加key？" class="headerlink" title="Vue中for循环为什么加key？"></a>Vue中for循环为什么加key？</h3><ul><li><p>必须用 key ， 且不能是 index 和 random</p><blockquote><p>因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了。</p></blockquote></li><li><p>性能优化，减少渲染次数，提升渲染性能</p><blockquote><p>因为vue是虚拟DOM，更新DOM时用diff算法对节点进行一一比对，通过 tag 和 key 来判断，是否是 sameNode</p></blockquote></li></ul><p>key也不能是li元素的index</p><h3 id="为什么不建议用index做key，为什么不建议用随机数做key？"><a href="#为什么不建议用index做key，为什么不建议用随机数做key？" class="headerlink" title="为什么不建议用index做key，为什么不建议用随机数做key？"></a>为什么不建议用index做key，为什么不建议用随机数做key？</h3><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in list&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;&#123;&#123;item.<span class="property">name</span>&#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="attr">list</span>: [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;124&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小花&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;125&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>渲染为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;0&quot;</span>&gt;小明&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;1&quot;</span>&gt;小红&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;2&quot;</span>&gt;小花&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>现在我执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="title function_ invoke__">unshift</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>:<span class="string">&#x27;122&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>渲染为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>小林<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新旧对比</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>小林<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能</p><p>现在我们使用id来做key，渲染为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;123&quot;</span>&gt;小明&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;124&quot;</span>&gt;小红&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> key=<span class="string">&quot;125&quot;</span>&gt;小花&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>现在我执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="title function_ invoke__">unshift</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>:<span class="string">&#x27;122&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>渲染为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;122&quot;</span>&gt;</span>小林<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新旧对比</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                           <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;122&quot;</span>&gt;</span>小林<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果</p><p>用 <code>index</code>和用 <code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，很 <code>渣男</code>，也很消耗性能，所以，拒绝 <code>渣男</code>，选择 <code>老实人</code></p><h3 id="vue路由守卫有哪些？"><a href="#vue路由守卫有哪些？" class="headerlink" title="vue路由守卫有哪些？"></a>vue路由守卫有哪些？</h3><p>路由守卫分为三种 ——分别是：全局路由守卫、组件路由守卫、独享路由守卫。</p><p>全局守卫</p><p>全局守卫又分为全局前置守卫、和后置守卫</p><ol><li>router.beforeEach((to,from,next)&#x3D;&gt;{})</li></ol><p>回调函数中的参数，to：进入到哪个路由去，from：从哪个路由离开，next：函数，决定是否展示你要看到的路由页面。</p><p>从名字全局前置守卫不难理解，它是全局的，即对 整个单页应用（SPA） 中的所有路由都生效，所以当定义了全局的前置守卫，在进入每一个路由之前都会调用这个回调，那么如果你在回调中对路由的跳转条件判断出错，简单点就是死循环…因为你遗漏了某种路由跳转的情况，守卫会一直执行。所以在使用全局前置守卫的时候一定要判断清楚可能会出现的路由跳转的情况。</p><p>2.router.afterEach((to, from) &#x3D;&gt; {}）</p><p>只有两个参数，to：进入到哪个路由去，from：从哪个路由离。</p><p>理解了全局前置守卫，那么全局后置守卫也就那么一回事。全局后置守卫是整个单页应用中每一次路由跳转后都会执行其中的回调。所以多用于路由跳转后的相应页面操作，并不像全局前置守卫那样会在回调中进行页面的重定向或跳转。</p><p>组件内的守卫</p><p>组件路由守卫分为到达这个组件时，离开这个组件时</p><ol><li>beforeRouteEnter:(to,from,next)&#x3D;&gt;{}——到达</li></ol><p>to，from参数与上面使用方法一致。next回调函数略有不同。</p><p>1</p><p>2.beforeRouteUpdate:(to,from,next)&#x3D;&gt;{}——更新</p><ol start="3"><li>beforeRouteLeave:(to,from,next)&#x3D;&gt;{}——离开</li></ol><p>点击其他组件时，判断是否确认离开。确认执行next()；取消执行next(false)，留在当前页面。</p><p>1</p><p>路由独享的守卫</p><ol><li>beforeEnter:(to,from,next)&#x3D;&gt;{}</li></ol><p>与全局路由守卫用法一致，但是只能针对一个页面使用</p><p>1</p><h3 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了empty&#x2F;undefined其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值</p><h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h3><p><img src="/image/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BVue%E7%AF%87/1666707236900.png" alt="1666707236900"><br><code>data</code>之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行 <code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的 <code>数据污染</code>。<br>如果data是对象的话，每当被复用是，复用的对象和源对象都会指向同一个内存地址（浅拷贝），互相之间相互影响；而函数的话，就会形成闭包，保护变量，不会造成影响。</p><h3 id="如何获取data中某一个数据的初始状态？"><a href="#如何获取data中某一个数据的初始状态？" class="headerlink" title="如何获取data中某一个数据的初始状态？"></a>如何获取data中某一个数据的初始状态？</h3><blockquote><p>在开发中，有时候需要拿初始状态去计算。例如</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="attr">num</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">howMuch</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出num增加了多少，那就是1000 - 初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通过this.$options.data().xxx来获取初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> - <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="title function_">data</span>().<span class="property">num</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态指令和参数使用过吗？"><a href="#动态指令和参数使用过吗？" class="headerlink" title="动态指令和参数使用过吗？"></a>动态指令和参数使用过吗？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;aButton@[someEvent]=<span class="string">&quot;handleSomeEvent()&quot;</span>:[someProps]=<span class="string">&quot;1000&quot;</span>/&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">someEvent</span>: someCondition ? <span class="string">&quot;click&quot;</span> : <span class="string">&quot;dbclick&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">someProps</span>:someCondition ? <span class="string">&quot;num&quot;</span> : <span class="string">&quot;price&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleSomeEvent</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// handle some event</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="如何设置动态class，动态style？"><a href="#如何设置动态class，动态style？" class="headerlink" title="如何设置动态class，动态style？"></a>如何设置动态class，动态style？</h3><ul><li><p>动态class对象：</p><p><code>&lt;div :class=&quot;&#123; &#39;is-active&#39;: true, &#39;red&#39;: isRed &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态class数组：</p><p><code>&lt;div :class=&quot;[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style对象：</p><p><code>&lt;div :style=&quot;&#123; color: textColor, fontSize: &#39;18px&#39; &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style数组：</p></li></ul><p><code> &lt;div :style=&quot;[&#123; color: textColor, fontSize: &#39;18px&#39; &#125;, &#123; fontWeight: &#39;300&#39; &#125;]&quot;&gt;&lt;/div&gt;</code></p><h3 id="为什么v-if和v-for不建议用在同一标签？"><a href="#为什么v-if和v-for不建议用在同一标签？" class="headerlink" title="为什么v-if和v-for不建议用在同一标签？"></a>为什么v-if和v-for不建议用在同一标签？</h3><p>在Vue2中，<code>v-for</code>优先级是高于 <code>v-if</code>的，咱们来看例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;divv-<span class="keyword">for</span>=<span class="string">&quot;item in [1, 2, 3, 4, 5, 6, 7]&quot;</span>v-<span class="keyword">if</span>=<span class="string">&quot;item !== 3&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的写法是 <code>v-for</code>和 <code>v-if</code>同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;divv-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">computed</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">list</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item !== <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="State：定义了应用状态的数据结构，可以在这里设置默认的初始状态"><a href="#State：定义了应用状态的数据结构，可以在这里设置默认的初始状态" class="headerlink" title="State：定义了应用状态的数据结构，可以在这里设置默认的初始状态"></a>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态</h3><ul><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="Vue的SSR是什么？有什么好处？"><a href="#Vue的SSR是什么？有什么好处？" class="headerlink" title="Vue的SSR是什么？有什么好处？"></a>Vue的SSR是什么？有什么好处？</h3><p>*<code>SSR</code>就是服务端渲染</p><ul><li>基于 <code>nodejs serve</code>服务环境开发，所有 <code>html</code>代码在服务端渲染</li><li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码</li></ul><p>*<code>SSR</code>首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好</p><h3 id="Vue-set方法的原理"><a href="#Vue-set方法的原理" class="headerlink" title="Vue.set方法的原理"></a>Vue.set方法的原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">functionset</span>(target, key, val) &#123;</span><br><span class="line">  <span class="comment">// 判断是否是数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 判断谁大谁小</span></span><br><span class="line">    target.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(target.<span class="property">length</span>, key)</span><br><span class="line">    <span class="comment">// 执行splice</span></span><br><span class="line">    target.<span class="title function_">splice</span>(key, <span class="number">1</span>, val)</span><br><span class="line">    returnval</span><br><span class="line">  &#125;</span><br><span class="line">  constob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果此对象没有不是响应式对象，直接设置并返回</span></span><br><span class="line">  <span class="keyword">if</span> (keyintarget &amp;&amp; !(keyintarget.<span class="property"><span class="keyword">prototype</span></span>) || !ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    returnval</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，新增属性，并响应式处理</span></span><br><span class="line">  <span class="title function_">defineReactive</span>(target, key, val)</span><br><span class="line">  returnval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-delete方法的原理？"><a href="#Vue-delete方法的原理？" class="headerlink" title="Vue.delete方法的原理？"></a>Vue.delete方法的原理？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">functiondel (target, key) &#123;</span><br><span class="line">  <span class="comment">// 判断是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 执行splice</span></span><br><span class="line">    target.<span class="title function_">splice</span>(key, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象本身就没有这个属性，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!(keyintarget)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，删除这个属性</span></span><br><span class="line">  deletetarget[key]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是响应式对象，不是的话，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是的话，删除后要通知视图更新</span></span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="props怎么自定义验证"><a href="#props怎么自定义验证" class="headerlink" title="props怎么自定义验证"></a>props怎么自定义验证</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">num</span>: &#123;</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 返回值为false则验证不通过，报错</span></span><br><span class="line">      <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审查元素时发现data-v-xxxxx，这是啥？"><a href="#审查元素时发现data-v-xxxxx，这是啥？" class="headerlink" title="审查元素时发现data-v-xxxxx，这是啥？"></a>审查元素时发现data-v-xxxxx，这是啥？</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff63f90f2d924ff6b20622a2d05ba367~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><blockquote><p>这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p></blockquote><h3 id="vue的hook的使用"><a href="#vue的hook的使用" class="headerlink" title="vue的hook的使用"></a>vue的hook的使用</h3><ul><li>同一组件中使用</li></ul><blockquote><p>这是我们常用的使用定时器的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">timer</span>:<span class="literal">null</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//具体执行内容</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeDestory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exportdefault&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">      lettimer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//具体执行代码</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line"></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>7.2 父子组件使用</li></ul><blockquote><p>如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"></span><br><span class="line">&lt;rl-child@childMounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line"></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">method () &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"></span><br><span class="line">mounted () &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;childMounted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用hook的话可以更方便：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"></span><br><span class="line">&lt;rl-child@<span class="attr">hook</span>:mounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line"></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">method () &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="provide和inject是响应式的吗？"><a href="#provide和inject是响应式的吗？" class="headerlink" title="provide和inject是响应式的吗？"></a>provide和inject是响应式的吗？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型</span></span><br><span class="line">    <span class="attr">keyName</span>:<span class="variable language_">this</span>.<span class="property">changeValue</span><span class="comment">// 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]</span></span><br><span class="line">    <span class="comment">// keyName: &#x27;test&#x27; value 如果是基本类型，就无法实现响应式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;改变后的名字-李四&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;keyName&#x27;</span>]</span><br><span class="line"><span class="title function_">create</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">keyName</span>) <span class="comment">// 改变后的名字-李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue的el属性和-mount优先级？"><a href="#Vue的el属性和-mount优先级？" class="headerlink" title="Vue的el属性和$mount优先级？"></a>Vue的el属性和$mount优先级？</h3><blockquote><p>比如下面这种情况，Vue会渲染到哪个节点上</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">newVue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>:<span class="function"><span class="params">h</span>=&gt;</span><span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#ggg&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这是官方的一张图，可以看出 <code>el</code>和 <code>$mount</code>同时存在时，<code>el优先级</code> &gt; <code>$mount</code></p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6331091cb145459e0b543c76e9bfc6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="计算变量时，methods和computed哪个好？"><a href="#计算变量时，methods和computed哪个好？" class="headerlink" title="计算变量时，methods和computed哪个好？"></a>计算变量时，methods和computed哪个好？</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">howMuch1</span>()&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">howMuch2</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">index</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data: () &#123;</span></span><br><span class="line"><span class="language-xml">  return &#123;</span></span><br><span class="line"><span class="language-xml">    index: 0</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;,</span></span><br><span class="line"><span class="language-xml">methods: &#123;</span></span><br><span class="line"><span class="language-xml">  howMuch1() &#123;</span></span><br><span class="line"><span class="language-xml">    return this.num + this.price</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;,</span></span><br><span class="line"><span class="language-xml">computed: &#123;</span></span><br><span class="line"><span class="language-xml">  howMuch2() &#123;</span></span><br><span class="line"><span class="language-xml">    return this.num + this.price</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>computed</code>会好一些，因为computed会有 <code>缓存</code>。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。</p></blockquote><h3 id="vue常见性能优化方式"><a href="#vue常见性能优化方式" class="headerlink" title="vue常见性能优化方式"></a>vue常见性能优化方式</h3><ul><li>合理使用 v-show 和 v-if</li><li>合理使用 computed</li><li>v-for 时加 key，以及避免和 v-if 同时使用</li><li>自定义事件、DOM事件及时销毁</li><li>合理使用异步组件</li><li>合理使用 keep-alive</li><li>data 层级不要太深</li><li>使用 vue-loader 在开发环境做模板编译（预编译）</li><li>webpack层面的优化（传送门）</li><li>使用SSR</li></ul><h3 id="vue常⽤的UI组件库"><a href="#vue常⽤的UI组件库" class="headerlink" title="vue常⽤的UI组件库"></a>vue常⽤的UI组件库</h3><p>Mint UI，element，VUX</p><h3 id="简单介绍一下Element-UI的框架设计？"><a href="#简单介绍一下Element-UI的框架设计？" class="headerlink" title="简单介绍一下Element UI的框架设计？"></a>简单介绍一下Element UI的框架设计？</h3><h3 id="Vue首页白屏是什么问题引起的？如何解决呢？"><a href="#Vue首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="Vue首页白屏是什么问题引起的？如何解决呢？"></a>Vue首页白屏是什么问题引起的？如何解决呢？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试之JS篇</title>
    <link href="https://superq314.github.io/posts/cbd6d0c2/"/>
    <id>https://superq314.github.io/posts/cbd6d0c2/</id>
    <published>2022-10-25T07:29:18.000Z</published>
    <updated>2022-12-01T14:57:12.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试之CSS篇</title>
    <link href="https://superq314.github.io/posts/42b47695/"/>
    <id>https://superq314.github.io/posts/42b47695/</id>
    <published>2022-10-25T07:28:56.000Z</published>
    <updated>2022-11-08T02:17:45.538Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CSS中有哪些长度单位"><a href="#CSS中有哪些长度单位" class="headerlink" title="CSS中有哪些长度单位"></a>CSS中有哪些长度单位</h3><ul><li>绝对长度单位：<code>px</code></li><li>百分比: <code>%</code></li><li>相对父元素字体大小单位: <code>em</code></li><li>相对于根元素字体大小的单位: <code>rem</code></li><li>相对于视口*宽度的百分比(100vw即视窗宽度的100%): <code>vw</code></li><li>相对于视口*高度的百分比(100vh即视窗高度的100%): <code>vh</code></li></ul><h3 id="隐藏元素的方法及区别"><a href="#隐藏元素的方法及区别" class="headerlink" title="隐藏元素的方法及区别"></a>隐藏元素的方法及区别</h3><ol><li><code>display: none;</code>：该元素不会在页面中占据位置，渲染书不会渲染，更不会响应绑定的监听事件。</li><li><code>visibility: hidden;</code>：元素在页面中仍占据位置，但是不会响应绑定的监听事件。</li><li><code>opacity: 0;</code>：仅仅是透明度为0，在页面中占据位置，也能够响应元素绑定的监听事件。</li><li><code>position: absolute;</code>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><code>z- index:99999;</code>：设置负值，使其他元素遮盖住该元素，以此来实现隐藏。</li><li><code>transform: scale(0,0);</code>：将元素内容缩放为0,但元素的大小不变，在页面中占据位置，但是不会响应绑定的监听事件。</li></ol><p>注意:</p><ol><li><code>display: none;</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示;</li><li><code>visibility: hidden;</code>是继承属性，子孙节点消失是由于继承了hidden,通过设置visibility: visible可以让子孙节点显示;</li><li>设置display会造成文档重排，而visibility只会诰成本元素重绘;</li></ol><h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><p>如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p><ol><li><p>height、top、bottom：通过包含块的 height 的值。如果包含块的 height 值会根据它的内容变化，而且包含块的 position 属性的值被赋予 relative 或 static ，那么，这些值的计算值为 auto。</p></li><li><p>width、left、right、padding、margin 这些属性由包含块的 width 属性的值来计算它的百分值。</p><p>这里特别强调padding和margin讲的是上下左右四个都是根据包含块的width</p></li></ol><h3 id="display-none和visibility-hidden的区别"><a href="#display-none和visibility-hidden的区别" class="headerlink" title="display:none和visibility:hidden的区别"></a>display:none和visibility:hidden的区别</h3><ol><li><p>dispaly: none 不保留被隐藏对象的物理空间；<br>visibility: hidden 保留被隐藏对象的物理空间。</p></li><li><p>dispaly: none 隐藏该元素及其所有后代元素。给后代元素设置非none也没用。<br>visibility具有继承性，给父元素设置visibility: hidden；子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。</p></li><li><p>浏览器渲染的时候会涉及到重绘与回流的问题</p><ol><li>前者隐藏后脱离文档流，不占据页面空间引发回流</li><li>后者隐藏后还占用空间，只引起重绘。</li></ol><blockquote><p>因此优化时：建议用visibility: hidden替换display: none</p></blockquote></li><li><p>CSS3的transition支持visibility属性，但是不支持display</p><blockquote><p>由于transition可以延迟执行，因此可以配合visibility使用纯css实现hover延时显示效果。</p></blockquote></li></ol><h3 id="常用布局方式"><a href="#常用布局方式" class="headerlink" title="常用布局方式"></a>常用布局方式</h3><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><h3 id="垂直水平居中方式"><a href="#垂直水平居中方式" class="headerlink" title="垂直水平居中方式"></a>垂直水平居中方式</h3><h3 id="解决纵向重叠问题"><a href="#解决纵向重叠问题" class="headerlink" title="解决纵向重叠问题"></a>解决纵向重叠问题</h3><h3 id="用CSS实现三角形"><a href="#用CSS实现三角形" class="headerlink" title="用CSS实现三角形"></a>用CSS实现三角形</h3><h3 id="CSS3新特征"><a href="#CSS3新特征" class="headerlink" title="CSS3新特征"></a>CSS3新特征</h3><ul><li>圆角（border-radius）</li><li>阴影（box-shadow）</li><li>文字特效(text-shadow)</li><li>线性渐变（gradient）</li><li>变换(transform)</li><li>更多的CSS选择器</li><li>更多背景设置（background）</li><li>色彩模式（rgba）</li><li>伪元素（::selection）</li><li>媒体查询（@media）</li><li>多栏布局（column）</li><li>图片边框（border-image）</li></ul><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><table><thead><tr><th>伪类</th><th>伪元素</th></tr></thead><tbody><tr><td>根据元素的特征分类，而不是名字、属性、内容</td><td>建立对超出文档语言指定的文档树的抽象</td></tr><tr><td>可以出现在选择器的任何位置</td><td>只能跟在选择器的最后一个简单选择器后面</td></tr></tbody></table><p>在 <code>CSS3</code>的规范里，单冒号表示伪类，伪元素的语法被修改成使用双冒。伪元素并不存在与 <code>dom</code>中，只存在于页面之中。</p><ul><li>伪类本质上是为了弥补常规 <code>CSS</code>选择器的不足，以便获取到更多信息；</li><li>伪元素本质上是创建了一个有内容的虚拟容器；</li><li><code>CSS3</code>中伪类和伪元素的语法不同；</li><li>可以同时使用多个伪类，而只能同时使用一个伪元素。</li><li>都不会出现在源文档或者文档树中</li></ul><h3 id="transition都有哪些过渡属性？"><a href="#transition都有哪些过渡属性？" class="headerlink" title="transition都有哪些过渡属性？"></a>transition都有哪些过渡属性？</h3><h3 id="link和-import的区别？"><a href="#link和-import的区别？" class="headerlink" title="link和@import的区别？"></a>link和@import的区别？</h3><p>link属于html标签，而@import是css提供的。</p><p>页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载的。</p><p>兼容性问题：@import只在IE5以上才能识别，而link是html标签，无兼容性问题。</p><p>权重问题:@import的权重要高于link。</p><p>DOM操作:DOM可以操作link中的样式，而不可以操作@import中的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html 文件 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- link 方式，推荐 --&gt;</span></span><br><span class="line">&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;style.css&quot;media=&quot;screen&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @import 方式 --&gt;</span></span><br><span class="line">&lt;styletype=&quot;text/css&quot;media=&quot;screen&quot;&gt;</span><br><span class="line">  @importurl(style.css);</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用的动画库有哪些？"><a href="#常用的动画库有哪些？" class="headerlink" title="常用的动画库有哪些？"></a>常用的动画库有哪些？</h3><h3 id="href与src的区别"><a href="#href与src的区别" class="headerlink" title="href与src的区别"></a>href与src的区别</h3><h3 id="如何让CSS只在当前组件中起作用？"><a href="#如何让CSS只在当前组件中起作用？" class="headerlink" title="如何让CSS只在当前组件中起作用？"></a>如何让CSS只在当前组件中起作用？</h3><p>将当前组件的 <code>&lt;style&gt;</code>修改为 <code>&lt;style scoped&gt;</code>。</p><h3 id="网站cover背景图缩放不改变比例"><a href="#网站cover背景图缩放不改变比例" class="headerlink" title="网站cover背景图缩放不改变比例"></a>网站cover背景图缩放不改变比例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">img/xxx.jpg</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试之HTML篇</title>
    <link href="https://superq314.github.io/posts/58958bc4/"/>
    <id>https://superq314.github.io/posts/58958bc4/</id>
    <published>2022-10-25T07:28:43.000Z</published>
    <updated>2022-11-07T15:18:05.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="语义话的目的是什么？"><a href="#语义话的目的是什么？" class="headerlink" title="语义话的目的是什么？"></a>语义话的目的是什么？</h3><p>语义化的主要目的可以概括为用正确的标签做正确的事</p><p>HTMl语义化可以让页面的内容结构化，以便于浏览器解析和搜索引擎解析，<br>并且提高了代码的可读性便于代码维护，</p><h3 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h3><p>块元素：div、h1~h6、ul、li、table、p、br、form。</p><blockquote><p>特征：独占一行，换行显示，可以设置宽高，可以嵌套块和行</p></blockquote><p>行内元素：span、a、img、textarea、select、option、input。</p><blockquote><p>特征：只有在行内显示，内容撑开宽、高，不可以设置宽、高（img、input、textarea等除外）。</p></blockquote><h3 id="HTML5新增元素"><a href="#HTML5新增元素" class="headerlink" title="HTML5新增元素"></a>HTML5新增元素</h3><p>Canvas绘图以及SVG绘图。<br>拖放（Drag and drop）API<br>语义化标签（header、nav、footer、article、section）<br>音频、视频（audio、video）API<br>地理定位（Geolocation）<br>本地离线存储（localStorage）,长期存储数据，关闭浏览器后不丢失。<br>会话储存（sessionStorage）,数据在关闭浏览器后自动删除。<br>表单控件（calendar、date、time、email、url、search）</p><h3 id="cookie与sessionStorage和localStorage的区别"><a href="#cookie与sessionStorage和localStorage的区别" class="headerlink" title="cookie与sessionStorage和localStorage的区别"></a>cookie与sessionStorage和localStorage的区别</h3><ul><li>保存方式<ul><li>cookie存放在客户的浏览器上。</li><li>session都在客户端中保存，不参与服务器通讯。</li></ul></li><li>生命周期<ul><li>cookie可设置失效时间</li><li>localStorage除非手动清除否则永久保存</li><li>sessionStorage关闭当前页面或浏览器后失效</li></ul></li><li>存储的大小<ul><li>cookie 4kb左右</li><li>session 5M</li></ul></li><li>易用性<ul><li>cookie需自己封装</li><li>session可以接受原生接口</li></ul></li></ul><p>因为cookie每次请求都会携带在http请求中,所以它的主要用来识别用户登录,localStorage可以用来跨页面传参,sessionStorage可以用来保留一些临时数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="面试" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>JS的运行机制</title>
    <link href="https://superq314.github.io/posts/b422724c/"/>
    <id>https://superq314.github.io/posts/b422724c/</id>
    <published>2022-10-24T14:09:43.000Z</published>
    <updated>2022-10-25T02:34:39.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h3><p>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h3 id="js事件循环"><a href="#js事件循环" class="headerlink" title="js事件循环"></a>js事件循环</h3><p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml17948\wps6.jpg"></p><p>这里解释一下这张图：</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p><strong>那主线程执行栈何时为空呢？</strong><br>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>以上就是js运行的整体流程</p><p>面试中该如何回答呢？下面是我个人推荐的回答：</p><ol><li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ol><p>最后可以用下面一道题检测一下收获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。<br>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕<br>因此结果是25431</p><p>相关资料：</p><ul><li><a href="https://juejin.cn/post/6844903606466904078" title="https://juejin.cn/post/6844903606466904078">《浏览器事件循环机制（event loop）》</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/33058983" title="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a></li><li><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/10/event_loop.html" title="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《Event Loop》</a></li><li><a href="https://juejin.cn/post/6844903512845860872" title="https://juejin.cn/post/6844903512845860872">《这一次，彻底弄懂 JavaScript 执行机制》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="异步编程" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="https://superq314.github.io/posts/8dbe3817/"/>
    <id>https://superq314.github.io/posts/8dbe3817/</id>
    <published>2022-10-24T07:32:38.000Z</published>
    <updated>2022-10-24T08:29:30.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>状态管理</p><blockquote><p>理论上来说，每一个 Vue 组件实例都已经在“管理”它自己的响应式状态了。我们以一个简单的计数器组件为例：</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 动作</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">count</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 视图 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>它是一个独立的单元，由以下几个部分组成：</p><ul><li>状态：驱动整个应用的数据源；</li><li>视图：对状态的一种声明式映射；</li><li>交互：状态根据用户在视图中的输入而作出相应变更的可能方式。<br>下面是“单向数据流”这一概念的简单图示：<br><img src="/image/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/1666598553488.png" alt="1666598553488"><br>然而，当我们有多个组件共享一个共同的状态时，就没有这么简单了：</li><li>多个视图可能都依赖于同一份状态。</li><li>来自不同视图的交互也可能需要更改同一份状态。<br>对于情景 1，一个可行的办法是将共享状态“提升”到共同的祖先组件上去，再通过 props 传递下来。然而在深层次的组件树结构中这么做的话，很快就会使得代码变得繁琐冗长。这会导致另一个问题：Prop 逐级透传问题。<br>对于情景 2，我们经常发现自己会直接通过模板引用获取父&#x2F;子实例，或者通过触发的事件尝试改变和同步多个状态的副本。但这些模式的健壮性都不甚理想，很容易就会导致代码难以维护。<br>一个更简单直接的解决方案是抽取出组件间的共享状态，放在一个全局单例中来管理。这样我们的组件树就变成了一个大的“视图”，而任何位置上的组件都可以访问其中的状态或触发动作。</li></ul><h2 id="用响应式-API-做简单状态管理"><a href="#用响应式-API-做简单状态管理" class="headerlink" title="用响应式 API 做简单状态管理"></a>用响应式 API 做简单状态管理</h2><p>如果你有一部分状态需要在多个组件实例间共享，你可以使用 reactive() 来创建一个响应式对象，并将它导入到多个组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- ComponentA.vue --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./store.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      store</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>From A: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- ComponentB.vue --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./store.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      store</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在每当 store 对象被更改时，<ComponentA> 与 <ComponentB> 都会自动更新它们的视图。现在我们有了单一的数据源。<br>然而，这也意味着任意一个导入了 store 的组件都可以随意修改它的状态：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.count++&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>虽然这在简单的情况下是可行的，但从长远来看，可以被任何组件任意改变的全局状态是不太容易维护的。为了确保改变状态的逻辑像状态本身一样集中，建议在 store 上定义方法，方法的名称应该要能表达出行动的意图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.increment()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>TIP：这里点击的处理函数使用了 store.increment()，带上了圆括号作为内联表达式调用，因为它并不是组件的方法，并且必须要以正确的 this 上下文来调用。<br>除了我们这里用到的单个响应式对象作为一个 store 之外，你还可以使用其他响应式 API 例如 ref() 或是 computed()，或是甚至通过一个组合式函数来返回一个全局状态：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; <span class="keyword">ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局状态，创建在模块作用域下</span></span><br><span class="line"><span class="keyword">const</span> globalCount = <span class="keyword">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="function">export function <span class="title">useCount</span>()</span> &#123;  </span><br><span class="line">  <span class="comment">// 局部状态，每个组件都会创建</span></span><br><span class="line">  <span class="keyword">const</span> localCount = <span class="keyword">ref</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    globalCount,</span><br><span class="line">    localCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Vue 的响应性系统与组件层是解耦的，这使得它非常灵活。</p><h2 id="SSR-相关细节"><a href="#SSR-相关细节" class="headerlink" title="SSR 相关细节"></a>SSR 相关细节</h2><p>如果你正在构建一个需要利用服务端渲染 (SSR) 的应用，由于 store 是跨多个请求共享的单例，上述模式可能会导致问题。这在 SSR 指引那一章节会讨论更多细节。</p><h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><p>虽然我们的手动状态管理解决方案在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：</p><ul><li>更强的团队协作约定</li><li>与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试</li><li>模块热更新 (HMR)</li><li>服务端渲染支持<br>Pinia 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。<br>现有用户可能对 Vuex 更熟悉，它是 Vue 之前的官方状态管理库。由于 Pinia 在生态系统中能够承担相同的职责且能做得更好，因此 Vuex 现在处于维护模式。它仍然可以工作，但不再接受新的功能。对于新的应用，建议使用 Pinia。<br>事实上，Pinia 最初正是为了探索 Vuex 的下一个版本而开发的，因此整合了核心团队关于 Vuex 5 的许多想法。最终，我们意识到 Pinia 已经实现了我们想要在 Vuex 5 中提供的大部分内容，因此决定将其作为新的官方推荐。<br>相比于 Vuex，Pinia 提供了更简洁直接的 API，并提供了组合式风格的 API，最重要的是，在使用 TypeScript 时它提供了更完善的类型推导。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>路由管理</title>
    <link href="https://superq314.github.io/posts/8086859f/"/>
    <id>https://superq314.github.io/posts/8086859f/</id>
    <published>2022-10-24T07:32:25.000Z</published>
    <updated>2022-10-24T08:29:30.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="客户端-vs-服务端路由"><a href="#客户端-vs-服务端路由" class="headerlink" title="客户端 vs. 服务端路由"></a>客户端 vs. 服务端路由</h2><p>服务端路由指的是服务器根据用户访问的 URL 路径返回不同的响应结果。当我们在一个传统的服务端渲染的 web 应用中点击一个链接时，浏览器会从服务端获得全新的 HTML，然后重新加载整个页面。<br>然而，在单页面应用中，客户端的 JavaScript 可以拦截页面的跳转请求，动态获取新的数据，然后在无需重新加载的情况下更新当前页面。这样通常可以带来更顺滑的用户体验，尤其是在更偏向“应用”的场景下，因为这类场景下用户通常会在很长的一段时间中做出多次交互。<br>在这类单页应用中，“路由”是在客户端执行的。一个客户端路由器的职责就是利用诸如 History API 或是 hashchange 事件这样的浏览器 API 来管理应用当前应该渲染的视图。</p><h2 id="官方路由"><a href="#官方路由" class="headerlink" title="官方路由"></a>官方路由</h2><p>Vue 很适合用来构建单页面应用。<br>对于大多数此类应用，都推荐使用官方支持的路由库。要了解更多细节，请查看 Vue Router 的文档。</p><h3 id="从头开始实现一个简单的路由"><a href="#从头开始实现一个简单的路由" class="headerlink" title="从头开始实现一个简单的路由"></a>从头开始实现一个简单的路由</h3><p>如果你只需要一个简单的页面路由，而不想为此引入一整个路由库，你可以通过动态组件的方式，监听浏览器 hashchange 事件或使用 History API 来更新当前组件。<br>下面是一个简单的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./About.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">NotFound</span> <span class="keyword">from</span> <span class="string">&#x27;./NotFound.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> routes = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="string">&#x27;/&#x27;</span>: <span class="title class_">Home</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="string">&#x27;/about&#x27;</span>: <span class="title class_">About</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> currentPath = <span class="title function_">ref</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  currentPath.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> currentView = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> routes[currentPath.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span>] || <span class="title class_">NotFound</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/non-existent-path&quot;</span>&gt;</span>Broken Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentView&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>工具链</title>
    <link href="https://superq314.github.io/posts/30a49cf0/"/>
    <id>https://superq314.github.io/posts/30a49cf0/</id>
    <published>2022-10-24T07:31:40.000Z</published>
    <updated>2022-10-24T08:44:10.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Vite</button></li><li class="tab"><button type="button" data-href="#super-2">Vue CLI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>Vite 是一个轻量级的、速度极快的构建工具，对 Vue SFC 提供第一优先级支持。<br>要使用 Vite 来创建一个 Vue 项目，非常简单：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> init vue@latest</span><br></pre></td></tr></table></figure><p>这个命令会安装和执行 create-vue，它是 Vue 提供的官方脚手架工具。跟随命令行的提示继续操作即可。</p><ul><li>要学习更多关于 Vite 的知识，请查看 Vite 官方文档。</li><li>若要了解如何为一个 Vite 项目配置 Vue 相关的特殊行为，比如向 Vue 编译器传递相关选项，请查看 @vitejs&#x2F;plugin-vue 的文档。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>Vue CLI 是官方提供的基于 Webpack 的 Vue 工具链，它现在处于维护模式。我们建议使用 Vite 开始新的项目，除非你依赖特定的 Webpack 的特性。在大多数情况下，Vite 将提供更优秀的开发体验。<br>关于从 Vue CLI 迁移到 Vite 的资源：</p><ul><li>VueSchool.io 的 Vue CLI -&gt; Vite 迁移指南</li><li>迁移支持工具 &#x2F; 插件</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="浏览器内模板编译注意事项"><a href="#浏览器内模板编译注意事项" class="headerlink" title="浏览器内模板编译注意事项"></a>浏览器内模板编译注意事项</h2><p>当以无构建步骤方式使用 Vue 时，组件模板要么是写在页面的 HTML 中，或者是内联的 JavaScript 字符串。在这些场景中，为了执行动态模板编译，Vue 需要将模板编译器运行在浏览器中。相对的，如果我们使用了构建步骤，由于提前编译了模板，那么就无须再在浏览器中运行了。为了减小打包出的客户端代码体积，Vue 提供了多种格式的“构建文件”以适配不同场景下的优化需求。</p><ul><li>前缀为 vue.runtime.* 的文件是只包含运行时的版本：不包含编译器，当使用这个版本时，所有的模板都必须由构建步骤预先编译。</li><li>名称中不包含 .runtime 的文件则是完全版：即包含了编译器，并支持在浏览器中直接编译模板。然而，体积也会因此增长大约 14kb。<br>默认的工具链中都会使用仅含运行时的版本，因为所有 SFC 中的模板都已经被预编译了。如果因为某些原因，在有构建步骤时，你仍需要浏览器内的模板编译，你可以更改构建工具配置，将 vue 改为相应的版本 vue&#x2F;dist&#x2F;vue.esm-bundler.js。</li></ul><h2 id="IDE-支持"><a href="#IDE-支持" class="headerlink" title="IDE 支持"></a>IDE 支持</h2><ul><li>推荐使用的 IDE 是 VSCode，配合 Volar 插件。Volar 提供了语法高亮、TypeScript 支持，以及模板内表达式与组件 props 的智能提示。<blockquote><p>TIP：Volar 取代了我们之前为 Vue 2 提供的官方 VSCode 扩展 Vetur。如果你之前已经安装了 Vetur，请确保在 Vue 3 的项目中禁用它。</p></blockquote></li><li>WebStorm 同样也为 Vue 的单文件组件提供了很好的内置支持。</li><li>其他支持语言服务协议 (LSP) 的 IDE 也可以通过 LSP 享受到 Volar 所提供的的核心功能：</li><li>Sublime Text 通过 LSP-Volar 支持。</li><li>vim &#x2F; Neovim 通过 coc-volar 支持。</li><li>emacs 通过 lsp-mode 支持。</li></ul><h2 id="浏览器开发者插件"><a href="#浏览器开发者插件" class="headerlink" title="浏览器开发者插件"></a>浏览器开发者插件</h2><p>Vue 的浏览器开发者插件使我们可以浏览一个 Vue 应用的组件树，查看各个组件的状态，追踪状态管理的事件，还可以进行组件性能分析。</p><ul><li>文档</li><li>Chrome 插件商店页</li><li>Firefox 所属插件页</li><li>独立的 Electron 应用所属插件</li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul><li>Volar 插件能够为<code>&lt;script lang=&quot;ts&quot;&gt;</code>块提供类型检查，也能对模板内表达式和组件之间 props 提供自动补全和类型验证。</li><li>使用 vue-tsc 可以在命令行中执行相同的类型检查，通常用来生成单文件组件的 d.ts文件。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>Cypress 推荐用于 E2E 测试。也可以通过 Cypress 组件测试运行器来给 Vue SFC 作单文件组件测试。</li><li>Vitest 是一个追求更快运行速度的测试运行器，由Vue &#x2F; Vite团队成员开发。主要针对基于 Vite 的应用设计，可以为组件提供即时响应的测试反馈。</li><li>Jest 可以通过 vite-jest 配合 Vite 使用。不过只推荐在你已经有一套基于 Jest 的测试集、且想要迁移到基于 Vite 的开发配置时使用，因为 Vitest 也能够提供类似的功能，且后者与 Vite 的集成更方便高效。</li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>Vue 团队维护着 eslint-plugin-vue 项目，它是一个 ESLint 插件，会提供 SFC 相关规则的定义。<br>之前使用 Vue CLI 的用户可能习惯于通过 webpack loader 来配置规范检查器。然而，若基于 Vite 构建，我们一般推荐：</p><ol><li>npm install -D eslint eslint-plugin-vue，然后遵照 eslint-plugin-vue 的指引进行配置。</li><li>启用 ESLint IDE 插件，比如 ESLint for VSCode，然后你就可以在开发时获得规范检查器的反馈。这同时也避免了启动开发服务器时不必要的规范检查。</li><li>将 ESLint 格式检查作为一个生产构建的步骤，保证你可以在最终打包时获得完整的规范检查反馈。</li><li>(可选) 启用类似 lint-staged 一类的工具在 git commit 提交时自动执行规范检查。</li></ol><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ul><li>Volar VSCode 插件为 Vue SFC 提供了开箱即用的格式化功能。</li><li>Prettier 也提供了内置的 Vue SFC 格式化支持。</li></ul><h2 id="SFC-自定义块集成"><a href="#SFC-自定义块集成" class="headerlink" title="SFC 自定义块集成"></a>SFC 自定义块集成</h2><p>自定义块被编译成导入到同一 Vue 文件的不同请求查询。这取决于底层构建工具如何处理这类导入请求。</p><ul><li>如果使用 Vite，需使用一个自定义 Vite 插件将自定义块转换为可执行的 JavaScript 代码。</li><li>如果使用 Vue CLI 或只是 webpack，需要使用一个 loader 来配置如何转换匹配到的自定义块。</li></ul><h2 id="底层库"><a href="#底层库" class="headerlink" title="底层库"></a>底层库</h2><ul><li><p><code>@vue/compiler-sfc</code></p><p>Vue 核心 monorepo 的一部分，并始终和 vue 主包版本号保持一致。它已经成为 vue 主包的一个依赖并代理到了 vue&#x2F;compiler-sfc 目录下，因此你无需单独安装它。<br>这个包本身提供了处理 Vue SFC 的底层的功能，并只适用于需要支持 Vue SFC 相关工具链的开发者。</p><blockquote><p>TIP：请始终选择通过 vue&#x2F;compiler-sfc 的深度导入来使用这个包，因为这样可以确保其与 Vue 运行时版本同步。</p></blockquote></li><li><p><code>@vitejs/plugin-vue</code><br>为 Vite 提供 Vue SFC 支持的官方插件。</p></li><li><p><code>vue-loader</code><br>为 webpack 提供 Vue SFC 支持的官方 loader。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>插件</title>
    <link href="https://superq314.github.io/posts/def84ee6/"/>
    <id>https://superq314.github.io/posts/def84ee6/</id>
    <published>2022-10-24T07:30:31.000Z</published>
    <updated>2022-10-24T08:31:15.935Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>插件</p><blockquote><p>一种能为 Vue 添加全局功能的工具代码。<br>安装插件的示例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myPlugin, &#123;  <span class="comment">/* 可选的选项 */</span>&#125;)</span><br></pre></td></tr></table></figure><p>一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的应用实例和传递给 app.use()的额外选项作为参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 配置此应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：</p><ol><li>通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。</li><li>通过 app.provide() 使一个资源可被注入进整个应用。</li><li>向 app.config.globalProperties 中添加一些全局实例属性或方法</li><li>一个可能上述三种都包含了的功能库 (例如 vue-router)。</li></ol><h2 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h2><p>从设置插件对象开始。<br>建议在一个单独的文件中创建并导出它，以保证更好地管理逻辑，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里编写插件代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望有一个翻译函数，这个函数接收一个以 . 作为分隔符的 key 字符串，用来在用户提供的翻译字典中查找对应语言的文本。期望的使用方式如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">$translate</span>(<span class="name">&#x27;greetings.hello&#x27;</span>) &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个函数应当能够在任意模板中被全局调用。这一点可以通过在插件中将它添加到 app.config.globalProperties 上来实现：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line">export default &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注入一个全局可用的 $translate() 方法</span></span><br><span class="line">    app.config.globalProperties.<span class="symbol">$tra</span>nslate = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 `options` 对象的深层属性</span></span><br><span class="line">      <span class="comment">// 使用 `key` 作为索引</span></span><br><span class="line">      <span class="keyword">return</span> key.<span class="built_in">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="built_in">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 $translate 函数会接收一个例如 greetings.hello 的字符串，在用户提供的翻译字典中查找，并返回翻译得到的值。<br>用于查找的翻译字典对象则应当在插件被安装时作为 app.use() 的额外参数被传入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> i18nPlugin <span class="keyword">from</span> <span class="string">&#x27;./plugins/i18n&#x27;</span></span><br><span class="line"></span><br><span class="line">app.use(i18nPlugin, &#123;</span><br><span class="line">  greetings: &#123;</span><br><span class="line">    hello: <span class="string">&#x27;Bonjour!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样，我们一开始的表达式 $translate(‘greetings.hello’) 就会在运行时被替换为 Bonjour! 了。<br>TIP：请谨慎使用全局属性，如果在整个应用中使用不同插件注入的太多全局属性，很容易让应用变得难以理解和维护。</p><h2 id="插件中的-Provide-x2F-Inject"><a href="#插件中的-Provide-x2F-Inject" class="headerlink" title="插件中的 Provide &#x2F; Inject"></a>插件中的 Provide &#x2F; Inject</h2><p>在插件中，我们可以通过 provide 来为插件用户供给一些内容。举例来说，我们可以将插件接收到的 options 参数提供给整个应用，让任何组件都能使用这个翻译字典对象。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> plugins/i18n.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function"><span class="params">(app, options)</span> =&gt;</span> &#123;</span><br><span class="line">    app.config.globalProperties.$translate = <span class="function"><span class="params">(key)</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> key.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function"><span class="params">(o, i)</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.provide(<span class="string">&#x27;i18n&#x27;</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，插件用户就可以在他们的组件中以 i18n 为 key 注入并访问插件的选项对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;i18n&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i18n</span>.<span class="property">greetings</span>.<span class="property">hello</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="逻辑复用" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义指令</title>
    <link href="https://superq314.github.io/posts/71ab3b72/"/>
    <id>https://superq314.github.io/posts/71ab3b72/</id>
    <published>2022-10-24T07:30:19.000Z</published>
    <updated>2022-10-24T08:42:18.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>组件</strong>和<strong>组合式函数</strong>是两种在 Vue 中重用代码的方式。</p><ul><li>组件是主要的构建模块</li><li>组合式函数则侧重于有状态的逻辑<br>自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。<br>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。<br>钩子函数会接收到指令所绑定元素作为其参数。<br>下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> focus = &#123;</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在模板中启用 v-focus</span></span><br><span class="line">    focus</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 autofocus attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。<br>和组件类似，自定义指令在模板中使用前必须先注册。在上面的例子中，我们使用 directives 选项完成了指令的局部注册。<br>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 使 v-focus 在所有组件中都可用</span><br><span class="line">app.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="regexp">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>TIP：只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 v-bind 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。</p></blockquote><h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">myDirective</span> <span class="operator">=</span> &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h2><p>指令的钩子会传递以下几种参数：</p><ul><li><code>el</code>：指令绑定到的元素。这可以用于直接操作 <code>DOM</code>。</li><li><code>binding</code>：一个对象，包含以下属性。<ul><li><code>value </code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code>中，值是 <code>2</code></li><li><code>oldValue</code>：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code>中，参数是 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code>中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li><li><code>instance</code>：使用该指令的组件实例。</li><li><code>dir</code>：指令的定义对象。</li></ul></li><li><code>vnode</code>：代表绑定元素的底层 <code>VNode</code>。</li><li><code>prevNode</code>：之前的渲染中代表指令所绑定元素的 <code>VNode</code>。仅在 <code>beforeUpdate </code>和 <code>updated</code>钩子中可用。<br>举例来说，像下面这样使用指令：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-example:foo.<span class="attribute">bar</span>=<span class="string">&quot;baz&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>binding</code>参数会是一个这样的对象：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  arg: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  modifiers: &#123; bar: true &#125;,</span><br><span class="line">  value: <span class="comment">/* `baz` 的值 */</span>,</span><br><span class="line">  oldValue: <span class="comment">/* 上一次更新时 `baz` 的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和内置指令类似，自定义指令的参数也可以是动态的。举例来说：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-example:[arg]=<span class="string">&quot;value&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>这里指令的参数会基于组件的 <code>arg</code>数据属性响应式地更新。</p><blockquote><p>Note：除了 el 外，其他参数都是只读的，不要更改它们。</p></blockquote><h2 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h2><p>对于自定义指令来说，一个很常见的情况是仅仅需要在 <code>mounted</code>和 <code>updated</code>上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-color=<span class="string">&quot;color&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app<span class="selector-class">.directive</span>(<span class="string">&#x27;color&#x27;</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span><br><span class="line">  el<span class="selector-class">.style</span><span class="selector-class">.color</span> = binding<span class="selector-class">.value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app<span class="selector-class">.directive</span>(<span class="string">&#x27;demo&#x27;</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(binding<span class="selector-class">.value</span>.<span class="attribute">color</span>) // =&gt; <span class="string">&quot;white&quot;</span></span><br><span class="line">  console<span class="selector-class">.log</span>(binding<span class="selector-class">.value</span>.text) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h2><p>当在组件上使用自定义指令时，它会始终应用于组件的根节点，和透传 attributes 类似。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-demo<span class="operator">=</span><span class="string">&quot;test&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent 的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-demo 指令会被应用在此处 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>My component content<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告。和 attribute 不同，指令不能通过 v-bind&#x3D;”$attrs”来传递给一个不同的元素。总的来说，不推荐在组件上使用自定义指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="逻辑复用" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
    
    
  </entry>
  
</feed>
