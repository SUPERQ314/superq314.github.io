<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-10-25T02:34:39.609Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS的运行机制</title>
    <link href="https://superq314.github.io/posts/b422724c/"/>
    <id>https://superq314.github.io/posts/b422724c/</id>
    <published>2022-10-24T14:09:43.000Z</published>
    <updated>2022-10-25T02:34:39.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h3><p>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h3 id="js事件循环"><a href="#js事件循环" class="headerlink" title="js事件循环"></a>js事件循环</h3><p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml17948\wps6.jpg"></p><p>这里解释一下这张图：</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p><strong>那主线程执行栈何时为空呢？</strong><br>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>以上就是js运行的整体流程</p><p>面试中该如何回答呢？下面是我个人推荐的回答：</p><ol><li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ol><p>最后可以用下面一道题检测一下收获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。<br>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕<br>因此结果是25431</p><p>相关资料：</p><ul><li><a href="https://juejin.cn/post/6844903606466904078" title="https://juejin.cn/post/6844903606466904078">《浏览器事件循环机制（event loop）》</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/33058983" title="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a></li><li><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/10/event_loop.html" title="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《Event Loop》</a></li><li><a href="https://juejin.cn/post/6844903512845860872" title="https://juejin.cn/post/6844903512845860872">《这一次，彻底弄懂 JavaScript 执行机制》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="异步编程" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="https://superq314.github.io/posts/8dbe3817/"/>
    <id>https://superq314.github.io/posts/8dbe3817/</id>
    <published>2022-10-24T07:32:38.000Z</published>
    <updated>2022-10-24T08:29:30.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>状态管理</p><blockquote><p>理论上来说，每一个 Vue 组件实例都已经在“管理”它自己的响应式状态了。我们以一个简单的计数器组件为例：</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 动作</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">count</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 视图 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>它是一个独立的单元，由以下几个部分组成：</p><ul><li>状态：驱动整个应用的数据源；</li><li>视图：对状态的一种声明式映射；</li><li>交互：状态根据用户在视图中的输入而作出相应变更的可能方式。<br>下面是“单向数据流”这一概念的简单图示：<br><img src="/image/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/1666598553488.png" alt="1666598553488"><br>然而，当我们有多个组件共享一个共同的状态时，就没有这么简单了：</li><li>多个视图可能都依赖于同一份状态。</li><li>来自不同视图的交互也可能需要更改同一份状态。<br>对于情景 1，一个可行的办法是将共享状态“提升”到共同的祖先组件上去，再通过 props 传递下来。然而在深层次的组件树结构中这么做的话，很快就会使得代码变得繁琐冗长。这会导致另一个问题：Prop 逐级透传问题。<br>对于情景 2，我们经常发现自己会直接通过模板引用获取父&#x2F;子实例，或者通过触发的事件尝试改变和同步多个状态的副本。但这些模式的健壮性都不甚理想，很容易就会导致代码难以维护。<br>一个更简单直接的解决方案是抽取出组件间的共享状态，放在一个全局单例中来管理。这样我们的组件树就变成了一个大的“视图”，而任何位置上的组件都可以访问其中的状态或触发动作。</li></ul><h2 id="用响应式-API-做简单状态管理"><a href="#用响应式-API-做简单状态管理" class="headerlink" title="用响应式 API 做简单状态管理"></a>用响应式 API 做简单状态管理</h2><p>如果你有一部分状态需要在多个组件实例间共享，你可以使用 reactive() 来创建一个响应式对象，并将它导入到多个组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- ComponentA.vue --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./store.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      store</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>From A: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- ComponentB.vue --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./store.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      store</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在每当 store 对象被更改时，<ComponentA> 与 <ComponentB> 都会自动更新它们的视图。现在我们有了单一的数据源。<br>然而，这也意味着任意一个导入了 store 的组件都可以随意修改它的状态：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.count++&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>虽然这在简单的情况下是可行的，但从长远来看，可以被任何组件任意改变的全局状态是不太容易维护的。为了确保改变状态的逻辑像状态本身一样集中，建议在 store 上定义方法，方法的名称应该要能表达出行动的意图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.increment()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    From B: </span><span class="template-variable">&#123;&#123; <span class="name">store.count</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>TIP：这里点击的处理函数使用了 store.increment()，带上了圆括号作为内联表达式调用，因为它并不是组件的方法，并且必须要以正确的 this 上下文来调用。<br>除了我们这里用到的单个响应式对象作为一个 store 之外，你还可以使用其他响应式 API 例如 ref() 或是 computed()，或是甚至通过一个组合式函数来返回一个全局状态：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; <span class="keyword">ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局状态，创建在模块作用域下</span></span><br><span class="line"><span class="keyword">const</span> globalCount = <span class="keyword">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="function">export function <span class="title">useCount</span>()</span> &#123;  </span><br><span class="line">  <span class="comment">// 局部状态，每个组件都会创建</span></span><br><span class="line">  <span class="keyword">const</span> localCount = <span class="keyword">ref</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    globalCount,</span><br><span class="line">    localCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Vue 的响应性系统与组件层是解耦的，这使得它非常灵活。</p><h2 id="SSR-相关细节"><a href="#SSR-相关细节" class="headerlink" title="SSR 相关细节"></a>SSR 相关细节</h2><p>如果你正在构建一个需要利用服务端渲染 (SSR) 的应用，由于 store 是跨多个请求共享的单例，上述模式可能会导致问题。这在 SSR 指引那一章节会讨论更多细节。</p><h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><p>虽然我们的手动状态管理解决方案在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：</p><ul><li>更强的团队协作约定</li><li>与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试</li><li>模块热更新 (HMR)</li><li>服务端渲染支持<br>Pinia 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。<br>现有用户可能对 Vuex 更熟悉，它是 Vue 之前的官方状态管理库。由于 Pinia 在生态系统中能够承担相同的职责且能做得更好，因此 Vuex 现在处于维护模式。它仍然可以工作，但不再接受新的功能。对于新的应用，建议使用 Pinia。<br>事实上，Pinia 最初正是为了探索 Vuex 的下一个版本而开发的，因此整合了核心团队关于 Vuex 5 的许多想法。最终，我们意识到 Pinia 已经实现了我们想要在 Vuex 5 中提供的大部分内容，因此决定将其作为新的官方推荐。<br>相比于 Vuex，Pinia 提供了更简洁直接的 API，并提供了组合式风格的 API，最重要的是，在使用 TypeScript 时它提供了更完善的类型推导。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>路由管理</title>
    <link href="https://superq314.github.io/posts/8086859f/"/>
    <id>https://superq314.github.io/posts/8086859f/</id>
    <published>2022-10-24T07:32:25.000Z</published>
    <updated>2022-10-24T08:29:30.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="客户端-vs-服务端路由"><a href="#客户端-vs-服务端路由" class="headerlink" title="客户端 vs. 服务端路由"></a>客户端 vs. 服务端路由</h2><p>服务端路由指的是服务器根据用户访问的 URL 路径返回不同的响应结果。当我们在一个传统的服务端渲染的 web 应用中点击一个链接时，浏览器会从服务端获得全新的 HTML，然后重新加载整个页面。<br>然而，在单页面应用中，客户端的 JavaScript 可以拦截页面的跳转请求，动态获取新的数据，然后在无需重新加载的情况下更新当前页面。这样通常可以带来更顺滑的用户体验，尤其是在更偏向“应用”的场景下，因为这类场景下用户通常会在很长的一段时间中做出多次交互。<br>在这类单页应用中，“路由”是在客户端执行的。一个客户端路由器的职责就是利用诸如 History API 或是 hashchange 事件这样的浏览器 API 来管理应用当前应该渲染的视图。</p><h2 id="官方路由"><a href="#官方路由" class="headerlink" title="官方路由"></a>官方路由</h2><p>Vue 很适合用来构建单页面应用。<br>对于大多数此类应用，都推荐使用官方支持的路由库。要了解更多细节，请查看 Vue Router 的文档。</p><h3 id="从头开始实现一个简单的路由"><a href="#从头开始实现一个简单的路由" class="headerlink" title="从头开始实现一个简单的路由"></a>从头开始实现一个简单的路由</h3><p>如果你只需要一个简单的页面路由，而不想为此引入一整个路由库，你可以通过动态组件的方式，监听浏览器 hashchange 事件或使用 History API 来更新当前组件。<br>下面是一个简单的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./About.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">NotFound</span> <span class="keyword">from</span> <span class="string">&#x27;./NotFound.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> routes = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="string">&#x27;/&#x27;</span>: <span class="title class_">Home</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="string">&#x27;/about&#x27;</span>: <span class="title class_">About</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> currentPath = <span class="title function_">ref</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  currentPath.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> currentView = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> routes[currentPath.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span>] || <span class="title class_">NotFound</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/non-existent-path&quot;</span>&gt;</span>Broken Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentView&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>工具链</title>
    <link href="https://superq314.github.io/posts/30a49cf0/"/>
    <id>https://superq314.github.io/posts/30a49cf0/</id>
    <published>2022-10-24T07:31:40.000Z</published>
    <updated>2022-10-24T08:44:10.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">Vite</button></li><li class="tab"><button type="button" data-href="#super-2">Vue CLI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>Vite 是一个轻量级的、速度极快的构建工具，对 Vue SFC 提供第一优先级支持。<br>要使用 Vite 来创建一个 Vue 项目，非常简单：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> init vue@latest</span><br></pre></td></tr></table></figure><p>这个命令会安装和执行 create-vue，它是 Vue 提供的官方脚手架工具。跟随命令行的提示继续操作即可。</p><ul><li>要学习更多关于 Vite 的知识，请查看 Vite 官方文档。</li><li>若要了解如何为一个 Vite 项目配置 Vue 相关的特殊行为，比如向 Vue 编译器传递相关选项，请查看 @vitejs&#x2F;plugin-vue 的文档。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>Vue CLI 是官方提供的基于 Webpack 的 Vue 工具链，它现在处于维护模式。我们建议使用 Vite 开始新的项目，除非你依赖特定的 Webpack 的特性。在大多数情况下，Vite 将提供更优秀的开发体验。<br>关于从 Vue CLI 迁移到 Vite 的资源：</p><ul><li>VueSchool.io 的 Vue CLI -&gt; Vite 迁移指南</li><li>迁移支持工具 &#x2F; 插件</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="浏览器内模板编译注意事项"><a href="#浏览器内模板编译注意事项" class="headerlink" title="浏览器内模板编译注意事项"></a>浏览器内模板编译注意事项</h2><p>当以无构建步骤方式使用 Vue 时，组件模板要么是写在页面的 HTML 中，或者是内联的 JavaScript 字符串。在这些场景中，为了执行动态模板编译，Vue 需要将模板编译器运行在浏览器中。相对的，如果我们使用了构建步骤，由于提前编译了模板，那么就无须再在浏览器中运行了。为了减小打包出的客户端代码体积，Vue 提供了多种格式的“构建文件”以适配不同场景下的优化需求。</p><ul><li>前缀为 vue.runtime.* 的文件是只包含运行时的版本：不包含编译器，当使用这个版本时，所有的模板都必须由构建步骤预先编译。</li><li>名称中不包含 .runtime 的文件则是完全版：即包含了编译器，并支持在浏览器中直接编译模板。然而，体积也会因此增长大约 14kb。<br>默认的工具链中都会使用仅含运行时的版本，因为所有 SFC 中的模板都已经被预编译了。如果因为某些原因，在有构建步骤时，你仍需要浏览器内的模板编译，你可以更改构建工具配置，将 vue 改为相应的版本 vue&#x2F;dist&#x2F;vue.esm-bundler.js。</li></ul><h2 id="IDE-支持"><a href="#IDE-支持" class="headerlink" title="IDE 支持"></a>IDE 支持</h2><ul><li>推荐使用的 IDE 是 VSCode，配合 Volar 插件。Volar 提供了语法高亮、TypeScript 支持，以及模板内表达式与组件 props 的智能提示。<blockquote><p>TIP：Volar 取代了我们之前为 Vue 2 提供的官方 VSCode 扩展 Vetur。如果你之前已经安装了 Vetur，请确保在 Vue 3 的项目中禁用它。</p></blockquote></li><li>WebStorm 同样也为 Vue 的单文件组件提供了很好的内置支持。</li><li>其他支持语言服务协议 (LSP) 的 IDE 也可以通过 LSP 享受到 Volar 所提供的的核心功能：</li><li>Sublime Text 通过 LSP-Volar 支持。</li><li>vim &#x2F; Neovim 通过 coc-volar 支持。</li><li>emacs 通过 lsp-mode 支持。</li></ul><h2 id="浏览器开发者插件"><a href="#浏览器开发者插件" class="headerlink" title="浏览器开发者插件"></a>浏览器开发者插件</h2><p>Vue 的浏览器开发者插件使我们可以浏览一个 Vue 应用的组件树，查看各个组件的状态，追踪状态管理的事件，还可以进行组件性能分析。</p><ul><li>文档</li><li>Chrome 插件商店页</li><li>Firefox 所属插件页</li><li>独立的 Electron 应用所属插件</li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul><li>Volar 插件能够为<code>&lt;script lang=&quot;ts&quot;&gt;</code>块提供类型检查，也能对模板内表达式和组件之间 props 提供自动补全和类型验证。</li><li>使用 vue-tsc 可以在命令行中执行相同的类型检查，通常用来生成单文件组件的 d.ts文件。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>Cypress 推荐用于 E2E 测试。也可以通过 Cypress 组件测试运行器来给 Vue SFC 作单文件组件测试。</li><li>Vitest 是一个追求更快运行速度的测试运行器，由Vue &#x2F; Vite团队成员开发。主要针对基于 Vite 的应用设计，可以为组件提供即时响应的测试反馈。</li><li>Jest 可以通过 vite-jest 配合 Vite 使用。不过只推荐在你已经有一套基于 Jest 的测试集、且想要迁移到基于 Vite 的开发配置时使用，因为 Vitest 也能够提供类似的功能，且后者与 Vite 的集成更方便高效。</li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>Vue 团队维护着 eslint-plugin-vue 项目，它是一个 ESLint 插件，会提供 SFC 相关规则的定义。<br>之前使用 Vue CLI 的用户可能习惯于通过 webpack loader 来配置规范检查器。然而，若基于 Vite 构建，我们一般推荐：</p><ol><li>npm install -D eslint eslint-plugin-vue，然后遵照 eslint-plugin-vue 的指引进行配置。</li><li>启用 ESLint IDE 插件，比如 ESLint for VSCode，然后你就可以在开发时获得规范检查器的反馈。这同时也避免了启动开发服务器时不必要的规范检查。</li><li>将 ESLint 格式检查作为一个生产构建的步骤，保证你可以在最终打包时获得完整的规范检查反馈。</li><li>(可选) 启用类似 lint-staged 一类的工具在 git commit 提交时自动执行规范检查。</li></ol><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ul><li>Volar VSCode 插件为 Vue SFC 提供了开箱即用的格式化功能。</li><li>Prettier 也提供了内置的 Vue SFC 格式化支持。</li></ul><h2 id="SFC-自定义块集成"><a href="#SFC-自定义块集成" class="headerlink" title="SFC 自定义块集成"></a>SFC 自定义块集成</h2><p>自定义块被编译成导入到同一 Vue 文件的不同请求查询。这取决于底层构建工具如何处理这类导入请求。</p><ul><li>如果使用 Vite，需使用一个自定义 Vite 插件将自定义块转换为可执行的 JavaScript 代码。</li><li>如果使用 Vue CLI 或只是 webpack，需要使用一个 loader 来配置如何转换匹配到的自定义块。</li></ul><h2 id="底层库"><a href="#底层库" class="headerlink" title="底层库"></a>底层库</h2><ul><li><p><code>@vue/compiler-sfc</code></p><p>Vue 核心 monorepo 的一部分，并始终和 vue 主包版本号保持一致。它已经成为 vue 主包的一个依赖并代理到了 vue&#x2F;compiler-sfc 目录下，因此你无需单独安装它。<br>这个包本身提供了处理 Vue SFC 的底层的功能，并只适用于需要支持 Vue SFC 相关工具链的开发者。</p><blockquote><p>TIP：请始终选择通过 vue&#x2F;compiler-sfc 的深度导入来使用这个包，因为这样可以确保其与 Vue 运行时版本同步。</p></blockquote></li><li><p><code>@vitejs/plugin-vue</code><br>为 Vite 提供 Vue SFC 支持的官方插件。</p></li><li><p><code>vue-loader</code><br>为 webpack 提供 Vue SFC 支持的官方 loader。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>插件</title>
    <link href="https://superq314.github.io/posts/def84ee6/"/>
    <id>https://superq314.github.io/posts/def84ee6/</id>
    <published>2022-10-24T07:30:31.000Z</published>
    <updated>2022-10-24T08:31:15.935Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>插件</p><blockquote><p>一种能为 Vue 添加全局功能的工具代码。<br>安装插件的示例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myPlugin, &#123;  <span class="comment">/* 可选的选项 */</span>&#125;)</span><br></pre></td></tr></table></figure><p>一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的应用实例和传递给 app.use()的额外选项作为参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 配置此应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：</p><ol><li>通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。</li><li>通过 app.provide() 使一个资源可被注入进整个应用。</li><li>向 app.config.globalProperties 中添加一些全局实例属性或方法</li><li>一个可能上述三种都包含了的功能库 (例如 vue-router)。</li></ol><h2 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h2><p>从设置插件对象开始。<br>建议在一个单独的文件中创建并导出它，以保证更好地管理逻辑，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里编写插件代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望有一个翻译函数，这个函数接收一个以 . 作为分隔符的 key 字符串，用来在用户提供的翻译字典中查找对应语言的文本。期望的使用方式如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">$translate</span>(<span class="name">&#x27;greetings.hello&#x27;</span>) &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个函数应当能够在任意模板中被全局调用。这一点可以通过在插件中将它添加到 app.config.globalProperties 上来实现：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line">export default &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注入一个全局可用的 $translate() 方法</span></span><br><span class="line">    app.config.globalProperties.<span class="symbol">$tra</span>nslate = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 `options` 对象的深层属性</span></span><br><span class="line">      <span class="comment">// 使用 `key` 作为索引</span></span><br><span class="line">      <span class="keyword">return</span> key.<span class="built_in">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="built_in">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 $translate 函数会接收一个例如 greetings.hello 的字符串，在用户提供的翻译字典中查找，并返回翻译得到的值。<br>用于查找的翻译字典对象则应当在插件被安装时作为 app.use() 的额外参数被传入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> i18nPlugin <span class="keyword">from</span> <span class="string">&#x27;./plugins/i18n&#x27;</span></span><br><span class="line"></span><br><span class="line">app.use(i18nPlugin, &#123;</span><br><span class="line">  greetings: &#123;</span><br><span class="line">    hello: <span class="string">&#x27;Bonjour!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样，我们一开始的表达式 $translate(‘greetings.hello’) 就会在运行时被替换为 Bonjour! 了。<br>TIP：请谨慎使用全局属性，如果在整个应用中使用不同插件注入的太多全局属性，很容易让应用变得难以理解和维护。</p><h2 id="插件中的-Provide-x2F-Inject"><a href="#插件中的-Provide-x2F-Inject" class="headerlink" title="插件中的 Provide &#x2F; Inject"></a>插件中的 Provide &#x2F; Inject</h2><p>在插件中，我们可以通过 provide 来为插件用户供给一些内容。举例来说，我们可以将插件接收到的 options 参数提供给整个应用，让任何组件都能使用这个翻译字典对象。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> plugins/i18n.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function"><span class="params">(app, options)</span> =&gt;</span> &#123;</span><br><span class="line">    app.config.globalProperties.$translate = <span class="function"><span class="params">(key)</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> key.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function"><span class="params">(o, i)</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.provide(<span class="string">&#x27;i18n&#x27;</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，插件用户就可以在他们的组件中以 i18n 为 key 注入并访问插件的选项对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;i18n&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i18n</span>.<span class="property">greetings</span>.<span class="property">hello</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="逻辑复用" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义指令</title>
    <link href="https://superq314.github.io/posts/71ab3b72/"/>
    <id>https://superq314.github.io/posts/71ab3b72/</id>
    <published>2022-10-24T07:30:19.000Z</published>
    <updated>2022-10-24T08:42:18.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>组件</strong>和<strong>组合式函数</strong>是两种在 Vue 中重用代码的方式。</p><ul><li>组件是主要的构建模块</li><li>组合式函数则侧重于有状态的逻辑<br>自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。<br>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。<br>钩子函数会接收到指令所绑定元素作为其参数。<br>下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> focus = &#123;</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在模板中启用 v-focus</span></span><br><span class="line">    focus</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 autofocus attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。<br>和组件类似，自定义指令在模板中使用前必须先注册。在上面的例子中，我们使用 directives 选项完成了指令的局部注册。<br>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 使 v-focus 在所有组件中都可用</span><br><span class="line">app.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="regexp">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>TIP：只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 v-bind 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。</p></blockquote><h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">myDirective</span> <span class="operator">=</span> &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params">el</span>, <span class="params">binding</span>, <span class="params">vnode</span>, <span class="params">prevVnode</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h2><p>指令的钩子会传递以下几种参数：</p><ul><li><code>el</code>：指令绑定到的元素。这可以用于直接操作 <code>DOM</code>。</li><li><code>binding</code>：一个对象，包含以下属性。<ul><li><code>value </code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code>中，值是 <code>2</code></li><li><code>oldValue</code>：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code>中，参数是 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code>中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li><li><code>instance</code>：使用该指令的组件实例。</li><li><code>dir</code>：指令的定义对象。</li></ul></li><li><code>vnode</code>：代表绑定元素的底层 <code>VNode</code>。</li><li><code>prevNode</code>：之前的渲染中代表指令所绑定元素的 <code>VNode</code>。仅在 <code>beforeUpdate </code>和 <code>updated</code>钩子中可用。<br>举例来说，像下面这样使用指令：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-example:foo.<span class="attribute">bar</span>=<span class="string">&quot;baz&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>binding</code>参数会是一个这样的对象：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  arg: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  modifiers: &#123; bar: true &#125;,</span><br><span class="line">  value: <span class="comment">/* `baz` 的值 */</span>,</span><br><span class="line">  oldValue: <span class="comment">/* 上一次更新时 `baz` 的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和内置指令类似，自定义指令的参数也可以是动态的。举例来说：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-example:[arg]=<span class="string">&quot;value&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>这里指令的参数会基于组件的 <code>arg</code>数据属性响应式地更新。</p><blockquote><p>Note：除了 el 外，其他参数都是只读的，不要更改它们。</p></blockquote><h2 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h2><p>对于自定义指令来说，一个很常见的情况是仅仅需要在 <code>mounted</code>和 <code>updated</code>上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-color=<span class="string">&quot;color&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app<span class="selector-class">.directive</span>(<span class="string">&#x27;color&#x27;</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span><br><span class="line">  el<span class="selector-class">.style</span><span class="selector-class">.color</span> = binding<span class="selector-class">.value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app<span class="selector-class">.directive</span>(<span class="string">&#x27;demo&#x27;</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(binding<span class="selector-class">.value</span>.<span class="attribute">color</span>) // =&gt; <span class="string">&quot;white&quot;</span></span><br><span class="line">  console<span class="selector-class">.log</span>(binding<span class="selector-class">.value</span>.text) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h2><p>当在组件上使用自定义指令时，它会始终应用于组件的根节点，和透传 attributes 类似。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-demo<span class="operator">=</span><span class="string">&quot;test&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent 的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-demo 指令会被应用在此处 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>My component content<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告。和 attribute 不同，指令不能通过 v-bind&#x3D;”$attrs”来传递给一个不同的元素。总的来说，不推荐在组件上使用自定义指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="逻辑复用" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>组合式函数</title>
    <link href="https://superq314.github.io/posts/f41f26a4/"/>
    <id>https://superq314.github.io/posts/f41f26a4/</id>
    <published>2022-10-24T07:29:43.000Z</published>
    <updated>2022-10-24T08:38:46.358Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">标准化</button></li><li class="tab"><button type="button" data-href="#super-2">“组合式函数”</button></li><li class="tab"><button type="button" data-href="#super-3">异步状态处理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">定义</button></li><li class="tab"><button type="button" data-href="#super-2">输入参数</button></li><li class="tab"><button type="button" data-href="#super-3">返回值</button></li><li class="tab"><button type="button" data-href="#super-4">副作用</button></li><li class="tab"><button type="button" data-href="#super-5">使用限制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><blockquote><p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。<br>一个利用 Vue 的组合式 API 来封装和复用<strong>有状态逻辑</strong>的函数。</p></blockquote><p>当构建前端应用时，我们常常需要复用公共任务的逻辑。复用无状态逻辑的库有很多，比如lodash[lodash.com] 、 date-fns[date-fns.org]。<br>相比之下，<strong>有状态逻辑</strong>负责管理会随时间而变化的状态。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数。如果编写的组合式函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。unref() 工具函数会对此非常有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) &#123;</span><br><span class="line">  <span class="comment">// 若 maybeRef 确实是一个 ref，它的 .value 会被返回</span></span><br><span class="line">  <span class="comment">// 否则，maybeRef 会被原样返回</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的组合式函数在接收 ref 为参数时会产生响应式 effect，请确保使用 watch() 显式地监听此 ref，或者在 watchEffect() 中调用 unref()来进行正确的追踪。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>你可能已经注意到了，我们一直在组合式函数中使用 ref() 而不是 reactive()。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 和 y 是两个 ref</span></span><br><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br></pre></td></tr></table></figure><p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。<br>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包，例如：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">mouse</span> = reactive(useMouse())</span><br><span class="line"><span class="comment">// mouse.x 链接到了原来的 x ref</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">mouse</span>.x)</span><br></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">Mouse position is at: </span><span class="template-variable">&#123;&#123; <span class="name">mouse.x</span> &#125;&#125;</span><span class="language-xml">, </span><span class="template-variable">&#123;&#123; <span class="name">mouse.y</span> &#125;&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p><ul><li>如果你的应用用到了服务端渲染 (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：onMounted()。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</li><li>确保在 onUnmounted() 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 onUnmounted() 中被移除 (就像我们在 useMouse() 示例中看到的一样)。当然也可以像之前的 useEventListener() 示例那样，使用一个组合式函数来自动帮你做这些事。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p>组合式函数在<code>&lt;script setup&gt;</code>或<code>setup()</code>钩子中，应始终被同步地调用。在某些场景下，你也可以在像<code>onMounted()</code>这样的生命周期钩子中使用他们。<br>这个限制是为了让 Vue 能够确定当前正在被执行的到底是哪个组件实例，只有能确认当前组件实例，才能够：</p><ol><li>将生命周期钩子注册到该组件实例上</li><li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。<blockquote><p>TIP：<code>&lt;script setup&gt;</code>是唯一在调用 await 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。</p></blockquote></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>一个简单的例子：跟踪当前鼠标在页面中的位置。</p><blockquote><p>在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。</p></blockquote><p>鼠标跟踪器示例</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 直接在组件中使用组合式 API 实现功能逻辑</button></li><li class="tab"><button type="button" data-href="#super-2">2. 多个组件复用功能逻辑</button></li><li class="tab"><button type="button" data-href="#super-3">3. 嵌套多个组合式函数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  x.<span class="property">value</span> = event.<span class="property">pageX</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  y.<span class="property">value</span> = event.<span class="property">pageY</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>Mouse position is at: </span><span class="template-variable">&#123;&#123; <span class="name">x</span> &#125;&#125;</span><span class="language-xml">, </span><span class="template-variable">&#123;&#123; <span class="name">y</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>把这个逻辑以一个组合式函数的形式提取到外部文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照惯例，组合式函数名以“use”开头</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 被组合式函数封装和管理的状态</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组合式函数可以随时更改其状态。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    x.<span class="property">value</span> = event.<span class="property">pageX</span></span><br><span class="line">    y.<span class="property">value</span> = event.<span class="property">pageY</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个组合式函数也可以挂靠在所属组件的生命周期上</span></span><br><span class="line">  <span class="comment">// 来启动和卸载副作用</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update))</span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过返回值暴露所管理的状态</span></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是它在组件中使用的方式：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">&#x27;./mouse.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>Mouse position is at: </span><span class="template-variable">&#123;&#123; <span class="name">x</span> &#125;&#125;</span><span class="language-xml">, </span><span class="template-variable">&#123;&#123; <span class="name">y</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>核心逻辑完全一致，只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，也可以在组合式函数中使用所有的组合式 API。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。<br>举例来说，我们可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line">import &#123; onMounted, onUnmounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">function</span> use<span class="constructor">EventListener(<span class="params">target</span>, <span class="params">event</span>, <span class="params">callback</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果你想的话，</span></span><br><span class="line">  <span class="comment">// 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素</span></span><br><span class="line">  on<span class="constructor">Mounted(()</span> =&gt; target.add<span class="constructor">EventListener(<span class="params">event</span>, <span class="params">callback</span>)</span>)</span><br><span class="line">  on<span class="constructor">Unmounted(()</span> =&gt; target.remove<span class="constructor">EventListener(<span class="params">event</span>, <span class="params">callback</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了它，之前的 useMouse() 组合式函数可以被简化为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse.js</span></span><br><span class="line">import &#123; <span class="keyword">ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">import &#123; useEventListener &#125; <span class="keyword">from</span> <span class="string">&#x27;./event&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function">export function <span class="title">useMouse</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="keyword">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="keyword">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEventListener(window, <span class="string">&#x27;mousemove&#x27;</span>, (<span class="keyword">event</span>) =&gt; &#123;</span><br><span class="line">    x.<span class="keyword">value</span> = <span class="keyword">event</span>.pageX</span><br><span class="line">    y.<span class="keyword">value</span> = <span class="keyword">event</span>.pageY</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TIP：每一个调用 useMouse() 的组件实例会创建其独有的 x、y 状态拷贝，因此他们不会互相影响。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>useMouse() 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 传统处理方式</button></li><li class="tab"><button type="button" data-href="#super-2">2. 抽取成一个组合式函数</button></li><li class="tab"><button type="button" data-href="#super-3">3. 如果想让它在每次 URL 变化时都重新请求</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">fetch</span>(<span class="string">&#x27;...&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;error&quot;</span>&gt;</span>Oops! Error encountered: </span><span class="template-variable">&#123;&#123; <span class="name">error.message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Data loaded:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">data</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, error &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件里只需要：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> </span></span><span class="template-variable">&#123; useFetch &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="keyword">from</span> <span class="string">&#x27;./fetch.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> </span></span><span class="template-variable">&#123; data, error &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="title function_">useFetch</span>(<span class="string">&#x27;...&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>useFetch() 接收一个静态的 URL 字符串作为输入，所以它只执行一次请求，然后就完成了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>可以让它同时允许接收 ref 作为参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, isRef, unref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在请求之前重设状态...</span></span><br><span class="line">    data.<span class="property">value</span> = <span class="literal">null</span></span><br><span class="line">    error.<span class="property">value</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// unref() 解包可能为 ref 的值</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="title function_">unref</span>(url))</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(url)) &#123;</span><br><span class="line">    <span class="comment">// 若输入的 URL 是一个 ref，那么启动一个响应式的请求</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(doFetch)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则只请求一次</span></span><br><span class="line">    <span class="comment">// 避免监听器的额外开销</span></span><br><span class="line">    <span class="title function_">doFetch</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, error &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的 useFetch() 现在同时可以接收静态的 URL 字符串和 URL 字符串的 ref。当通过 isRef() 检测到 URL 是一个动态 ref 时，它会使用 watchEffect() 启动一个响应式的 effect。该 effect 会立刻执行一次，并在此过程中将 URL 的 ref 作为依赖进行跟踪。当 URL 的 ref 发生改变时，数据就会被重置，并重新请求。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="通过抽取组合式函数改善代码结构"><a href="#通过抽取组合式函数改善代码结构" class="headerlink" title="通过抽取组合式函数改善代码结构"></a>通过抽取组合式函数改善代码结构</h2><p>抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> </span></span><span class="template-variable">&#123; useFeatureA &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="keyword">from</span> <span class="string">&#x27;./featureA.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> </span></span><span class="template-variable">&#123; useFeatureB &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="keyword">from</span> <span class="string">&#x27;./featureB.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> </span></span><span class="template-variable">&#123; useFeatureC &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="keyword">from</span> <span class="string">&#x27;./featureC.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> </span></span><span class="template-variable">&#123; foo, bar &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="title function_">useFeatureA</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> </span></span><span class="template-variable">&#123; baz &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="title function_">useFeatureB</span>(foo)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> </span></span><span class="template-variable">&#123; qux &#125;</span><span class="language-xml"> = useFeatureC(baz)</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。<br>在选项式 API 中使用组合式函数<br>组合式函数必须在 setup() 中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给 this 及其模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">&#x27;./mouse.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFetch &#125; <span class="keyword">from</span> <span class="string">&#x27;./fetch.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useFetch</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, data, error &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// setup() 暴露的属性可以在通过 `this` 访问到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与其他模式的比较"><a href="#与其他模式的比较" class="headerlink" title="与其他模式的比较"></a>与其他模式的比较</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">和 Mixin 的对比</button></li><li class="tab"><button type="button" data-href="#super-2">和无渲染组件的对比</button></li><li class="tab"><button type="button" data-href="#super-3">和 React Hooks 的对比</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>Vue 2 的用户可能会对 mixins 选项比较熟悉。它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：</p><ol><li>不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。</li><li>命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。</li><li>隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>在组件插槽一章中，我们讨论过了基于作用域插槽的无渲染组件。我们甚至用它实现了一样的鼠标追踪器示例。<br>组合式函数相对于无渲染组件的主要优势</p><blockquote><p>组合式函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。<br>推荐在纯逻辑复用时使用组合式函数<br>在需要同时复用逻辑和视图布局时使用无渲染组件。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>如果你有 React 的开发经验，你可能注意到组合式函数和自定义 React hooks 非常相似。组合式 API 的一部分灵感正来自于 React hooks，Vue 的组合式函数也的确在逻辑组合能力上与 React hooks 相近。然而，Vue 的组合式函数是基于 Vue 细粒度的响应性系统，这和 React hooks 的执行模型有本质上的不同。这一话题在组合式 API 的常见问题中有更细致的讨论。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="逻辑复用" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>key在React和Vue中的作用</title>
    <link href="https://superq314.github.io/posts/e9daea21/"/>
    <id>https://superq314.github.io/posts/e9daea21/</id>
    <published>2022-10-20T09:12:48.000Z</published>
    <updated>2022-10-20T11:18:51.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、虚拟DOM中key的作用：<br>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：<br><img src="/image/key%E5%9C%A8React%E5%92%8CVue%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/1666257319648.png" alt="1666257319648"><br>​ 对比规则：<br>​ (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>​ ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>​ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p><p>​ (2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>​ 创建新的真实DOM，随后渲染到到页面。<br>​</p><p>2、用index作为key或者不声明key的时候（此时默认key的value值为index时）可能会引发的问题：</p><p>​ (1).若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>​ 会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p><p>​ (2).如果结构中还包含输入类的DOM：<br>​ 会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p><p>3、开发中如何选择key?:<br>(1).最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>(2).如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>key的原理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 遍历数组 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表（遍历数组）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click.once</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加一个老刘<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;&#123;<span class="name">p.name</span>&#125;&#125;</span><span class="language-xml">-</span><span class="template-variable">&#123;&#123;<span class="name">p.age</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">persons</span>:[</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王五&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> p=&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">name</span>:<span class="string">&#x27;老刘&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">age</span>:<span class="number">40</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">persons</span>.<span class="title function_">unshift</span>(p)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手动搭建模块化webpack开发环境</title>
    <link href="https://superq314.github.io/posts/62be68dc/"/>
    <id>https://superq314.github.io/posts/62be68dc/</id>
    <published>2022-10-20T03:08:59.000Z</published>
    <updated>2022-10-20T06:55:26.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>新建文件夹：<code>mkdir react-webpack</code></p><p>打开文件夹：<code>cd react-webpack</code></p><h2 id="快速初始化项目"><a href="#快速初始化项目" class="headerlink" title="快速初始化项目"></a>快速初始化项目</h2><p><code>npm init -y</code></p><p>文件夹中自动生成 package.json 文件</p><h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><p><code>dist</code>：webpack打包生成的文件于此</p><p><code>src</code>：于此进行开发</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426195640829-110551594.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426195640829-110551594.png"></a></p><h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><p><strong>命令集合</strong></p><p>打包工具：<code>npm i webpack webpack-cli -D</code></p><p>实时编译：<code>npm i webpack-dev-server -D</code></p><p>插 件：<code>npm i html-webpack-plugin -D</code></p><h3 id="🌸打包工具"><a href="#🌸打包工具" class="headerlink" title="🌸打包工具"></a>🌸打包工具</h3><p>命令：<code>npm i webpack webpack-cli -D</code></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>1.webpack.config.js</strong></p><p>设置打包模式：<code>mode: &#39;development&#39;, //必选：development  production</code></p><p><code>mode</code>必须设置。<code>development</code>表明以开发模式进行打包，<code>production</code>用于产品上线的时候打包，可以自己测试下打包结果的区别。</p><p>webpack配置中的一些基本概念建议看下官网<a href="https://www.webpackjs.com/concepts/">webpack官方中文文档</a></p><p><code>webpack4.x</code>中的 <code>entry</code>、<code>output</code>属性可省略（默认入口：<code>src/index.js</code>，默认出口：<code>dist/main.js</code>）</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426202528411-778250179.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426202528411-778250179.png"></a></p><p><strong>2.package.json添加build</strong></p><p><code>&quot;build&quot;: &quot;webpack&quot;,</code></p><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426203443158-1571004375.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426203443158-1571004375.png"></a></p><h4 id="执行打包命令"><a href="#执行打包命令" class="headerlink" title="执行打包命令"></a>执行打包命令</h4><p>经过上面的配置，我们现在可以使用命令 <code>npm run build</code>进行打包，默认入口为 <code>src/index.js</code>。此时 <code>dist</code>文件夹中生成 <code>main.js</code>（默认出口）</p><h3 id="🌸实时编译"><a href="#🌸实时编译" class="headerlink" title="🌸实时编译"></a>🌸实时编译</h3><p>命令：<code>npm i -D webpack-dev-server</code></p><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>1.package.json添加dev</strong></p><p><code>&quot;dev&quot;:&quot;webpack-dev-server --port 8081 --hot --host 127.0.0.1&quot;</code></p><p>这里建议手打一遍，不要直接复制。我从onenote中复制自己存的这行代码到vscode中居然报错了，找了半天原因，结果自己手打一遍就好了</p><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426210617855-446782502.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426210617855-446782502.png"></a></p><p><code>--open</code>：执行命令后打开浏览器。–open iexplore表示打开IE浏览器<br><code>--port 8081</code>：端口8081<br><code>--hot</code>：实现版本大补丁而非重写文件。实现网页无刷新就能执行index.js中更改的代码<br><code>--host</code>：ip地址。默认为localhost<br><code>--contentBase src</code>：指定托管的根目录为src文件夹</p><h4 id="执行实时编译命令"><a href="#执行实时编译命令" class="headerlink" title="执行实时编译命令"></a>执行实时编译命令</h4><p>经过上面的配置，我们现在可以使用命令 <code>npm run dev</code> 进行实时预编译，打包好的main.js托管于内存中，而非根目录中。</p><h4 id="内存托管解释"><a href="#内存托管解释" class="headerlink" title="内存托管解释"></a>内存托管解释</h4><p>假设打包好的main.js放于根目录了，程序员有个随时保存的习惯，如果经常保存的话就会容易损害物理（机械）磁盘。内存比机械磁盘更快，处于性能考虑，将打包好的main.js文件放于内存中，将html放于物理磁盘中。</p><h3 id="🌸webpack-plugin插件"><a href="#🌸webpack-plugin插件" class="headerlink" title="🌸webpack-plugin插件"></a>🌸webpack-plugin插件</h3><p>命令：<code>npm i html-webpack-plugin -D</code></p><h4 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h4><p><a href="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426213946784-416697885.png"><img src="https://img2020.cnblogs.com/blog/1019981/202004/1019981-20200426213946784-416697885.png" alt="img"></a></p><p>此时index.html和main.js都处于内存中，且webpack-plugin会自动将main.js添加到html中。因此此时，index.html中不用写 这句话了</p><p><del><code>&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</code></del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue族谱架构</title>
    <link href="https://superq314.github.io/posts/a97a1a46/"/>
    <id>https://superq314.github.io/posts/a97a1a46/</id>
    <published>2022-10-17T09:55:40.000Z</published>
    <updated>2022-10-24T07:38:50.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>静态网站：html 放到服务器，ok了。</li><li>动态网站: 静态网站 + 动态语言 + 链接数据库</li><li>Node.js</li></ul><blockquote><p>nodejs中文网: <a href="http://nodejs.cn/">http://nodejs.cn/</a><br>官方介绍：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。</p></blockquote><ul><li>WebPack</li></ul><blockquote><p>WebPack官网：<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a><br>官方介绍：打包所有的样式 脚本 资源 图片</p></blockquote><ul><li>@vue&#x2F;cli-service</li></ul><blockquote><p>脚手架</p></blockquote><ul><li>Babel</li></ul><blockquote><p>Babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a><br>官方介绍：Babel 是一个 JavaScript 编译器。</p></blockquote><ul><li>Eslint</li></ul><blockquote><p>Eslint官网：<a href="https://eslint.org/">https://eslint.org/</a><br>官方介绍：Find and fix problems in your JavaScript code</p></blockquote><p>前台核心基本功</p><ul><li>ES6</li></ul><blockquote><p>ES6官网：<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br>官方介绍：《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。</p></blockquote><ul><li>VUE 2.x</li></ul><blockquote><p>Vue官网：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a><br>官方介绍：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><ul><li>vue-router</li></ul><blockquote><p>vue-router官网：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a><br>官方介绍：Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote><ul><li>vuex</li></ul><blockquote><p>vuex官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a><br>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><ul><li>Axios</li></ul><blockquote><p>个人介绍：当年的Ajax，如今的Axios</p></blockquote><ul><li>LESS</li></ul><blockquote><p>LESS中文官网：<a href="http://lesscss.cn/">http://lesscss.cn/</a><br>官方介绍：Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。</p></blockquote><ul><li>VIEW-Design</li></ul><blockquote><p>VIEW-Design官网：<a href="https://www.iviewui.com/">https://www.iviewui.com/</a><br>官方介绍：View UI，即原先的 iView，是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。</p></blockquote><p>一般常用拓展库</p><ul><li>Echarts</li></ul><blockquote><p>Echarts官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a><br>官方介绍：ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p></blockquote><ul><li>VueTreeSelect</li></ul><blockquote><p>VueTreeSelect官网：<a href="https://vue-treeselect.js.org/">https://vue-treeselect.js.org/</a><br>官方介绍：vue-treeselect is a multi-select component with nested options support for Vue.js.</p></blockquote><ul><li>print-js</li></ul><blockquote><p>print-js官网：<a href="https://printjs.crabbly.com/">https://printjs.crabbly.com/</a><br>官方介绍：A tiny javascript library to help printing from the web.</p></blockquote><ul><li>js-cookie</li></ul><blockquote><p>js-cookie官网：<a href="https://github.com/js-cookie/js-cookie">https://github.com/js-cookie/js-cookie</a><br>官方介绍：A simple, lightweight JavaScript API for handling cookies</p></blockquote><ul><li>lodash</li></ul><blockquote><p>lodash官网：<a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a><br>官方介绍：Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。</p></blockquote><ul><li>Mockjs</li></ul><blockquote><p>Mockjs官网：<a href="http://mockjs.com/">http://mockjs.com/</a><br>官方介绍：生成随机数据，拦截 Ajax 请求</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>将excel文件转为本地json文件的插件</title>
    <link href="https://superq314.github.io/posts/93bc55ab/"/>
    <id>https://superq314.github.io/posts/93bc55ab/</id>
    <published>2022-10-17T02:56:29.000Z</published>
    <updated>2022-10-17T04:17:55.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>excel-2b-json插件用于将google excel文件转化成本地json文件。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-安装excel-2b-json"><a href="#1-安装excel-2b-json" class="headerlink" title="1. 安装excel-2b-json"></a>1. 安装excel-2b-json</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install excel-2b-json</span><br></pre></td></tr></table></figure><h3 id="2-引入使用"><a href="#2-引入使用" class="headerlink" title="2. 引入使用"></a>2. 引入使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> excelToJson = <span class="built_in">require</span>(<span class="string">&#x27;excel-2b-json&#x27;</span>);</span><br><span class="line"><span class="comment">// path 生成的json文件目录</span></span><br><span class="line"><span class="title function_">excelToJson</span>(<span class="string">&#x27;https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0&#x27;</span>, path)</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-fd3aff58b3f9b44d6160c9f0d4ef4f5f_720w.webp"><br>转化得到<br><img src="https://pic2.zhimg.com/80/v2-ab6e90fb06caec7d652f3a95fbba8fe9_720w.webp"></p><p>下面是插件的实现</p><blockquote><p>源码已放到github：<a href="https://link.zhihu.com/?target=https://github.com/Sunny-lucking/HowToBuildMyExcelTobeJson">https://github.com/Sunny-lucking/HowToBuildMyExcelTobeJson</a></p></blockquote><h2 id="一、涉及的算法"><a href="#一、涉及的算法" class="headerlink" title="一、涉及的算法"></a>一、涉及的算法</h2><h3 id="1-26字母转换成数字，26进制，a为1，aa为27，ab为28"><a href="#1-26字母转换成数字，26进制，a为1，aa为27，ab为28" class="headerlink" title="1. 26字母转换成数字，26进制，a为1，aa为27，ab为28"></a>1. 26字母转换成数字，26进制，a为1，aa为27，ab为28</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">colToInt</span>(<span class="params">col</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> letters = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line">    col = col.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; col.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        n *= <span class="number">26</span></span><br><span class="line">        n += letters.<span class="title function_">indexOf</span>(col[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-生成几行几列的二维空数组"><a href="#2-生成几行几列的二维空数组" class="headerlink" title="2. 生成几行几列的二维空数组"></a>2. 生成几行几列的二维空数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEmpty2DArr</span>(<span class="params">rows, cols</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrs = <span class="keyword">new</span> <span class="title class_">Array</span>(rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        arrs[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(cols).<span class="title function_">fill</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">//每行有cols列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-清除二维数组中空的数组"><a href="#3-清除二维数组中空的数组" class="headerlink" title="3. 清除二维数组中空的数组"></a>3. 清除二维数组中空的数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">转化为</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title function_">clearEmptyArrItem</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">val1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) !== <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-矩阵的翻转"><a href="#4-矩阵的翻转" class="headerlink" title="4. 矩阵的翻转"></a>4. 矩阵的翻转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">转化为</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array*2</span>&#125; matrix 一个二维数组，返回旋转后的二维数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">rotateExcelDate</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix[<span class="number">0</span>]) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">var</span> results = [],</span><br><span class="line">        result = [],</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        lens,</span><br><span class="line">        len</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, lens = matrix[<span class="number">0</span>].<span class="property">length</span>; i &lt; lens; i++) &#123;</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, len = matrix.<span class="property">length</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[j] = matrix[j][i]</span><br><span class="line">        &#125;</span><br><span class="line">        results.<span class="title function_">push</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、插件的实现"><a href="#二、插件的实现" class="headerlink" title="二、插件的实现"></a>二、插件的实现</h2><h3 id="1-下载google-Excel文档到本地"><a href="#1-下载google-Excel文档到本地" class="headerlink" title="1. 下载google Excel文档到本地"></a>1. 下载google Excel文档到本地</h3><p>我们先看看google Excel文档的url的组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/文档ID/edit#哈希值</span></span><br></pre></td></tr></table></figure><p>例如下面这条，你可以尝试打开，下面这条链接是可以打开的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0</span></span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-df4c89880f1bbf9efcce79ab6eb9d3c5_720w.webp"></p><p>下载google文档的步骤非常简单，只要获取原始的链接，然后拼接成下面的url，向这个Url发起请求，然后以流的方式写入生成文件就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docs.google.com/spreadsheets/d/ + &quot;文档ID&quot; + &#x27;/export?format=xlsx&amp;id=&#x27; + id + &#x27;&amp;&#x27; + hash</span></span><br></pre></td></tr></table></figure><p>因此实现下载的方法非常简单，可以直接看代码<br><strong>downLoadExcel.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> rmobj = <span class="built_in">require</span>(<span class="string">&#x27;./remove&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载google excel 文档到本地</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; url  // https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/edit#gid=0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">downLoadExcel</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 记录当前下载文件的目录，方便删除</span></span><br><span class="line">    rmobj.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: __dirname,</span><br><span class="line">        <span class="attr">ext</span>: <span class="string">&#x27;xlsx&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> down1 = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> down2 = down1.<span class="title function_">pop</span>() <span class="comment">// edit#gid=0</span></span><br><span class="line">        <span class="keyword">var</span> url2 = down1.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>) <span class="comment">// https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM</span></span><br><span class="line">        <span class="keyword">var</span> id = down1.<span class="title function_">pop</span>() <span class="comment">// 12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM</span></span><br><span class="line">        <span class="keyword">var</span> hash = down2.<span class="title function_">split</span>(<span class="string">&#x27;#&#x27;</span>).<span class="title function_">pop</span>() <span class="comment">// gid=0</span></span><br><span class="line">        <span class="keyword">var</span> downurl = url2 + <span class="string">&#x27;/export?format=xlsx&amp;id=&#x27;</span> + id + <span class="string">&#x27;&amp;&#x27;</span> + hash  <span class="comment">// https://docs.google.com/spreadsheets/d/12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM/export?format=xlsx&amp;id=12q3leiNxdmI_ZLWFj4LP_EA5PeJpLF18vViuyiSOuvM&amp;gid=0</span></span><br><span class="line">        <span class="keyword">var</span> loadedpath = __dirname + <span class="string">&#x27;/&#x27;</span> + id + <span class="string">&#x27;.xlsx&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> stream = fs.<span class="title function_">createWriteStream</span>(loadedpath)</span><br><span class="line">        <span class="keyword">const</span> req = request.<span class="title function_">get</span>(downurl)</span><br><span class="line">        req.<span class="title function_">pipe</span>(stream).<span class="title function_">on</span>(<span class="string">&#x27;finish&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(loadedpath)</span><br><span class="line">        <span class="comment">// 已经成功下载下来了，接下来将本地excel转化成json的工作就交给Excel对象来完成</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = downLoadExcel</span><br></pre></td></tr></table></figure><p>入口文件可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">excelToJson</span>(<span class="params">excelPathName, outputPath</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Util</span>.<span class="title function_">checkAddress</span>(excelPathName) === <span class="string">&#x27;google&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.判断是谷歌excel文档，需要交给Google对象去处理，主要是下载线上的，生成本地excel文件</span></span><br><span class="line">        <span class="keyword">const</span> filePath = <span class="keyword">await</span> <span class="title function_">downLoadExcel</span>(excelPathName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.解析本地excel成二维数组</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">parseXlsx</span>(filePath)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 3.生成json文件</span></span><br><span class="line">        <span class="title function_">generateJsonFile</span>(data, outputPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = excelToJson</span><br></pre></td></tr></table></figure><p>之所以写if判断，是为了后面扩展，也许就不止是解析google文档了，或许也要解析腾讯等其他文档呢</p><p>第一步已经实现了，接下来就看第二步怎么实现</p><h3 id="2-解析本地excel成二维数组，获取excel的sheet信息和strings信息"><a href="#2-解析本地excel成二维数组，获取excel的sheet信息和strings信息" class="headerlink" title="2. 解析本地excel成二维数组，获取excel的sheet信息和strings信息"></a>2. 解析本地excel成二维数组，获取excel的sheet信息和strings信息</h3><p>excel 文件其实本质上是多份xml文件的压缩文件。</p><blockquote><p>xml是存储数据的，而html是显示数据的</p></blockquote><p>而在这里我们只需要获取两份xml 文件，一份是strings，就是excel里的内容，一份是sheet，概括整个excel文件的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">parseXlsx</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 解析本地excel文件，获取excel的sheet信息和content信息</span></span><br><span class="line">    <span class="keyword">const</span> files = <span class="keyword">await</span> <span class="title function_">extractFiles</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据strings和sheet解析成二维数组</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">extractData</span>(files)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 处理二维数组的内容，</span></span><br><span class="line">    <span class="keyword">const</span> fixData = <span class="title function_">handleData</span>(data)</span><br><span class="line">    <span class="keyword">return</span> fixData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以第一步我们看看怎么获取excel的sheet信息和strings信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractFiles</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="comment">// excel的本质是多份xml组成的压缩文件，这里我们只需要xl/sharedStrings.xml和xl/worksheets/sheet1.xml</span></span><br><span class="line">    <span class="keyword">const</span> files = &#123;</span><br><span class="line">        <span class="attr">strings</span>: &#123;&#125;, <span class="comment">// strings内容</span></span><br><span class="line">        <span class="attr">sheet</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&#x27;xl/sharedStrings.xml&#x27;</span>: <span class="string">&#x27;strings&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xl/worksheets/sheet1.xml&#x27;</span>: <span class="string">&#x27;sheet&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stream = path <span class="keyword">instanceof</span> <span class="title class_">Stream</span> ? path : fs.<span class="title function_">createReadStream</span>(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> filePromises = [] <span class="comment">// 由于一份excel文档，会被解析成好多分xml文档，但是我们只需要两份xml文档，分别是（xl/sharedStrings.xml和xl/worksheets/sheet1.xml），所以用数组接受</span></span><br><span class="line">        stream.<span class="title function_">pipe</span>(unzip.<span class="title class_">Parse</span>())</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, reject)</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(filePromises).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(files)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).<span class="title function_">on</span>(<span class="string">&#x27;entry&#x27;</span>, <span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 每解析某个xml文件都会进来这里，但是我们只需要xl/sharedStrings.xml和xl/worksheets/sheet1.xml，并将内容保存在strings和sheet中</span></span><br><span class="line">            <span class="keyword">const</span> file = files[entry.<span class="property">path</span>]</span><br><span class="line">            <span class="keyword">if</span> (file) &#123;</span><br><span class="line">                <span class="keyword">let</span> contents = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">let</span> chunks = []</span><br><span class="line">                <span class="keyword">let</span> totalLength = <span class="number">0</span></span><br><span class="line">                filePromises.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                    entry.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">                        chunks.<span class="title function_">push</span>(chunk)</span><br><span class="line">                        totalLength += chunk.<span class="property">length</span></span><br><span class="line">                    &#125;).<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        contents = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks, totalLength).<span class="title function_">toString</span>()</span><br><span class="line">                        files[file].<span class="property">contents</span> = contents</span><br><span class="line">                        <span class="keyword">if</span> (<span class="regexp">/�/g</span>.<span class="title function_">test</span>(contents)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;本次转化出现乱码�&#x27;</span>)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="title function_">resolve</span>()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                entry.<span class="title function_">autodrain</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以断点看看entry.path，你就会看到分别进来了好几次，然后我们会分别看到我们想要的那两个文件</p><p><img src="https://pic2.zhimg.com/80/v2-c5a24f7ea29e7b0c3de3de4ecf1a13dd_720w.webp"></p><p>两份xml文件解析之后就会到close方法里了，这时就可以看到strings和sheet都有内容了，而且内容都是xml</p><p><img src="https://pic2.zhimg.com/80/v2-df174239b78c1855b30fd831afa0cb29_720w.webp"></p><p>我们分别看看strings和sheet的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream.<span class="title function_">pipe</span>(unzip.<span class="title class_">Parse</span>())</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, reject)</span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>(filePromises).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(files.<span class="property">strings</span>.<span class="property">contents</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(files.<span class="property">sheet</span>.<span class="property">contents</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(files)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-f9cf1e973ac326808ef302a15d4e5aa1_720w.webp"></p><p>格式化一下</p><p><strong>strings</strong></p><p><img src="https://pic2.zhimg.com/80/v2-92d46307423131de25104058ed95571d_720w.webp"></p><p><strong>sheet</strong></p><p><img src="https://pic2.zhimg.com/80/v2-aef401e7709cbb2cb8a03279ecfdd3d1_720w.webp"></p><p>可以发现strings的内容非常简单，现在我们借助xmldom将内容解析为节点对象，然后用xpath插件来获取内容</p><p>xpath的用法：<a href="https://link.zhihu.com/?target=https://github.com/goto100/xpath%23readme">https:&#x2F;&#x2F;<strong>github.com&#x2F;goto100&#x2F;xpat</strong>h#readme</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">XMLDOM</span> = <span class="built_in">require</span>(<span class="string">&#x27;xmldom&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> xpath = <span class="built_in">require</span>(<span class="string">&#x27;xpath&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ns = &#123; <span class="attr">a</span>: <span class="string">&#x27;http://schemas.openxmlformats.org/spreadsheetml/2006/main&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> select = xpath.<span class="title function_">useNamespaces</span>(ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> valuesDoc = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(</span><br><span class="line">    files.<span class="property">strings</span>.<span class="property">contents</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有每个格子的内容都放进了values数组里。</span></span><br><span class="line">values = <span class="title function_">select</span>(<span class="string">&#x27;//a:si&#x27;</span>, valuesDoc).<span class="title function_">map</span>(<span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="title function_">select</span>(<span class="string">&#x27;.//a:t&#x27;</span>, string).<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">textContent</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>‘<code>//a:si</code>‘ 是xpath语法，&#x2F;&#x2F;表示选择当前节点下的所有子孙节点，a是<a href="https://link.zhihu.com/?target=http://schemas.openxmlformats.org/spreadsheetml/2006/main">http:&#x2F;&#x2F;<strong>schemas.openxmlformats.org</strong>&#x2F;spreadsheetml&#x2F;2006&#x2F;main</a>的命名空间。所以合起来就是找到当前节点下的所有si节点。<code>.//a:t</code>则是找到当前si节点下的所有t节点。</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-b50f77d4c392f606921c961f1ffffb6d_720w.webp"></p><p>可以看到，xpath的用法很简单，就是找到si节点下的子节点t的内容，然后放进数组里</p><p><img src="https://pic4.zhimg.com/80/v2-c9d54ab8f6d2c33225ed89efbec59287_720w.webp"></p><p>最终生成的values数组是 <code>[ &#39;lang&#39;, &#39;cn&#39;,&#39;en&#39;, &#39;lang001&#39;,&#39;我是阳光&#39;, &#39;i am sunny&#39;,&#39;lang002&#39;, &#39;前端阳光&#39;,&#39;FE Sunny&#39;, &#39;lang003&#39;,&#39;带带我&#39;, &#39;ddw&#39;]</code></p><p>现在我们要获取sheet的内容了，我们先分析一下xml结构</p><p><img src="https://pic4.zhimg.com/80/v2-f33366ece0d6989efb5c94e5930af507_720w.webp"></p><p>可以看到sheetData节点其实就是记录strings的内容的信息的，strings的内容是我们真正输入的，而sheet则是类似一种批注。</p><p>我们分析看看</p><p>row就是表示表格中的行，c则表示的是列，属性t&#x3D;”s”表示的是当前这个格子有内容，r&#x3D;”A1”表示的是在第一行中的A列</p><p><img src="https://pic3.zhimg.com/80/v2-1059e798cded4a9a5c3c207ab98c9232_720w.webp"></p><p>而节点v则表示该格子是该表格的第几个有值的格子，不信？我们可以试试看</p><p><img src="https://pic4.zhimg.com/80/v2-5af242307963fe82dbd0c10b7a0fa45f_720w.webp"></p><p><img src="https://pic2.zhimg.com/80/v2-1ec56afec3a9d20b5b8a1e6e0df09e61_720w.webp"></p><p>可以看到这打印出来的xml内容，strings中已经没有了那两个值，而sheet中的那两个格子的c节点的t属性没了，而且v节点也没有了。</p><p><strong>现在我们可以知道，string只保存有值的格子里的值，而sheet则是一个网格，不管格子有没有值都会记录，有值的会有个序号存在v节点中。</strong></p><p>现在就要收集c节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> na = &#123;</span><br><span class="line">    <span class="attr">textContent</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellCoords</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">cell</span>) &#123;</span><br><span class="line">        cell = cell.<span class="title function_">split</span>(<span class="regexp">/([0-9]+)/</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">row</span> = <span class="built_in">parseInt</span>(cell[<span class="number">1</span>])</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">column</span> = <span class="title function_">colToInt</span>(cell[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">cellNode</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> r = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">       <span class="keyword">const</span> type = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;t&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">       <span class="keyword">const</span> value = (<span class="title function_">select</span>(<span class="string">&#x27;a:v&#x27;</span>, cellNode, <span class="number">1</span>) || na).<span class="property">textContent</span></span><br><span class="line">       <span class="keyword">const</span> coords = <span class="keyword">new</span> <span class="title class_">CellCoords</span>(r)</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">column</span> = coords.<span class="property">column</span> <span class="comment">// 该格子所在列数</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">row</span> = coords.<span class="property">row</span> <span class="comment">// 该格子所在行数</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">value</span> = value <span class="comment">// 该格子的顺序</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">type</span> = type <span class="comment">// 该格子是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cells = <span class="title function_">select</span>(<span class="string">&#x27;/a:worksheet/a:sheetData/a:row/a:c&#x27;</span>, sheet).<span class="title function_">map</span>(</span><br><span class="line">    <span class="function"><span class="params">node</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(node)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>每个c节点用cell对象来表示</p><p>可以看到cell节点有四个属性。</p><p><strong>你现在知道它为什么要保存顺序了吗？</strong></p><p>因为这样才可以直接从strings生成的values数组中拿出对应顺序的值填充到网格中。</p><p>接下来要获取总共有多少列数和行数。这就需要获取最大最小行数列数，然后求差得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDimensions</span>(<span class="params">cells</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">comparator</span> = (<span class="params">a, b</span>) =&gt; a - b</span><br><span class="line">   <span class="keyword">const</span> allRows = cells.<span class="title function_">map</span>(<span class="function"><span class="params">cell</span> =&gt;</span> cell.<span class="property">row</span>).<span class="title function_">sort</span>(comparator)</span><br><span class="line">   <span class="keyword">const</span> allCols = cells.<span class="title function_">map</span>(<span class="function"><span class="params">cell</span> =&gt;</span> cell.<span class="property">column</span>).<span class="title function_">sort</span>(comparator)</span><br><span class="line">   <span class="keyword">const</span> minRow = allRows[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">const</span> maxRow = allRows[allRows.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">   <span class="keyword">const</span> minCol = allCols[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">const</span> maxCol = allCols[allCols.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> [&#123; <span class="attr">row</span>: minRow, <span class="attr">column</span>: minCol &#125;, &#123; <span class="attr">row</span>: maxRow, <span class="attr">column</span>: maxCol &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就根据列数和行数造空二维数组，然后再根据cells和values填充内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成二维空数组</span></span><br><span class="line">data = <span class="title function_">getEmpty2DArr</span>(rows, cols)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充二维空数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cell <span class="keyword">of</span> cells) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = cell.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// s表示该格子有内容</span></span><br><span class="line">    <span class="keyword">if</span> (cell.<span class="property">type</span> == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">        value = values[<span class="built_in">parseInt</span>(value)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充该格子</span></span><br><span class="line">    <span class="keyword">if</span> (data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>]) &#123;</span><br><span class="line">        data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>][cell.<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span>] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>我们看看最终生成的data，可以发现，excel的网格已经被二维数组模拟出来了</p><p><img src="https://pic2.zhimg.com/80/v2-15b4d6409f81c87fa05d62ab9d7e0f91_720w.webp"></p><p>所以我们看看extractData的完整实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractData</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sheet</span><br><span class="line">    <span class="keyword">let</span> values</span><br><span class="line">    <span class="keyword">let</span> data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sheet = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(files.<span class="property">sheet</span>.<span class="property">contents</span>)</span><br><span class="line">        <span class="keyword">const</span> valuesDoc = <span class="keyword">new</span> <span class="variable constant_">XMLDOM</span>.<span class="title class_">DOMParser</span>().<span class="title function_">parseFromString</span>(files.<span class="property">strings</span>.<span class="property">contents</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把所有每个格子的内容都放进了values数组里。</span></span><br><span class="line">        values = <span class="title function_">select</span>(<span class="string">&#x27;//a:si&#x27;</span>, valuesDoc).<span class="title function_">map</span>(<span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">            <span class="title function_">select</span>(<span class="string">&#x27;.//a:t&#x27;</span>, string)</span><br><span class="line">            .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">textContent</span>)</span><br><span class="line">            .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (parseError) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> na = &#123;</span><br><span class="line">        <span class="attr">textContent</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CellCoords</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">cell</span>) &#123;</span><br><span class="line">            cell = cell.<span class="title function_">split</span>(<span class="regexp">/([0-9]+)/</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">row</span> = <span class="built_in">parseInt</span>(cell[<span class="number">1</span>])</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">column</span> = <span class="title function_">colToInt</span>(cell[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">cellNode</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> r = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> type = cellNode.<span class="title function_">getAttribute</span>(<span class="string">&#x27;t&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> value = (<span class="title function_">select</span>(<span class="string">&#x27;a:v&#x27;</span>, cellNode, <span class="number">1</span>) || na).<span class="property">textContent</span></span><br><span class="line">        <span class="keyword">const</span> coords = <span class="keyword">new</span> <span class="title class_">CellCoords</span>(r)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">column</span> = coords.<span class="property">column</span> <span class="comment">// 该格子所在列数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">row</span> = coords.<span class="property">row</span> <span class="comment">// 该格子所在行数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value <span class="comment">// 该格子的顺序</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = type <span class="comment">// 该格子是否为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cells = <span class="title function_">select</span>(<span class="string">&#x27;/a:worksheet/a:sheetData/a:row/a:c&#x27;</span>, sheet).<span class="title function_">map</span>(</span><br><span class="line">        <span class="function"><span class="params">node</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(node)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算该表格的最大最小列数行数</span></span><br><span class="line">    d = <span class="title function_">calculateDimensions</span>(cells)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cols = d[<span class="number">1</span>].<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> rows = d[<span class="number">1</span>].<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成二维空数组</span></span><br><span class="line">    data = <span class="title function_">getEmpty2DArr</span>(rows, cols)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充二维空数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> cell <span class="keyword">of</span> cells) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = cell.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s表示该格子有内容</span></span><br><span class="line">        <span class="keyword">if</span> (cell.<span class="property">type</span> == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">        value = values[<span class="built_in">parseInt</span>(value)]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充该格子</span></span><br><span class="line">        <span class="keyword">if</span> (data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>]) &#123;</span><br><span class="line">        data[cell.<span class="property">row</span> - d[<span class="number">0</span>].<span class="property">row</span>][cell.<span class="property">column</span> - d[<span class="number">0</span>].<span class="property">column</span>] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要去除空行和空列，并将二维数组翻转成我们需要的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        data = <span class="title function_">clearEmptyArrItem</span>(data)</span><br><span class="line">        data = <span class="title function_">rotateExcelDate</span>(data)</span><br><span class="line">        data = <span class="title function_">clearEmptyArrItem</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-58f5ce9df016541ef038537c7c2003b2_720w.webp"></p><p>可以看到，现在数组的第一项子数组则是key列表了。</p><p>接下来就可以根据key来生成对应的json文件了。</p><h3 id="3-生成json数据"><a href="#3-生成json数据" class="headerlink" title="3. 生成json数据"></a>3. 生成json数据</h3><p>这一步非常简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateJsonFile</span>(<span class="params">excelDatas, outputPath</span>) &#123;</span><br><span class="line">    <span class="comment">// 获得转化成json格式</span></span><br><span class="line">    <span class="keyword">const</span> jsons = <span class="title function_">convertProcess</span>(excelDatas)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成写入文件</span></span><br><span class="line">    <span class="title function_">writeFile</span>(jsons, outputPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是获取json数据</p><p>先获取data数组的第一项数组，第一项数组是key，然后生成每种语言的json对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array*2</span>&#125; <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> * 返回处理完后的多语言数组，每一项都是一个json对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convertProcess</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys_arr = [],</span><br><span class="line">        data_arr = [],</span><br><span class="line">        result_arr = [],</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        data_arr_len,</span><br><span class="line">        col_data_json,</span><br><span class="line">        col_data_arr,</span><br><span class="line">        data_arr_col_len</span><br><span class="line">    <span class="comment">// 表格合并处理，这是json属性列。</span></span><br><span class="line">    keys_arr = data[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 第一例是json描述，后续是语言包</span></span><br><span class="line">    data_arr = data.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, data_arr_len = data_arr.<span class="property">length</span>; i &lt; data_arr_len; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出第一个列语言包</span></span><br><span class="line">        col_data_arr = data_arr[i]</span><br><span class="line">        <span class="comment">// 该列对应的临时对象</span></span><br><span class="line">        col_data_json = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, data_arr_col_len = col_data_arr.<span class="property">length</span>; j &lt; data_arr_col_len; j++) &#123;</span><br><span class="line">            col_data_json[keys_arr[j]] = col_data_arr[j]</span><br><span class="line">        &#125;</span><br><span class="line">        result_arr.<span class="title function_">push</span>(col_data_json)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result_arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看看生成的result_arr<br><img src="https://pic3.zhimg.com/80/v2-7a9dcdeb07b4d88976836de7323c7b12_720w.webp"></p><p>可见已经成功生成每一种语言的json对象了。<br>接下来只需要生成json文件就可以了，注意把之前生成的excel文件删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到的数据写入文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeFile</span>(<span class="params">datas, outputPath</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = datas.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(outputPath + (datas[i].<span class="property">filename</span> || datas[i].<span class="property">lang</span>) + <span class="string">&#x27;.json&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(datas[i], <span class="literal">null</span>, <span class="number">4</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    rmobj.<span class="title function_">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>移动端多端适配（flexiblejs）</title>
    <link href="https://superq314.github.io/posts/740ab8bd/"/>
    <id>https://superq314.github.io/posts/740ab8bd/</id>
    <published>2022-10-17T02:35:41.000Z</published>
    <updated>2022-10-17T04:17:55.842Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p><strong>flexible.js帮我们计算出1rem 等于多少px</strong> 。</p><p><strong>计算方式</strong></p><blockquote><p>很简单，就是1rem &#x3D; 屏幕宽度width &#x2F; 10</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>  <span class="comment">// 返回文档的root元素,即html</span></span><br><span class="line"><span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span></span><br><span class="line">docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure><p>rem的大小是根据html节点的font-size的相对值<br>例如，iphone 6的屏幕宽度为375px，因此1rem &#x3D;&#x3D;&#x3D; 37.5px。</p><h2 id="计算rem的作用"><a href="#计算rem的作用" class="headerlink" title="计算rem的作用"></a>计算rem的作用</h2><p>发挥它的用处是当我们根据设计稿来转化成页面时需要用到。</p><p>举个例子，现在有两个手机，一个手机的屏幕宽度是375px，一个是750px，设计稿给我们的宽度是375px，那我们按照设计稿的设计在375px的手机上刚好完美匹配，但是却会发现在750px的手机上页面只有一半，空白了一半。</p><p>这就是我们需要解决的问题，即怎么解决移动端尺寸众多的问题，我们的设计稿是固定，怎么办，如果设计稿是弹性的可以随意缩放该多好。</p><p>好吧，设计只给一张设计稿，我们只能想其他方法啦。</p><h2 id="等比例放缩"><a href="#等比例放缩" class="headerlink" title="等比例放缩"></a>等比例放缩</h2><p>现在我们把设计稿分成10等份，设计稿 A &#x3D; W&#x2F;10，我们把设备可视区域也就是我们的各种移动端设备的这个画布也分成10份，并赋值给根元素的fontSize，我们都知道rem是根据根元素字体大小计算的，所以我们的1rem也就是设备可视区域&#x2F;10，现在设计稿上有一块区域宽B，那它是不是等比放到设备可视区域的宽度为 B&#x2F;A rem。</p><p>再啰嗦一下，B在设计稿上占B&#x2F;A份，那在设备可视区域上也要占B&#x2F;A份对不对，所以宽是B&#x2F;A rem。这就是flexible.js能实现设备兼容的原理。下面看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个立即执行函数，执行时传入的参数是window和document</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">flexible</span> (<span class="variable language_">window</span>, <span class="variable language_">document</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>  <span class="comment">// 返回文档的root元素</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span> <span class="comment">// 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// adjust body font size 设置默认字体大小，默认的字体大小继承自body</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setBodyFontSize</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = (<span class="number">12</span> * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setBodyFontSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setRemUnit</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span></span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setRemUnit</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset rem unit on page resize</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">      <span class="title function_">setRemUnit</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// detect 0.5px supports  检测是否支持0.5像素，解决1px在高清屏多像素问题，需要css的配合。</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    testElement.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">    fakeBody.<span class="title function_">appendChild</span>(testElement)</span><br><span class="line">    docEl.<span class="title function_">appendChild</span>(fakeBody)</span><br><span class="line">    <span class="keyword">if</span> (testElement.<span class="property">offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.<span class="title function_">removeChild</span>(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">window</span>, <span class="variable language_">document</span>))</span><br></pre></td></tr></table></figure><p>这就是flexible.js的源码，超级简单吧。</p><p><img src="https://pic1.zhimg.com/80/v2-98391a7a7033a03304afe78b500ebb90_720w.webp"><br><img src="https://pic2.zhimg.com/80/v2-6f4de7f8b828b1d56e0b3cd6312f51f1_720w.webp"></p><p>现在已经实现了将屏幕分为10等份，也就是1rem。</p><h2 id="将设计稿分成10等份"><a href="#将设计稿分成10等份" class="headerlink" title="将设计稿分成10等份"></a>将设计稿分成10等份</h2><p>根据我们上面画饼的方案，现在也要把设计稿转化为10等分才行。</p><p>我看了下我们项目的实现是用到了<code>postcss-pxtorem</code>插件来实现的</p><p>因为设计稿给我们的是px单位的，所以我们在开发的时候只能写px，然后这就需要postcss-pxtorem来帮我们将我们写的px转化为rem了。</p><p>安装完postcss-pxtorem之后的配合非常简单，只要在.postcssrc.js文件配置如下就好了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;postcss-pxtorem&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">rootValue</span>: <span class="number">75</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rootValue：75</strong> 为啥是75呢，这是因为我们的设计稿的宽度是750px，十分之一就是75px<br><img src="https://pic1.zhimg.com/80/v2-59153648cfdfaa6f72e6ffaad2beeef8_720w.webp"><br><strong>如果你们的设计稿是375px的，就需要将值改写成37.5</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这么简单的两步就实现了移动端的适配。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li>flexible.js 原理解析(看了不会忘)：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6923060568437817351">https://juejin.cn/post/6923060568437817351</a></li><li>通过插件postcss-pxtorem轻松实现px到rem转换，完成移动端适配：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/llq886/article/details/105737987">https://blog.csdn.net/llq886/article/details/105737987</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>魔改总览</title>
    <link href="https://superq314.github.io/posts/15174961/"/>
    <id>https://superq314.github.io/posts/15174961/</id>
    <published>2022-10-15T07:51:29.000Z</published>
    <updated>2022-10-15T10:47:29.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://akilar.top/posts/d9550c81/">添加白天夜间模式转换动画</a></li><li><a href="https://akilar.top/posts/3afa069a/">引入Aplayer播放音乐</a></li><li><a href="https://akilar.top/posts/194e1534/">Butterfly布局调整———相关推荐版块侧栏卡片</a></li><li><a href="https://akilar.top/posts/451ac5f8/">Butterfly fixed card widget</a></li><li><a href="https://akilar.top/posts/a9131002/">Categories Magnet</a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a>；</li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li><li><a href=""></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Hexo" scheme="https://superq314.github.io/categories/Hexo/"/>
    
    <category term="魔改" scheme="https://superq314.github.io/categories/Hexo/%E9%AD%94%E6%94%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Vuejs构建方式</title>
    <link href="https://superq314.github.io/posts/71fee748/"/>
    <id>https://superq314.github.io/posts/71fee748/</id>
    <published>2022-10-14T08:54:26.000Z</published>
    <updated>2022-10-24T07:38:55.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将 Vue.js 添加到项目中主要有四种方式：</p><ol><li>在页面上以 <a href="https://v3.cn.vuejs.org/guide/installation.html#cdn">CDN 包</a>的形式导入。</li><li>下载 JavaScript 文件并<a href="https://v3.cn.vuejs.org/guide/installation.html#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%87%AA%E6%89%98%E7%AE%A1">自行托管</a>。</li><li>使用 <a href="https://v3.cn.vuejs.org/guide/installation.html#npm">npm</a> 安装它。</li><li>使用官方的 <a href="https://v3.cn.vuejs.org/guide/installation.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-cli">CLI</a> 来构建一个项目，它为现代前端工作流程提供了功能齐备的构建设置 (例如，热重载、保存时的提示等等)。</li></ol><p>在使用 Vue 时，推荐在浏览器上安装 <a href="https://github.com/vuejs/vue-devtools#vue-devtools">Vue Devtools</a>，允许在一个更友好的界面中审查和调试 Vue 应用。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在用 Vue 构建大型应用时推荐使用 npm 安装。npm 能很好地和诸如 <a href="https://webpack.js.org/">webpack</a> 或 <a href="https://rollupjs.org/">Rollup</a> 模块打包器配合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新稳定版</span></span><br><span class="line">npm install vue@next</span><br></pre></td></tr></table></figure><p>Vue 还提供了编写<a href="https://v3.cn.vuejs.org/guide/single-file-component.html">单文件组件</a>的配套工具。如果你想使用单文件组件，那么你还需要安装 <code>@vue/compiler-sfc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D @vue/compiler-sfc</span><br></pre></td></tr></table></figure><h2 id="命令行工具-CLI"><a href="#命令行工具-CLI" class="headerlink" title="命令行工具 (CLI)"></a>命令行工具 (CLI)</h2><p>Vue 提供<a href="https://cli.vuejs.org/zh/">CLI</a>，为单页面应用 (SPA) 快速搭建脚手架。它为现代前端工作流提供了功能齐备的构建设置。</p><p>运行所需时间短，带有热重载、保存时 lint 校验。</p><p>详情查阅 <a href="https://cli.vuejs.org/zh/">Vue CLI 的文档</a>。</p><blockquote><p>TIP</p><p>CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读<a href="https://v3.cn.vuejs.org/guide/introduction.html">指南</a>，在熟悉 Vue 本身之后再使用 CLI。</p></blockquote><p>对于 Vue 3，你应该使用 <code>npm</code> 上可用的 Vue CLI v4.5 作为 <code>@vue/cli</code>。要升级，你应该需要全局重新安装最新版本的 <code>@vue/cli</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>然后在 Vue 项目中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue upgrade --next</span><br></pre></td></tr></table></figure><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p><a href="https://cn.vitejs.dev/">Vite</a> 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。</p><p>通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。</p><p>使用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 6.x</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; --template vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 7+，需要加上额外的双短横线</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; -- --template vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>或者 yarn：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn create vite &lt;project-name&gt; --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>或者 pnpm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pnpm create vite &lt;project-name&gt; -- --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">pnpm install</span><br><span class="line">pnpm dev</span><br></pre></td></tr></table></figure><h2 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h2><p>在 <a href="https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/">npm 包的 dist&#x2F; 目录</a>你将会找到很多不同的 Vue.js 构建版本。下面是一个概述，根据不同的使用情况，应该使用哪个 <code>dist</code> 文件：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="应用规模化" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-bind绑定</title>
    <link href="https://superq314.github.io/posts/7ed0d5cb/"/>
    <id>https://superq314.github.io/posts/7ed0d5cb/</id>
    <published>2022-10-13T14:37:01.000Z</published>
    <updated>2022-10-20T07:12:45.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>操作元素的class列表和内联样式是数据绑定的一个常见需求。<br>因为都是attribute，所以用v-bind进行处理：只需要通过表达式计算出字符串结果。<br>表达式结果的类型：字符串、对象、数组。</p><h2 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a>v-bind语法糖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-bind动态绑定"><a href="#v-bind动态绑定" class="headerlink" title="v-bind动态绑定"></a>v-bind动态绑定</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">绑定Class</button></li><li class="tab"><button type="button" data-href="#super-2">绑定style</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">对象语法</button></li><li class="tab"><button type="button" data-href="#super-2">数组语法</button></li><li class="tab"><button type="button" data-href="#super-3">用在组件上</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><ol><li>直接通过 <code>{}</code>绑定一个类，以动态地切换 class：<br><code>&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>active 这个 class 存在与否将取决于数据property isActive 的 truthiness。<br>可以在对象中传入更多字段来动态切换多个 class。</p></blockquote><ol start="2"><li>通过判断，传入多个值。</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;static&quot;</span></span><br><span class="line">  v-bind:<span class="built_in">class</span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">isActive:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError:</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：<br><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code><br>当 isActive 或者 hasError 变化时，class 列表将相应地更新。<br>例如，如果 hasError 的值为 true，class 列表将变为 “static active text-danger”。<br>3. 绑定的数据对象不必内联定义在模板里：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;<span class="symbol">classObject</span>&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>绑定一个返回对象的计算属性。</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-bind:<span class="built_in">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><ol><li>把一个数组传给 v-bind:class，以应用一个 class 列表：</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;[<span class="symbol">activeClass, <span class="symbol">errorClass</span></span>]&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><code>&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></p><ol start="2"><li>根据条件切换列表中的 class，可以用三元表达式：<br><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>只有在 isActive 是 truthy时才添加 activeClass。</p></blockquote><ol start="3"><li>在数组语法中也可以使用对象语法</li></ol><blockquote><p>避免多个条件class时，书写繁琐。<br><code>&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。<br>例如，如果已经声明了这个组件：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;<span class="keyword">my</span>-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p <span class="built_in">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>在使用的时候添加一些 class：<br><code>&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</code><br>HTML 将被渲染为：<br><code>&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</code></li><li>对于带数据绑定 class ：<br><code>&lt;my-component v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/my-component&gt;</code><br>当 isActive 为 truthy时，HTML 将被渲染成为：<br><code>&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</code></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">对象语法</button></li><li class="tab"><button type="button" data-href="#super-2">数组语法</button></li><li class="tab"><button type="button" data-href="#super-3">自动添加前缀</button></li><li class="tab"><button type="button" data-href="#super-4">多重值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，需用引号括起来) 来命名：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接绑定到样式对象</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;styleObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：<br><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，VueJS 会自动侦测并添加相应的前缀。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><code>&lt;div :style=&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;&gt;&lt;/div&gt;</code><br>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-创建Vue实例</title>
    <link href="https://superq314.github.io/posts/b7848c31/"/>
    <id>https://superq314.github.io/posts/b7848c31/</id>
    <published>2022-10-13T14:36:50.000Z</published>
    <updated>2022-10-14T09:14:00.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建-Vue-实例"><a href="#创建-Vue-实例" class="headerlink" title="创建 Vue 实例"></a>创建 Vue 实例</h2><p>由 Vue 函数创建 Vue 实例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>Vue 实例会将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。<br>当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="selector-tag">var</span> data = &#123; <span class="selector-tag">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="selector-tag">var</span> vm = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm<span class="selector-class">.a</span> == data<span class="selector-class">.a</span> <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm<span class="selector-class">.a</span> = <span class="number">2</span></span><br><span class="line">data<span class="selector-class">.a</span> <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data<span class="selector-class">.a</span> = <span class="number">3</span></span><br><span class="line">vm<span class="selector-class">.a</span> <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：只有当实例被创建时，就已经存在于 data 中的 property，才是响应式的。<br>也就是说如果添加一个新的 property，比如：<br><code>vm.b = &#39;hi&#39;</code><br>那么对 b 的改动将不会触发任何视图的更新。<br>如果知道后续会需要一个 property，但是一开始为空或不存在，那么仅需要设置一些初始值。比如：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">newTodoText:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">visitCount:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">hideCompletedTodos:</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">todos:</span> [],</span><br><span class="line">  <span class="attr">error:</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.freeze()：会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">var obj = </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  foo: &#x27;bar&#x27;</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">Object.freeze(obj)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">new Vue(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="template-variable">  data: obj</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; foo &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: <span class="built_in">data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === <span class="built_in">data</span> <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === document.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, function (newValue, oldValue) &#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>el:类型：string | HTMLElement<br>作用：决定之后Vue实例会管理哪一个DOM<br>data:类型：Object | Function<br>作用：Vue实例对应的数据对象<br>methods:类型：{[key:string]:Function}<br>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-计算属性vs侦听属性</title>
    <link href="https://superq314.github.io/posts/224f971c/"/>
    <id>https://superq314.github.io/posts/224f971c/</id>
    <published>2022-10-13T14:36:36.000Z</published>
    <updated>2022-10-20T08:46:33.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算属性 VS 表达式中调用方法 VS 侦听属性</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">计算属性</button></li><li class="tab"><button type="button" data-href="#super-2">表达式中调用方法</button></li><li class="tab"><button type="button" data-href="#super-3">侦听属性</button></li><li class="tab"><button type="button" data-href="#super-4">总结</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>计算属性</p><blockquote><p>定义：要用的属性不存在，要通过已有属性计算得来。写在实例的<code>computed</code>选项中<br>原理：底层借助了<code>Objcet.defineproperty</code>方法提供的<code>getter</code>和<code>setter</code>。</p></blockquote><p><strong>计算属性的优势</strong></p><blockquote><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p></blockquote><p>对于任何复杂逻辑，都可以使用计算属性。<br>每个计算属性都包含一个getter()和setter()</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">计算属性的getter(计算属性的简写)</button></li><li class="tab"><button type="button" data-href="#super-2">计算属性的 setter</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><blockquote><p>计算属性的getter函数是没有副作用的。</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">reversedMessage</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>计算属性默认只有 getter，不过在需要时也可以提供一个 setter：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行<br>vm.fullName &#x3D; ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: <span class="string">&quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="attr">reversedMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<br>案例如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Ask a yes/no question: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">answer</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">debouncedGetAnswer</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">getAnswer</span>, <span class="number">500</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">getAnswer</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">question</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = _.<span class="title function_">capitalize</span>(response.<span class="property">data</span>.<span class="property">answer</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 watch 选项允许用户执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p><strong>计算属性是基于它们的响应式依赖进行缓存的。</strong><br>只在相关响应式依赖发生改变时它们才会重新求值。</p><p>一、computed和watch之间的区别：</p><ol><li>computed能完成的功能，watch都可以完成。</li><li>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</li></ol><p>二、两个重要的小原则：</p><ol><li>所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</li><li>所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-模板语法</title>
    <link href="https://superq314.github.io/posts/d3e99041/"/>
    <id>https://superq314.github.io/posts/d3e99041/</id>
    <published>2022-10-13T14:36:14.000Z</published>
    <updated>2022-10-20T12:21:12.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模板语法：基于 HTML，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><blockquote><p>所有 VueJS 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p></blockquote><h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 文本插值</button></li><li class="tab"><button type="button" data-href="#super-2">2. v-once 指令</button></li><li class="tab"><button type="button" data-href="#super-3">3. v-html指令</button></li><li class="tab"><button type="button" data-href="#super-4">4. v-text指令</button></li><li class="tab"><button type="button" data-href="#super-5">5. v-pre指令</button></li><li class="tab"><button type="button" data-href="#super-6">6. v-cloak指令</button></li><li class="tab"><button type="button" data-href="#super-7">7. JavaScript表达式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>使用“Mustache”语法（双大括号）：<br><code>&lt;h1&gt;&lt;/h1&gt;</code></p><blockquote><p><code>msg</code>标签将会被替代为对应数据对象上 <code>msg property</code> 的值。<br>无论何时，绑定的数据对象上 <code>msg property</code> 发生了改变，插值处的内容都会更新。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>使用 v-once 指令，执行一次性文本插值</p><ol><li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li><li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li></ol><p><code>&lt;div v-once&gt;&lt;/div&gt;</code><br>注：可能会影响到该节点上的其他数据绑定</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>v-html指令：后跟一个string类型，向指定节点中渲染包含html结构的内容。<br>与插值语法的区别：</p><ol><li>v-html会替换掉节点中所有的内容，则不会。</li><li>v-html可以识别html结构。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>span 的内容将会被替换为 property 值 rawHtml，直接作为 HTML内容</p></blockquote><p>注意：v-html有安全性问题！</p><ol><li>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</li><li>一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><p>和Mustache相似，将数据显示在界面中，一般情况下，接受一个string类型。<br>与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;你好&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-5"><p>作用：跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-6"><p>v-cloak指令（没有值）：</p><ol><li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li><li>使用css配合v-cloak可以解决网速慢时页面展示出的问题。<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>hello</span><span class="template-variable">&#123;&#123;<span class="name">name</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&#x27;web&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,<span class="number">10000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> <span class="selector-attr">[v-cloak]</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">display</span>: none;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-7"><p>实际上，对于所有的数据绑定，VueJS 都提供了完全的 JavaScript 表达式支持。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">gender</span> === <span class="string">&quot;male&quot;</span> ? <span class="string">&#x27;Boy&#x27;</span>: <span class="string">&#x27;Girl&#x27;</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>限制：每个绑定都只能包含单个表达式。<br>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h2><p>指令：带有 v- 前缀的特殊指令。<br>指令的值：预期是单个 JavaScript 表达式 (v-for 是例外情况)。<br>指令的职责：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">接收参数</button></li><li class="tab"><button type="button" data-href="#super-2">动态参数</button></li><li class="tab"><button type="button" data-href="#super-3">修饰符.</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。常用的有两个</p><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 响应式地更新HTML attribute</button></li><li class="tab"><button type="button" data-href="#super-2">2. 事件监听v-on</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> app2 = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-2&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    message: <span class="string">&#x27;页面加载于 &#x27;</span> + <span class="literal">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将该元素节点的 title attribute 和 Vue实例中的 message proterty 绑定。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> app5 = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-5&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this<span class="selector-class">.message</span> = this<span class="selector-class">.message</span><span class="selector-class">.split</span>(<span class="string">&#x27;&#x27;</span>)<span class="selector-class">.reverse</span>()<span class="selector-class">.join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><ol><li>使用 JavaScript 表达式进行动态求值，求得的值作为最终的绑定参数。<br><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code><br>例如，当Vue 实例中的data有个property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</li><li>使用动态参数为一个动态的事件名绑定处理函数：<br><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code><br>例如，当 eventName 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 v-on:focus。<button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p>修饰符是以半角句号<code>.</code>指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-条件渲染</title>
    <link href="https://superq314.github.io/posts/3e41d22b/"/>
    <id>https://superq314.github.io/posts/3e41d22b/</id>
    <published>2022-10-13T14:36:06.000Z</published>
    <updated>2022-10-20T08:59:25.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">v-if</button></li><li class="tab"><button type="button" data-href="#super-2">v-show</button></li><li class="tab"><button type="button" data-href="#super-3">v-if vs v-show</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">v-if 指令</button></li><li class="tab"><button type="button" data-href="#super-2">条件渲染分组</button></li><li class="tab"><button type="button" data-href="#super-3">用 key 管理可复用的元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">if</span> = <span class="string">&quot;male&quot;</span>&gt;i’m <span class="keyword">super</span> man!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>-<span class="keyword">if</span> = <span class="string">&quot;female&quot;</span>&gt;i’m <span class="keyword">super</span> woman!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>&gt;i’m no one!&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>将 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 v-if，从而一并切换多个元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">1. 允许用户在不同的登录方式之间切换</button></li><li class="tab"><button type="button" data-href="#super-2">2. 两个元素完全独立，不要复用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码，可用于切换 loginType 并且不会清除用户已经输入的内容。</p><blockquote><p>因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 placeholder。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>只需添加一个具有唯一值的 key attribute 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，每次切换时，输入框都将被重新渲染。<br>注意：<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 key attribute。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>根据条件展示元素的选项。用法和v-if大致一样：<br><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code></p><ul><li>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。<blockquote><p>v-show 只是简单地切换元素的 CSS property 的 display（block为显示，none为隐藏）。</p></blockquote></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><p><code>v-if</code></p><ul><li>“真正”的条件渲染：确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li>惰性：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li></ul><p><code>v-show</code></p><ul><li>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</li></ul><p>总结</p><blockquote><p>如果需要非常频繁地切换，则使用 v-show 较好；<br>如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-事件处理</title>
    <link href="https://superq314.github.io/posts/38e178ba/"/>
    <id>https://superq314.github.io/posts/38e178ba/</id>
    <published>2022-10-13T14:35:57.000Z</published>
    <updated>2022-10-20T08:30:24.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="v-on语法糖"><a href="#v-on语法糖" class="headerlink" title="v-on语法糖"></a>v-on语法糖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事件的基本使用总结："><a href="#事件的基本使用总结：" class="headerlink" title="事件的基本使用总结："></a>事件的基本使用总结：</h2><ol><li>使用<code>v-on:xxx</code>或<code>@xxx</code>绑定事件，其中<code>xx</code>是事件名；</li><li>事件的回调需要配置在<code>methods</code>对象中，最终会在<code>vm</code>上；</li><li><code>methods</code>中配置的函数，不要用箭头函数！否则<code>this</code>就不是<code>vm</code>了；</li><li><code>methods</code>中配置的函数，都是被<code>Vue</code>所管理的函数，<code>this</code>的指向是<code>vm</code>或组件实例对象；</li><li><code>@click=&quot;demo&quot;</code>和<code>@click=&quot;demo($event)&quot;</code>效果一致，但后者可以传参；</li></ol><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">事件绑定</button></li><li class="tab"><button type="button" data-href="#super-2">内联处理器中的方法</button></li><li class="tab"><button type="button" data-href="#super-3">事件修饰符</button></li><li class="tab"><button type="button" data-href="#super-4">按键/系统修饰符</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><p>如果事件绑定里面的事件不写小括号表示传的参数为$event，如果小括号里面有值则表示该值的调用事件</p><ul><li><code>@click=&quot;demo&quot;</code>和<code>@click=&quot;demo(event)</code>一样</li><li><code>@click=&quot;demo(n)</code>调用n值产生的事件</li></ul><p>案例如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">var example = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">   <span class="built_in"> name</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="keyword">function</span> (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(<span class="string">&#x27;Hello &#x27;</span> + this<span class="built_in">.name</span> + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 也可以用 JavaScript 直接调用方法</span><br><span class="line">example.greet() </span><br><span class="line">// =&gt; <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>在内联 JavaScript 语句中调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example-3&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-3&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-<span class="keyword">on</span>:click=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, <span class="keyword">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">      <span class="keyword">event</span>.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-3"><ol><li>prevent：阻止默认事件(常用);</li><li>stop：阻止事件冒泡(常用);</li><li>capture：使用事件的捕获模式;</li><li>self：只有event.target是当前操作的元素时才触发事件;</li><li>once：事件只触发一次(常用)——2.1.4 新增;</li><li>passive：事件的默认行为立即执行,无需等待事件回调执行完毕——2.3.0 新增;</li></ol><p>案例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line">`<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以对应的顺序产生。</p><blockquote><p>用 v-on:click.prevent.self会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">.once不仅能作用于原生的 DOM 事件，还能作用于自定义的组件事件上。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.passive 修饰符尤其能够提升移动端的性能。</p><blockquote><p>不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。<br>注意：.passive 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-4"><div class="tabs" id="super"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#super-1">按键修饰符</button></li><li class="tab"><button type="button" data-href="#super-2">系统修饰键（2.1.0 新增）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="super-1"><ul><li><code>@keydown</code>：按下按键不用抬起来就触发事件</li><li><code>@keyup</code>：按下按键松手才触发的事件</li><li><code>@keyup.enter</code>：enter-别名</li></ul><ol><li><p>常用的按键别名:</p><pre><code> 回车 =&gt; `enter` 删除 =&gt; `delete` (捕获“删除”和“退格”按键) 退出 =&gt; `esc` 空格 =&gt; `space` 换行 =&gt; `tab` 移动焦点(必须配合keydown使用)  上  =&gt; `up`  下  =&gt; `down`  左  =&gt; `left`(2.2.0 新增)  右  =&gt; `right`(2.2.0 新增)</code></pre><p>  中  &#x3D;&gt; <code>middle</code>(2.2.0 新增)</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。<br><code>&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</code><blockquote><p>在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。</p></blockquote></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="super-2"><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><blockquote><p>ctrl、alt、shift、meta(windows电脑的win键)</p></blockquote><ol><li>配合keyup使用:按下修饰键的同时，再按下其他键，随后释放其他键，事件才会被触发。</li><li>配合keydown使用:正常触发事件。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>.exact 修饰符——2.5.0 新增<br>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
</feed>
