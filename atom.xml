<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-10-14T09:03:38.396Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuejs构建方式</title>
    <link href="https://superq314.github.io/posts/71fee748/"/>
    <id>https://superq314.github.io/posts/71fee748/</id>
    <published>2022-10-14T08:54:26.000Z</published>
    <updated>2022-10-14T09:03:38.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将 Vue.js 添加到项目中主要有四种方式：</p><ol><li>在页面上以 <a href="https://v3.cn.vuejs.org/guide/installation.html#cdn">CDN 包</a>的形式导入。</li><li>下载 JavaScript 文件并<a href="https://v3.cn.vuejs.org/guide/installation.html#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%87%AA%E6%89%98%E7%AE%A1">自行托管</a>。</li><li>使用 <a href="https://v3.cn.vuejs.org/guide/installation.html#npm">npm</a> 安装它。</li><li>使用官方的 <a href="https://v3.cn.vuejs.org/guide/installation.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-cli">CLI</a> 来构建一个项目，它为现代前端工作流程提供了功能齐备的构建设置 (例如，热重载、保存时的提示等等)。</li></ol><p>在使用 Vue 时，推荐在浏览器上安装 <a href="https://github.com/vuejs/vue-devtools#vue-devtools">Vue Devtools</a>，允许在一个更友好的界面中审查和调试 Vue 应用。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在用 Vue 构建大型应用时推荐使用 npm 安装。npm 能很好地和诸如 <a href="https://webpack.js.org/">webpack</a> 或 <a href="https://rollupjs.org/">Rollup</a> 模块打包器配合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新稳定版</span></span><br><span class="line">npm install vue@next</span><br></pre></td></tr></table></figure><p>Vue 还提供了编写<a href="https://v3.cn.vuejs.org/guide/single-file-component.html">单文件组件</a>的配套工具。如果你想使用单文件组件，那么你还需要安装 <code>@vue/compiler-sfc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D @vue/compiler-sfc</span><br></pre></td></tr></table></figure><h2 id="命令行工具-CLI"><a href="#命令行工具-CLI" class="headerlink" title="命令行工具 (CLI)"></a>命令行工具 (CLI)</h2><p>Vue 提供<a href="https://cli.vuejs.org/zh/">CLI</a>，为单页面应用 (SPA) 快速搭建脚手架。它为现代前端工作流提供了功能齐备的构建设置。</p><p>运行所需时间短，带有热重载、保存时 lint 校验。</p><p>详情查阅 <a href="https://cli.vuejs.org/zh/">Vue CLI 的文档</a>。</p><blockquote><p>TIP</p><p>CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读<a href="https://v3.cn.vuejs.org/guide/introduction.html">指南</a>，在熟悉 Vue 本身之后再使用 CLI。</p></blockquote><p>对于 Vue 3，你应该使用 <code>npm</code> 上可用的 Vue CLI v4.5 作为 <code>@vue/cli</code>。要升级，你应该需要全局重新安装最新版本的 <code>@vue/cli</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>然后在 Vue 项目中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue upgrade --next</span><br></pre></td></tr></table></figure><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p><a href="https://cn.vitejs.dev/">Vite</a> 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。</p><p>通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。</p><p>使用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 6.x</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; --template vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 7+，需要加上额外的双短横线</span></span><br><span class="line">npm init vite@latest &lt;project-name&gt; -- --template vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>或者 yarn：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn create vite &lt;project-name&gt; --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>或者 pnpm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pnpm create vite &lt;project-name&gt; -- --template vue</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">pnpm install</span><br><span class="line">pnpm dev</span><br></pre></td></tr></table></figure><h2 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h2><p>在 <a href="https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/">npm 包的 dist&#x2F; 目录</a>你将会找到很多不同的 Vue.js 构建版本。下面是一个概述，根据不同的使用情况，应该使用哪个 <code>dist</code> 文件：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初识Vue-数据绑定bind</title>
    <link href="https://superq314.github.io/posts/7ed0d5cb/"/>
    <id>https://superq314.github.io/posts/7ed0d5cb/</id>
    <published>2022-10-13T14:37:01.000Z</published>
    <updated>2022-10-14T09:15:03.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>操作元素的class列表和内联样式是数据绑定的一个常见需求。<br>因为都是attribute，所以用v-bind进行处理：只需要通过表达式计算出字符串结果。<br>表达式结果的类型：字符串、对象、数组。</p><h2 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a>v-bind语法糖</h2><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定class"><a href="#动态绑定class" class="headerlink" title="动态绑定class"></a>动态绑定class</h3><p>用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><ol><li>使用 JavaScript 表达式进行动态求值，求得的值作为最终的绑定参数。<br>&lt;a v-bind:[attributeName]&#x3D;”url”&gt; … <code>&lt;/a&gt;</code><br>例如，当Vue 实例中的data有个property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</li><li>使用动态参数为一个动态的事件名绑定处理函数：<br>&lt;a v-on:[eventName]&#x3D;”doSomething”&gt; … <code>&lt;/a&gt;</code><br>例如，当 eventName 的值为 “focus” 时，v-on:[eventName] 将等价于 v-on:focus。</li></ol><h2 id="绑定Class"><a href="#绑定Class" class="headerlink" title="绑定Class"></a>绑定Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><ol><li>传给 v-bind:class 一个对象，以动态地切换 class：<br><code>&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>active 这个 class 存在与否将取决于数据property isActive 的 truthiness。<br>可以在对象中传入更多字段来动态切换多个 class。</p></blockquote><ol start="2"><li>v-bind:class 指令可以与普通的 class attribute 共存。当有如下模板：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span></span><br><span class="line">  <span class="built_in">class</span>=<span class="string">&quot;static&quot;</span></span><br><span class="line">  v-bind:<span class="built_in">class</span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span><br><span class="line">&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">isActive:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError:</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：<br><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code><br>当 isActive 或者 hasError 变化时，class 列表将相应地更新。<br>例如，如果 hasError 的值为 true，class 列表将变为 “static active text-danger”。<br>3. 绑定的数据对象不必内联定义在模板里：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;<span class="symbol">classObject</span>&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>绑定一个返回对象的计算属性。这是一个常用且强大的模式：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><ol><li>把一个数组传给 v-bind:class，以应用一个 class 列表：</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="keyword">class</span>=&quot;[<span class="symbol">activeClass, <span class="symbol">errorClass</span></span>]&quot;&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line"><span class="symbol">data: </span>&#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><code>&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></p><ol start="2"><li>根据条件切换列表中的 class，可以用三元表达式：<br><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code></li></ol><blockquote><p>只有在 isActive 是 truthy时才添加 activeClass。</p></blockquote><ol start="3"><li>在数组语法中也可以使用对象语法</li></ol><blockquote><p>避免多个条件class时，书写繁琐。<br><code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</code></p></blockquote><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><p>当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。<br>例如，如果已经声明了这个组件：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;<span class="keyword">my</span>-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p <span class="built_in">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>在使用的时候添加一些 class：<br><code>&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</code><br>HTML 将被渲染为：<br><code>&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</code></li><li>对于带数据绑定 class ：<br><code>&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</code><br>当 isActive 为 truthy时，HTML 将被渲染成为：<br><code>&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</code></li></ol><h2 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p>v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，需用引号括起来) 来命名：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接绑定到样式对象，使模板更清晰：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-bind:style=<span class="string">&quot;styleObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：<br><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></p><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，VueJS 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><code>&lt;div :style=&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;/div&gt;</code><br>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-创建Vue实例</title>
    <link href="https://superq314.github.io/posts/b7848c31/"/>
    <id>https://superq314.github.io/posts/b7848c31/</id>
    <published>2022-10-13T14:36:50.000Z</published>
    <updated>2022-10-14T09:14:00.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建-Vue-实例"><a href="#创建-Vue-实例" class="headerlink" title="创建 Vue 实例"></a>创建 Vue 实例</h2><p>由 Vue 函数创建 Vue 实例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>Vue 实例会将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。<br>当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="selector-tag">var</span> data = &#123; <span class="selector-tag">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="selector-tag">var</span> vm = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm<span class="selector-class">.a</span> == data<span class="selector-class">.a</span> <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm<span class="selector-class">.a</span> = <span class="number">2</span></span><br><span class="line">data<span class="selector-class">.a</span> <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data<span class="selector-class">.a</span> = <span class="number">3</span></span><br><span class="line">vm<span class="selector-class">.a</span> <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：只有当实例被创建时，就已经存在于 data 中的 property，才是响应式的。<br>也就是说如果添加一个新的 property，比如：<br><code>vm.b = &#39;hi&#39;</code><br>那么对 b 的改动将不会触发任何视图的更新。<br>如果知道后续会需要一个 property，但是一开始为空或不存在，那么仅需要设置一些初始值。比如：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> &#123;</span><br><span class="line">  <span class="attr">newTodoText:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">visitCount:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">hideCompletedTodos:</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">todos:</span> [],</span><br><span class="line">  <span class="attr">error:</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.freeze()：会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">var obj = </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  foo: &#x27;bar&#x27;</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">Object.freeze(obj)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">new Vue(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="template-variable">  data: obj</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; foo &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: <span class="built_in">data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === <span class="built_in">data</span> <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === document.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, function (newValue, oldValue) &#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>el:类型：string | HTMLElement<br>作用：决定之后Vue实例会管理哪一个DOM<br>data:类型：Object | Function<br>作用：Vue实例对应的数据对象<br>methods:类型：{[key:string]:Function}<br>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-计算属性和侦听器</title>
    <link href="https://superq314.github.io/posts/224f971c/"/>
    <id>https://superq314.github.io/posts/224f971c/</id>
    <published>2022-10-13T14:36:36.000Z</published>
    <updated>2022-10-14T09:14:39.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算属性 VS 表达式中调用方法 VS 侦听属性</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性，写在实例的computed选项中<br>计算属性的优势</p><blockquote><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p></blockquote><p>对于任何复杂逻辑，都可以使用计算属性。<br>每个计算属性都包含一个getter()和setter()</p><h3 id="计算属性的getter"><a href="#计算属性的getter" class="headerlink" title="计算属性的getter"></a>计算属性的getter</h3><blockquote><p>计算属性的getter函数是没有副作用的。</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;</span><span class="template-variable">&#123;&#123; <span class="name">reversedMessage</span> &#125;&#125;</span><span class="language-xml">&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><p>计算属性默认只有 getter，不过在需要时也可以提供一个 setter：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行<br>vm.fullName &#x3D; ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h2 id="表达式中调用方法"><a href="#表达式中调用方法" class="headerlink" title="表达式中调用方法"></a>表达式中调用方法</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: <span class="string">&quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="attr">reversedMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.message.<span class="built_in">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="built_in">reverse</span>().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h2><p>有时需要一个自定义的侦听器。因此，Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<br>例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Ask a yes/no question: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">answer</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">debouncedGetAnswer</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">getAnswer</span>, <span class="number">500</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">getAnswer</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">question</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = _.<span class="title function_">capitalize</span>(response.<span class="property">data</span>.<span class="property">answer</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          vm.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 watch 选项允许用户执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>总结：<br><strong>计算属性是基于它们的响应式依赖进行缓存的。</strong><br>只在相关响应式依赖发生改变时它们才会重新求值。</p><ul><li>这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li><li>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-模板语法</title>
    <link href="https://superq314.github.io/posts/d3e99041/"/>
    <id>https://superq314.github.io/posts/d3e99041/</id>
    <published>2022-10-13T14:36:14.000Z</published>
    <updated>2022-10-14T09:23:56.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模板语法：基于 HTML，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><blockquote><p>所有 VueJS 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p></blockquote><h2 id="模板插值"><a href="#模板插值" class="headerlink" title="模板插值"></a>模板插值</h2><ol><li>文本插值<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：<br><code>&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</code><br><code>Mustache</code>标签将会被替代为对应数据对象上 <code>msg property</code> 的值。</li></ol><blockquote><p>无论何时，绑定的数据对象上 <code>msg property</code> 发生了改变，插值处的内容都会更新。</p></blockquote><ol start="2"><li><p>一次性文本插值<br>通过使用 v-once 指令，执行一次性文本插值，当数据改变时，插值处的内容不会更新。<br><code>&lt;div v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</code><br>注：这会影响到该节点上的其他数据绑定</p></li><li><p>插入原始HTML</p><ol><li>如果直接通过<code>&#123;&#123;&#125;&#125;</code>来输出，会将HTML格式进行解析，并且显示对应的内容。</li><li>可以使用v-html指令，该指令后跟上一个string类型</li><li>会将string的html解析处理并且进行渲染</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>span 的内容将会被替换为 property 值 rawHtml，直接作为 HTML内容<br>在站点上动态渲染任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。<br>请只对可信内容使用 HTML 插值，绝不要对用户提供的内容（UGC内容）使用插值。</p></blockquote><ol start="4"><li>v-text的作用和Mustache比较相似，独使用于将数据显示在界面中，一般情况下，接受一个string类型。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">message</span>: <span class="string">&#x27;你好&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="6"><li>v-cloak斗篷的意思。</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>hello</span><span class="template-variable">&#123;&#123;<span class="name">name</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">name</span>: <span class="string">&#x27;web&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;,<span class="number">10000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> <span class="selector-attr">[v-cloak]</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">display</span>: none;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="7"><li>JavaScript表达式<br>实际上，对于所有的数据绑定，VueJS 都提供了完全的 JavaScript 表达式支持。<br><code>&lt;div&gt;&#123;&#123; gender === "male" ? 'Boy': 'Girl' &#125;&#125;&lt;/div&gt;</code></li></ol><blockquote><p>限制：每个绑定都只能包含单个表达式。<br>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。<br>指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况)。<br>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<br>接收参数<br>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。常用的有两个</p><ol><li>响应式地更新HTML attribute</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> app2 = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-2&#x27;</span>,</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    message: <span class="string">&#x27;页面加载于 &#x27;</span> + <span class="literal">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将该元素节点的 title attribute 和 Vue实例中的 message proterty 绑定。</p></blockquote><ol start="2"><li>事件监听</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> app5 = new <span class="built_in">Vue</span>(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-5&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this<span class="selector-class">.message</span> = this<span class="selector-class">.message</span><span class="selector-class">.split</span>(<span class="string">&#x27;&#x27;</span>)<span class="selector-class">.reverse</span>()<span class="selector-class">.join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p>用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><ol><li>使用 JavaScript 表达式进行动态求值，求得的值作为最终的绑定参数。<br><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code><br>例如，当Vue 实例中的data有个property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</li><li>使用动态参数为一个动态的事件名绑定处理函数：<br><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code><br>例如，当 eventName 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 v-on:focus。</li></ol><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-条件渲染</title>
    <link href="https://superq314.github.io/posts/3e41d22b/"/>
    <id>https://superq314.github.io/posts/3e41d22b/</id>
    <published>2022-10-13T14:36:06.000Z</published>
    <updated>2022-10-14T09:16:19.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>条件渲染</p><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><div v-if = "male">i’m super man!</div><div v-else-if = "female">i’m super woman!</div><div v-else>i’m no one!</div><h2 id="条件渲染分组"><a href="#条件渲染分组" class="headerlink" title="条件渲染分组"></a>条件渲染分组</h2><p>将 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 v-if，从而一并切换多个元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h2><p>允许用户在不同的登录方式之间切换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码，可用于切换 loginType 并且不会清除用户已经输入的内容。</p><blockquote><p>因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 placeholder。</p></blockquote><ol start="2"><li>Vue 还提供了一种方式来表达“这两个元素是完全独立的，不要复用”。只需添加一个具有唯一值的 key attribute 即可：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，每次切换时，输入框都将被重新渲染。<br>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 key attribute。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>根据条件展示元素的选项。用法和v-if大致一样：<br><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code></p><ul><li>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。</li></ul><blockquote><p>v-show 只是简单地切换元素的 CSS property display。<br>注意，v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p></blockquote><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p>v-if </p><ul><li>“真正”的条件渲染：确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li>惰性：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show </li><li>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</li></ul><blockquote><p>因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-事件处理</title>
    <link href="https://superq314.github.io/posts/38e178ba/"/>
    <id>https://superq314.github.io/posts/38e178ba/</id>
    <published>2022-10-13T14:35:57.000Z</published>
    <updated>2022-10-14T09:14:55.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。<br>示例：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked </span><span class="template-variable">&#123;&#123; <span class="name">counter</span> &#125;&#125;</span><span class="language-xml"> times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var example = new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    counter: 0</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><p>v-on 可以接收一个需要调用的方法名称，从而处理许多复杂逻辑的事件处理。<br>示例：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">var example = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">   <span class="built_in"> name</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="keyword">function</span> (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(<span class="string">&#x27;Hello &#x27;</span> + this<span class="built_in">.name</span> + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 也可以用 JavaScript 直接调用方法</span><br><span class="line">example.greet() </span><br><span class="line">// =&gt; <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example-3&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-3&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-<span class="keyword">on</span>:click=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, <span class="keyword">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">      <span class="keyword">event</span>.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。<br>尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。<br>为了解决这个问题，VueJS 为 v-on 提供了事件修饰符。</p><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line">`<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。<br>因此，用 v-on:click.prevent.self会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.1.4 新增</span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">.once不仅能作用于原生的 DOM 事件，还能作用于自定义的组件事件上。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.3.0 新增</span><br><span class="line"><span class="comment">&lt;!-- Vue 还为对应于 addEventListener中的passive选项提供了 .passive 修饰符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.passive 修饰符尤其能够提升移动端的性能。</p><blockquote><p>不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。<br>注意：.passive 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。<br><code>&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</code></p><p>在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>2.1.0 新增<br>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta<br>例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。<br>换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。<br>而单单释放 ctrl 也不会触发事件。<br>如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。<br>.exact 修饰符<br>2.5.0 新增<br>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>鼠标按钮修饰符<br>2.2.0 新增</p><ul><li>.left</li><li>.right</li><li>.middle</li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p><h2 id="为什么在-HTML-中监听事件？"><a href="#为什么在-HTML-中监听事件？" class="headerlink" title="为什么在 HTML 中监听事件？"></a>为什么在 HTML 中监听事件？</h2><p>这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。<br>但是因为所有的 VueJS 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。<br>实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</li></ol><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。</p><blockquote><p>Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p></blockquote><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-列表渲染</title>
    <link href="https://superq314.github.io/posts/cf3da349/"/>
    <id>https://superq314.github.io/posts/cf3da349/</id>
    <published>2022-10-13T14:35:49.000Z</published>
    <updated>2022-10-14T09:14:32.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h2><p>可以用 v-for 指令基于一个数组来渲染一个列表。<br>v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="language-xquery">&#123;&#123; <span class="type">item</span>.message &#125;</span><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">var example = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; message: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 v-for 块中，可以访问所有父作用域的 property。v-for 还支持一个可选的第二个参数，即当前项的索引。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">parentMessage</span> &#125;&#125;</span><span class="language-xml"> - </span><span class="template-variable">&#123;&#123; <span class="name">index</span> &#125;&#125;</span><span class="language-xml"> - </span><span class="template-variable">&#123;&#123; <span class="name">item.message</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var example = new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    parentMessage: &#x27;Parent&#x27;,</span></span><br><span class="line"><span class="language-xml">    items: [</span></span><br><span class="line"><span class="language-xml">      &#123; message: &#x27;Foo&#x27; &#125;,</span></span><br><span class="line"><span class="language-xml">      &#123; message: &#x27;Bar&#x27; &#125;</span></span><br><span class="line"><span class="language-xml">    ]</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以用 of 替代 in 作为分隔符，因为更接近 JavaScript 迭代器的语法：<br><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</code></p></blockquote><h2 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h2><p>也可以用 v-for 来遍历一个对象的 property。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;v-for-object&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">  &lt;li v-for=<span class="string">&quot;value in object&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="title">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  el: &#x27;#v-for-object&#x27;,</span><br><span class="line">  <span class="class"><span class="keyword">data</span>: &#123;</span></span><br><span class="line"><span class="class">    <span class="title">object</span>: &#123;</span></span><br><span class="line"><span class="class">      <span class="title">title</span>: &#x27;<span class="type">How</span> <span class="title">to</span> <span class="title">do</span> <span class="title">lists</span> <span class="title">in</span> <span class="type">Vue</span>&#x27;,</span></span><br><span class="line"><span class="class">      <span class="title">author</span>: &#x27;<span class="type">Jane</span> <span class="type">Doe</span>&#x27;,</span></span><br><span class="line"><span class="class">      <span class="title">publishedAt</span>: &#x27;2016-04-10&#x27;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">name</span> &#125;&#125;</span><span class="language-xml">: </span><span class="template-variable">&#123;&#123; <span class="name">value</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数作为索引：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">index</span> &#125;&#125;</span><span class="language-xml">. </span><span class="template-variable">&#123;&#123; <span class="name">name</span> &#125;&#125;</span><span class="language-xml">: </span><span class="template-variable">&#123;&#123; <span class="name">value</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。</p></blockquote><h2 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h2><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。<br>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key attribute：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>key的作用主要是为了高效的更新虚拟dom。<br>因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。</p><blockquote><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></blockquote><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。<br>变更方法：变更调用了这些方法的原始数组。<br>这些被包裹过的方法包括：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><h3 id="替换数组（非变更方法）"><a href="#替换数组（非变更方法）" class="headerlink" title="替换数组（非变更方法）"></a>替换数组（非变更方法）</h3><p>例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。<br>当使用非变更方法时，可以用新数组替换旧数组：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.<span class="built_in">filter</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p><h2 id="显示过滤-x2F-排序后的结果"><a href="#显示过滤-x2F-排序后的结果" class="headerlink" title="显示过滤&#x2F;排序后的结果"></a>显示过滤&#x2F;排序后的结果</h2><p>需求：显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。<br>方法：创建一个计算属性，用于返回过滤或排序后的数组。<br>例如：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span></span><span class="language-xquery">&#123;&#123; n &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: <span class="keyword">function</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> this.numbers<span class="built_in">.filter</span>(<span class="keyword">function</span> <span class="built_in">(number</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span><span class="built_in"> number</span> % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">for</span>=<span class="string">&quot;set in sets&quot;</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;n in even(set)&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  sets: <span class="string">[[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> <span class="params">(numbers)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> <span class="params">(number)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-v-for-里使用值范围"><a href="#在-v-for-里使用值范围" class="headerlink" title="在 v-for 里使用值范围"></a>在 v-for 里使用值范围</h2><p>v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">n</span> &#125;&#125;</span><span class="language-xml"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="在-lt-template-gt-上使用-v-for"><a href="#在-lt-template-gt-上使用-v-for" class="headerlink" title="在 &lt;template&gt; 上使用 v-for"></a>在 <code>&lt;template&gt;</code> 上使用 v-for</h2><p>类似于 v-if，可以利用带有 v-for 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">item.msg</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="v-for-与-v-if-一同使用"><a href="#v-for-与-v-if-一同使用" class="headerlink" title="v-for 与 v-if 一同使用"></a>v-for 与 v-if 一同使用</h2><blockquote><p>注意：不推荐在同一元素上使用 v-if 和 v-for。<br>当处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下：</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">todo</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的代码将只渲染未完成的 todo。<br>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;todos.length&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h2><p>在自定义组件上，你可以像在任何普通元素上一样使用 v-for。<br><code>&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt;</code><br>2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。<br>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in items&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:item=<span class="string">&quot;item&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:<span class="keyword">index</span>=<span class="string">&quot;index&quot;</span></span><br><span class="line">  v-<span class="keyword">bind</span>:key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">&gt;&lt;/<span class="keyword">my</span>-component&gt;</span><br></pre></td></tr></table></figure><p>不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。<br>下面是一个简单的 todo 列表的完整例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;todo-list-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;addNewTodo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;new-todo&quot;</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;new-todo&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">&quot;E.g. Feed the cat&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">&quot;todo-item&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;(todo, index) in todos&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">&quot;todo.title&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">&quot;todos.splice(index, 1)&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的 is&#x3D;”todo-item” attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code>元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click=&quot;$emit(\&#x27;remove\&#x27;)&quot;&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  &#x27;</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attribute">el</span>: <span class="string">&#x27;#todo-list-example&#x27;</span>,</span><br><span class="line">  <span class="attribute">data</span>: &#123;</span><br><span class="line">    <span class="attribute">newTodoText</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attribute">todos</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 1,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Do the dishes&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 2,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Take out the trash&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 3,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">&#x27;Mow the lawn&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attribute">nextTodoId</span>: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attribute">methods</span>: &#123;</span><br><span class="line">    <span class="attribute">addNewTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> this.nextTodoId</span>++,</span><br><span class="line">        <span class="attribute">title</span>: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-表单输入绑定</title>
    <link href="https://superq314.github.io/posts/f6a53e88/"/>
    <id>https://superq314.github.io/posts/f6a53e88/</id>
    <published>2022-10-13T14:35:40.000Z</published>
    <updated>2022-10-14T09:14:18.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>可以用 v-model 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。<br>v-model 本质上是语法糖，本质：</p><ol><li>v-bind绑定一个value属性</li><li>v-on指令给当前元素绑定input事件</li></ol><p>&#x3D;&#x3D;&gt; 负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p><blockquote><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 data 选项中声明初始值。</p></blockquote><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: </span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space: pre-line;&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;add multiple lines&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在文本区域插值 (<code>&lt;textarea&gt;</code><code>&lt;/textarea&gt;</code>) 并不会生效，应用 v-model 来代替。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单个复选框，绑定到布尔值：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">checked</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>多个复选框，绑定到同一个数组：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mike&quot;</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: </span><span class="template-variable">&#123;&#123; <span class="name">checkedNames</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;...&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    checkedNames: []</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;One&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Two&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: </span><span class="template-variable">&#123;&#123; <span class="name">picked</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example-4&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    picked: &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h3><h4 id="单选时："><a href="#单选时：" class="headerlink" title="单选时："></a>单选时：</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="template-variable">&#123;&#123; <span class="name">selected</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;...&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    selected: &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><p>如果 v-model 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p><h4 id="多选时-绑定到一个数组-："><a href="#多选时-绑定到一个数组-：" class="headerlink" title="多选时 (绑定到一个数组)："></a>多选时 (绑定到一个数组)：</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">&quot;width: 50px;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="template-variable">&#123;&#123; <span class="name">selected</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml">  el: &#x27;#example-6&#x27;,</span></span><br><span class="line"><span class="language-xml">  data: &#123;</span></span><br><span class="line"><span class="language-xml">    selected: []</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="用-v-for-渲染的动态选项："><a href="#用-v-for-渲染的动态选项：" class="headerlink" title="用 v-for 渲染的动态选项："></a>用 v-for 渲染的动态选项：</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="language-xquery">&#123;&#123; <span class="keyword">option</span>.<span class="type">text</span> &#125;</span><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: </span><span class="language-xquery">&#123;&#123; selected &#125;</span><span class="language-xml">&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: <span class="string">&#x27;One&#x27;</span>, value: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">      &#123; text: <span class="string">&#x27;Two&#x27;</span>, value: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">      &#123; text: <span class="string">&#x27;Three&#x27;</span>, value: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 v-bind 实现，并且这个 property 的值可以不是字符串。</p><h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  <span class="keyword">type</span>=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">  v-model=<span class="string">&quot;toggle&quot;</span></span><br><span class="line">  <span class="literal">true</span>-value=<span class="string">&quot;yes&quot;</span></span><br><span class="line">  <span class="literal">false</span>-value=<span class="string">&quot;no&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.toggle === <span class="string">&#x27;yes&#x27;</span></span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.toggle === <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 true-value 和 false-value attribute 并不会影响输入控件的 value attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。<br>如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p><h3 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;radio&quot;</span> v-model=<span class="string">&quot;pick&quot;</span> v-<span class="keyword">bind</span>:value=<span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm<span class="variable">.pick</span> === vm<span class="variable">.a</span></span><br></pre></td></tr></table></figure><h3 id="选择框的选项"><a href="#选择框的选项" class="headerlink" title="选择框的选项"></a>选择框的选项</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;&#123; number: 123 &#125;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line">// 当选中</span><br><span class="line">typeof vm.selected // =&gt; <span class="string">&#x27;object&#x27;</span></span><br><span class="line">vm.selected<span class="built_in">.number</span> // =&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>.lazy</p><ol><li>默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。</li><li>一旦有数据发生改变对应的data中的数据就会自动发生改变。</li><li>可以添加lazy修饰符，让数据在 change 事件之后进行更新：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.number</p><ol><li>默认情况下，在输入框中无论输入的是字母&#x2F;数字，都会被当做字符串类型进行处理。</li><li>number修饰符可以让在输入框中输入的内容自动转成数值类型。<br><code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code><br>这通常很有用，因为即使在 type&#x3D;”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。</li></ol><p>.trim<br>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：<br><code>&lt;input v-model.trim=&quot;msg&quot;&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-组件基础</title>
    <link href="https://superq314.github.io/posts/b1068101/"/>
    <id>https://superq314.github.io/posts/b1068101/</id>
    <published>2022-10-13T14:35:06.000Z</published>
    <updated>2022-10-14T09:18:03.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><p>1.组件化是vue.js中的重要思想<br>2.它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用<br>3.任何的应用都会被抽象成一颗组件树<br><img src="/image/%E7%BB%84%E4%BB%B6%E5%8C%96%E2%80%94%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/1665673037732.png" alt="1665673037732"><br>注册组件的基本步骤：<br>1.创建组件构造器<br>2.注册组件<br>3.使用组件<br>示例：<br>调用Vue.extend()方法创建组件构造器<br>调用Vue.component()方法，注册组件<br>在Vue实例的作用范围内使用组件</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>这里有一个 Vue 组件的示例：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(<span class="symbol">&#x27;button</span>-counter&#x27;, &#123;</span><br><span class="line">  data: <span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">&#123;</span></span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;`&lt;button v-on:click=<span class="string">&quot;count++&quot;</span>&gt;`You clicked me &#123;&#123; count &#125;&#125; times.`&lt;/button&gt;`&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。<br>我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">new Vue(</span><span class="template-variable">&#123; el: &#x27;#components-demo&#x27; &#125;</span><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。<br>仅有的例外是像 el这样根实例特有的选项。</p><h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>将组件进行任意次数的复用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p><h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h3><p>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>: &#123;</span></span><br><span class="line"><span class="class">  <span class="title">count</span>: 0</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：<br>data: function () {<br>  return {<br>    count: 0<br>  }<br>}<br>如果 Vue 没有这条规则，点击一个按钮可能会影响到其它所有实例。</p><h2 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h2><p>通常一个应用会以一棵嵌套的组件树的形式来组织。<br>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。<br>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。<br>这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的：<br>Vue.component(‘my-component-name’, {<br>  &#x2F;&#x2F; … options …<br>})<br>全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><h2 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a>通过 Prop 向子组件传递数据</h2><p>Prop 是可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中：<br>Vue.component(‘blog-post’, {<br>  props: [‘title’],<br>  template: ‘<code>&lt;h3&gt;</code>组件化-组件基础<code>&lt;/h3&gt;</code>‘<br>})<br>一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。<br>一个 prop 被注册之后，你就可以像这样把数据作为一个自定义 attribute 传递进来：<br><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code><br><code>&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;</code><br><code>&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;</code><br>然而在一个典型的应用中，你可能在 data 里有一个博文的数组：<br>new Vue({<br>  el: ‘#blog-post-demo’,<br>  data: {<br>    posts: [<br>      { id: 1, title: ‘My journey with Vue’ },<br>      { id: 2, title: ‘Blogging with Vue’ },<br>      { id: 3, title: ‘Why Vue is so fun’ }<br>    ]<br>  }<br>})<br>并想要为每篇博文渲染一个组件：<br>&lt;blog-post<br>  v-for&#x3D;”post in posts”<br>  v-bind:key&#x3D;”post.id”<br>  v-bind:title&#x3D;”post.title”</p><blockquote></blog-post></blockquote><p>如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。</p><h2 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h2><p>当构建一个 <code>&lt;blog-post&gt;</code> 组件时，你的模板最终会包含的东西远不止一个标题：</p><h3>组件化-组件基础</h3>最最起码，你会包含这篇博文的正文：<h3>组件化-组件基础</h3><div v-html="content"></div>然而如果你在模板中尝试这样写，Vue 会显示一个错误，并解释道 every component must have a single root element (每个组件必须只有一个根元素)。你可以将模板的内容包裹在一个父元素内，来修复这个问题，例如：<div class="blog-post">  <h3>组件化-组件基础</h3>  <div v-html="content"></div></div>看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦：<blog-post  v-for="post in posts"  v-bind:key="post.id"  v-bind:title="post.title"  v-bind:content="post.content"  v-bind:publishedAt="post.publishedAt"  v-bind:comments="post.comments"></blog-post>所以是时候重构一下这个 <blog-post> 组件了，让它变成接受一个单独的 postprop：<blog-post  v-for="post in posts"  v-bind:key="post.id"  v-bind:post="post"></blog-post>Vue.component('blog-post', {  props: ['post'],  template: `    <div class="blog-post">      <h3></h3>      <div v-html="post.content"></div>    </div>  `})上述的这个和一些接下来的示例使用了 JavaScript 的模板字符串来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之。现在，不论何时为 post 对象添加一个新的 property，它都会自动地在 <blog-post>内可用。<h2 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h2><p>在我们开发 <code>&lt;blog-post&gt;</code> 组件时，它的一些功能可能要求我们和父级组件进行沟通。例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号。<br>在其父组件中，我们可以通过添加一个 postFontSize 数据 property 来支持这个功能：<br>new Vue({<br>  el: ‘#blog-posts-events-demo’,<br>  data: {<br>    posts: [&#x2F;* … *&#x2F;],<br>    postFontSize: 1<br>  }<br>})<br>它可以在模板中用来控制所有博文的字号：</p><div id="blog-posts-events-demo">  <div :style="{ fontSize: postFontSize + 'em' }">    <blog-post      v-for="post in posts"      v-bind:key="post.id"      v-bind:post="post"    ></blog-post>  </div></div>现在我们在每篇博文正文之前添加一个按钮来放大字号：Vue.component('blog-post', {  props: ['post'],  template: `    <div class="blog-post">      <h3></h3>      <button>        Enlarge text      </button>      <div v-html="post.content"></div>    </div>  `})问题是这个按钮不会做任何事：<button>  Enlarge text</button>当点击这个按钮时，我们需要告诉父级组件放大所有博文的文本。幸好 Vue 实例提供了一个自定义事件的系统来解决这个问题。1. 父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：<blog-post  ...  v-on:enlarge-text="postFontSize += 0.1"></blog-post>2. 子组件通过调用内建的 $emit 方法并传入事件名称来触发一个事件：<button v-on:click="$emit('enlarge-text')">  Enlarge text</button>有了这个 v-on:enlarge-text="postFontSize += 0.1" 监听器，父级组件就会接收该事件并更新 postFontSize 的值。<h3 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h3><p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 $emit 的第二个参数来提供这个值：<br><code>&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;</code><br>  Enlarge text<br><code>&lt;/button&gt;</code><br>然后当在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值：<br>&lt;blog-post<br>  …<br>  v-on:enlarge-text&#x3D;”postFontSize +&#x3D; $event”</p><blockquote></blog-post></blockquote><p>或者，如果这个事件处理函数是一个方法：<br>&lt;blog-post<br>  …<br>  v-on:enlarge-text&#x3D;”onEnlargeText”</p><blockquote></blog-post></blockquote><p>那么这个值将会作为第一个参数传入这个方法：<br>methods: {<br>  onEnlargeText: function (enlargeAmount) {<br>    this.postFontSize +&#x3D; enlargeAmount<br>  }<br>}</p><h3 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h3><p>自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：<br><code>&lt;input v-model=&quot;searchText&quot;&gt;</code><br>等价于：<br>&lt;input<br>  v-bind:value&#x3D;”searchText”<br>  v-on:input&#x3D;”searchText &#x3D; $event.target.value”</p><p>当用在组件上时，v-model 则会这样：<br>&lt;custom-input<br>  v-bind:value&#x3D;”searchText”<br>  v-on:input&#x3D;”searchText &#x3D; $event”</p><blockquote></custom-input></blockquote><p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p><ul><li>将其 value attribute 绑定到一个名叫 value 的 prop 上</li><li>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出<br>写成代码之后是这样的：<br>Vue.component(‘custom-input’, {<br>props: [‘value’],<br>template: <code>&lt;input v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;    &gt;</code><br>})<br>现在 v-model 就应该可以在这个组件上完美地工作起来了：<br><code>&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</code><br>到目前为止，关于组件自定义事件你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把自定义事件读完。</li></ul><h2 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h2><p>和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：<br><code>&lt;alert-box&gt;</code><br>  Something bad happened.<code>&lt;/alert-box&gt;</code><br>可能会渲染出这样的东西：<br>Error! Something bad happened.<br>幸好，Vue 自定义的 <code>&lt;slot&gt;</code> 元素让这变得非常简单：<br>Vue.component(‘alert-box’, {<br>  template: <code>   &lt;div class=&quot;demo-alert-box&quot;&gt;       &lt;strong&gt;Error!&lt;/strong&gt;       &lt;slot&gt;&lt;/slot&gt;     &lt;/div&gt; </code><br>})<br>如你所见，我们只要在需要的地方加入插槽就行了——就这么简单！</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：<br>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is attribute 来实现：</p><!-- 组件会在 `currentTabComponent` 改变时改变 --><p><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>在上述示例中，currentTabComponent 可以包括</p><ul><li>已注册组件的名字，或</li><li>一个组件的选项对象<br>注意：这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，若想让其如预期般工作，你需要使用 .prop 修饰器。</li></ul><h2 id="解析-DOM-模板时的注意事项"><a href="#解析-DOM-模板时的注意事项" class="headerlink" title="解析 DOM 模板时的注意事项"></a>解析 DOM 模板时的注意事项</h2><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。<br>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p><table>  <blog-post-row></blog-post-row></table>这个自定义组件 <blog-post-row> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：<table>  <tr is="blog-post-row"></tr></table>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：字符串 (例如：template: '...')单文件组件 (.vue)<script type="text/x-template">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-组件注册</title>
    <link href="https://superq314.github.io/posts/1944849e/"/>
    <id>https://superq314.github.io/posts/1944849e/</id>
    <published>2022-10-13T14:34:58.000Z</published>
    <updated>2022-10-14T09:18:08.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>组件注册<br>组件名<br>在注册一个组件的时候，需要一个名字。比如在全局注册的时候：<br>Vue.component(‘my-component-name’, { &#x2F;* … <em>&#x2F; })<br>该组件名就是 Vue.component 的第一个参数。<br>给予组件的名字可能依赖于打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。定义组件名<br>方式有两种：<br>1、使用 kebab-case<br>Vue.component(‘my-component-name’, { &#x2F;</em> … <em>&#x2F; })<br>当使用 kebab-case (短横线分隔命名) 定义一个组件时，必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。<br>2、使用 PascalCase<br>Vue.component(‘MyComponentName’, { &#x2F;</em> … *&#x2F; })<br>当使用 PascalCase (首字母大写命名) 定义一个组件时，在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的。</p><blockquote><p>注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>注册全局组件<br>用 Vue.component 来创建组件：<br>Vue.component(‘my-component-name’, {<br> &#x2F;&#x2F; … 选项 …<br>})<br>在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如：<br>Vue.component(‘component-a’, { &#x2F;* … <em>&#x2F; })<br>Vue.component(‘component-b’, { &#x2F;</em> … <em>&#x2F; })<br>Vue.component(‘component-c’, { &#x2F;</em> … *&#x2F; })<br>new Vue({ el: ‘#app’ })</p></blockquote><div id="app">  <component-a></component-a>  <component-b></component-b>  <component-c></component-c></div>在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。注册局部组件全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { /* ... */ }然后在 components 选项中定义想要使用的组件：new Vue({  el: '#app',  components: {    'component-a': ComponentA,    'component-b': ComponentB  }})对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。注意局部注册的组件在其子组件中不可用。> 例如，如果希望 ComponentA 在 ComponentB 中可用，则需要这样写：var ComponentA = { /* ... */ }var ComponentB = {  components: {    'component-a': ComponentA  },  // ...}或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：import ComponentA from './ComponentA.vue'export default {  components: {    ComponentA  },  // ...}注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是：用在模板中的自定义元素的名称包含了这个组件选项的变量名模块系统在模块系统中局部注册如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中：import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default {  components: {    ComponentA,    ComponentC  },  // ...}现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。所以会导致很多组件里都会有一个包含基础组件的长列表：import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default {  components: {    BaseButton,    BaseIcon,    BaseInput  }}而只是用于模板中的一小部分：<BaseInput  v-model="searchText"  @keydown.enter="search"/><BaseButton @click="search">  <BaseIcon name="search"/></BaseButton>如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context(  // 其组件目录的相对路径  './components',  // 是否查询其子目录  false,  // 匹配基础组件文件名的正则表达式  /Base[A-Z]\w+\.(vue|js)$/)<p>requireComponent.keys().forEach(fileName &#x3D;&gt; {<br>  &#x2F;&#x2F; 获取组件配置<br>  const componentConfig &#x3D; requireComponent(fileName)</p><p>  &#x2F;&#x2F; 获取组件的 PascalCase 命名<br>  const componentName &#x3D; upperFirst(<br>    camelCase(<br>      &#x2F;&#x2F; 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘&#x2F;‘)<br>        .pop()<br>        .replace(&#x2F;.\w+$&#x2F;, ‘’)<br>    )<br>  )</p><p>  &#x2F;&#x2F; 全局注册组件<br>  Vue.component(<br>    componentName,<br>    &#x2F;&#x2F; 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    &#x2F;&#x2F; 那么就会优先使用 <code>.default</code>，<br>    &#x2F;&#x2F; 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})<br>记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-处理边界情况</title>
    <link href="https://superq314.github.io/posts/363ae6cf/"/>
    <id>https://superq314.github.io/posts/363ae6cf/</id>
    <published>2022-10-13T14:34:46.000Z</published>
    <updated>2022-10-14T09:17:49.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>处理边界情况<br>访问元素 &amp; 组件<br>在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。<br>访问根实例<br>在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。<br>例如，在这个根实例中：<br>&#x2F;&#x2F; Vue 根实例<br>new Vue({<br>  data: {<br>    foo: 1<br>  },<br>  computed: {<br>    bar: function () { &#x2F;* … <em>&#x2F; }<br>  },<br>  methods: {<br>    baz: function () { &#x2F;</em> … *&#x2F; }<br>  }<br>})<br>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。<br>&#x2F;&#x2F; 获取根组件的数据this.$root.foo<br>&#x2F;&#x2F; 写入根组件的数据this.$root.foo &#x3D; 2<br>&#x2F;&#x2F; 访问根组件的计算属性this.$root.bar<br>&#x2F;&#x2F; 调用根组件的方法this.$root.baz()<br>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。<br>扩展到中大型应用来说，强烈推荐使用 Vuex 来管理应用的状态。<br>访问父级组件实例<br>和 $root 类似，$parent property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。<br>另外在一些可能适当的时候，你需要特别地共享一些组件库。举个例子，在和 JavaScript API 进行交互而不渲染 HTML 的抽象组件内，诸如这些假设性的 Google 地图组件一样：<br><code>&lt;google-map&gt;</code><br>  <code>&lt;google-map-markers v-bind:places=&quot;iceCreamShops&quot;&gt;</code><br>  <code>&lt;/google-map-markers&gt;</code><br><code>&lt;/google-map&gt;</code><br>这个 <code>&lt;google-map&gt;</code> 组件可以定义一个 map property，所有的子组件都需要访问它。在这种情况下 <code>&lt;google-map-markers&gt;</code> 可能想要通过类似 this.$parent.getMap 的方式访问那个地图，以便为其添加一组标记。你可以在这里查阅这种模式。<br>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 <code>&lt;google-map-region&gt;</code> 组件，当 <code>&lt;google-map-markers&gt;</code> 在其内部出现的时候，只会渲染那个区域内的标记：<br><code>&lt;google-map&gt;</code><br>  <code>&lt;google-map-region v-bind:shape=&quot;cityBoundaries&quot;&gt;</code><br>    <code>&lt;google-map-markers v-bind:places=&quot;iceCreamShops&quot;&gt;&lt;/google-map-markers&gt;</code><br>  <code>&lt;/google-map-region&gt;&lt;/google-map&gt;</code><br>那么在 <code>&lt;google-map-markers&gt;</code> 内部你可能发现自己需要一些类似这样的 hack：<br>var map &#x3D; this.$parent.map || this.$parent.$parent.map<br>很快它就会失控。这也是我们针对需要向任意更深层级的组件提供上下文信息时推荐依赖注入的原因。<br>访问子组件实例或子元素<br>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。例如：<br><code>&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</code><br>现在在你已经定义了这个 ref 的组件里，你可以使用：<br>this.$refs.usernameInput<br>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 ref 提供对内部这个指定元素的访问，例如：<br><code>&lt;input ref=&quot;input&quot;&gt;</code><br>甚至可以通过其父级组件定义方法：<br>methods: {<br>  &#x2F;&#x2F; 用来从父级组件聚焦输入框<br>  focus: function () {<br>    this.$refs.input.focus()<br>  }<br>}<br>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：<br>this.$refs.usernameInput.focus()<br>当 ref 和 v-for 一起使用的时候，你得到的 ref 将会是一个包含了对应数据源的这些子组件的数组。<br>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。<br>依赖注入<br>在此之前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子：<br><code>&lt;google-map&gt;</code><br>  <code>&lt;google-map-region v-bind:shape=&quot;cityBoundaries&quot;&gt;</code><br>    <code>&lt;google-map-markers v-bind:places=&quot;iceCreamShops&quot;&gt;&lt;/google-map-markers&gt;</code><br>  <code>&lt;/google-map-region&gt;&lt;/google-map&gt;</code><br>在这个组件里，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 getMap 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 $parent property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。<br>provide 选项允许我们指定我们想要提供给后代组件的数据&#x2F;方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 getMap 方法：<br>provide: function () {<br>  return {<br>    getMap: this.getMap<br>  }<br>}<br>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的 property：<br>inject: [‘getMap’]<br>你可以在这里看到完整的示例。相比 $parent 来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变&#x2F;移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。<br>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：<br>祖先组件不需要知道哪些后代组件使用它提供的 property<br>后代组件不需要知道被注入的 property 来自哪里<br>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个 property 是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。<br>程序化的事件侦听器<br>现在，你已经知道了 $emit 的用法，它可以被 v-on 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：<br>通过 $on(eventName, eventHandler) 侦听一个事件<br>通过 $once(eventName, eventHandler) 一次性侦听一个事件<br>通过 $off(eventName, eventHandler) 停止侦听一个事件<br>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：<br>&#x2F;&#x2F; 一次性将这个日期选择器附加到一个输入框上&#x2F;&#x2F; 它会被挂载到 DOM 上。mounted: function () {<br>  &#x2F;&#x2F; Pikaday 是一个第三方日期选择器的库<br>  this.picker &#x3D; new Pikaday({<br>    field: this.$refs.input,<br>    format: ‘YYYY-MM-DD’<br>  })<br>},&#x2F;&#x2F; 在组件被销毁之前，&#x2F;&#x2F; 也销毁这个日期选择器。beforeDestroy: function () {<br>  this.picker.destroy()<br>}<br>这里有两个潜在的问题：<br>它需要在这个组件实例中保存这个 picker，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。<br>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。<br>你应该通过一个程序化的侦听器解决这两个问题：<br>mounted: function () {<br>  var picker &#x3D; new Pikaday({<br>    field: this.$refs.input,<br>    format: ‘YYYY-MM-DD’<br>  })</p><p>  this.$once(‘hook:beforeDestroy’, function () {<br>    picker.destroy()<br>  })<br>}<br>使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：<br>mounted: function () {<br>  this.attachDatepicker(‘startDateInput’)<br>  this.attachDatepicker(‘endDateInput’)<br>},methods: {<br>  attachDatepicker: function (refName) {<br>    var picker &#x3D; new Pikaday({<br>      field: this.$refs[refName],<br>      format: ‘YYYY-MM-DD’<br>    })</p><pre><code>this.$once(&#39;hook:beforeDestroy&#39;, function () &#123;  picker.destroy()&#125;)</code></pre><p>  }<br>}<br>注意，如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。在这个例子中，我们推荐创建一个可复用的<code>&lt;input-datepicker&gt;</code> 组件。<br>注意 Vue 的事件系统不同于浏览器的 EventTarget API。<br>尽管它们工作起来是相似的，但是 $emit、$on, 和 $off 并不是 dispatchEvent、addEventListener 和 removeEventListener 的别名。<br>循环引用<br>递归组件<br>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事：<br>name: ‘unique-name-of-my-component’<br>当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。<br>Vue.component(‘unique-name-of-my-component’, {<br>  &#x2F;&#x2F; …<br>})<br>稍有不慎，递归组件就可能导致无限循环：<br>name: ‘stack-overflow’,template: ‘<code>&lt;div&gt;&lt;stack-overflow&gt;``&lt;/stack-overflow&gt;&lt;/div&gt;</code>‘<br>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。<br>组件之间的循环引用<br>假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</p><p>  <span></span>  <tree-folder-contents :children="folder.children"/></p>还有一个 <tree-folder-contents> 组件，模板是这样的：<ul>  <li v-for="child in children">    <tree-folder v-if="child.children" :folder="child"/>    <span v-else></span>  </li></ul>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代和祖先——一个悖论！当通过 Vue.component 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。然而，如果你使用一个模块系统依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误：Failed to mount component: template or render function not defined.为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。”在我们的例子中，把 <tree-folder> 组件设为了那个点。我们知道那个产生悖论的子组件是 <tree-folder-contents> 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它：beforeCreate: function () {  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default}或者，在本地注册组件的时候，你可以使用 webpack 的异步 import：components: {  TreeFolderContents: () => import('./tree-folder-contents.vue')}这样问题就解决了！模板定义的替代品内联模板当 inline-template 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。<my-component inline-template>  <div>    <p>These are compiled as the component's own template.</p>    <p>Not parent's transclusion content.</p>  </div></my-component>内联模板需要定义在 Vue 所属的 DOM 元素内。不过，inline-template 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 <template> 元素来定义模板。X-Template另一个定义模板的方式是在一个 <script> 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如：<script type="text/x-template" id="hello-world-template">  <p>Hello hello hello</p></script>Vue.component('hello-world', {  template: '#hello-world-template'})x-template 需要定义在 Vue 所属的 DOM 元素外。这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。控制更新感谢 Vue 的响应式系统，它始终知道何时进行更新 (如果你用对了的话)。不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。强制更新如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。通过 v-once 创建低开销的静态组件渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来，就像这样：Vue.component('terms-of-service', {  template: `    <div v-once>      <h1>Terms of Service</h1>      ... a lot of static content ...    </div>  `})再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-动态组件和异步组件</title>
    <link href="https://superq314.github.io/posts/5de961e9/"/>
    <id>https://superq314.github.io/posts/5de961e9/</id>
    <published>2022-10-13T14:34:34.000Z</published>
    <updated>2022-10-14T09:17:54.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态组件 &amp; 异步组件<br>在动态组件上使用 keep-alive<br>我们之前曾经在一个多标签的界面中使用 is attribute 来切换不同的组件：<br><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。例如我们来展开说一说这个多标签界面：<br>PostsArchive<br>Cat Ipsum <br>Hipster Ipsum <br>Cupcake Ipsum <br>Click on a blog title to the left to view it. <br>你会注意到，如果你选择了一篇文章，切换到 Archive 标签，然后再切换回 Posts，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 currentTabComponent 实例。<br>重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p><!-- 失活的组件将会被缓存！--><keep-alive><p>  <code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;``&lt;/keep-alive&gt;</code><br>来看看修改后的结果：<br>PostsArchive<br>Cat Ipsum <br>Hipster Ipsum <br>Cupcake Ipsum <br>Click on a blog title to the left to view it. <br>现在这个 Posts 标签保持了它的状态 (被选中的文章) 甚至当它未被渲染时也是如此。你可以在这个示例查阅到完整的代码。<br>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部&#x2F;全局注册。<br>你可以在 API 参考文档查阅更多关于 <code>&lt;keep-alive&gt;</code> 的细节。<br>异步组件<br>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：<br>Vue.component(‘async-example’, function (resolve, reject) {<br>  setTimeout(function () {<br>    &#x2F;&#x2F; 向 <code>resolve</code> 回调传递组件定义<br>    resolve({<br>      template: ‘<code>&lt;div&gt;</code>I am async!<code>&lt;/div&gt;</code>‘<br>    })<br>  }, 1000)<br>})<br>如你所见，这个工厂函数会收到一个 resolve 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：<br>Vue.component(‘async-webpack-example’, function (resolve) {<br>  &#x2F;&#x2F; 这个特殊的 <code>require</code> 语法将会告诉 webpack<br>  &#x2F;&#x2F; 自动将你的构建代码切割成多个包，这些包<br>  &#x2F;&#x2F; 会通过 Ajax 请求加载<br>  require([‘.&#x2F;my-async-component’], resolve)<br>})<br>你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：<br>Vue.component(<br>  ‘async-webpack-example’,<br>  &#x2F;&#x2F; 这个动态导入会返回一个 <code>Promise</code> 对象。<br>  () &#x3D;&gt; import(‘.&#x2F;my-async-component’)<br>)<br>当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：<br>new Vue({<br>  &#x2F;&#x2F; …<br>  components: {<br>    ‘my-component’: () &#x3D;&gt; import(‘.&#x2F;my-async-component’)<br>  }<br>})<br>如果你是一个 Browserify 用户同时喜欢使用异步组件，很不幸这个工具的作者明确表示异步加载“并不会被 Browserify 支持”，至少官方不会。Browserify 社区已经找到了一些变通方案，这些方案可能会对已存在的复杂应用有帮助。对于其它的场景，我们推荐直接使用 webpack，以拥有内置的头等异步支持。<br>处理加载状态<br>2.3.0+ 新增<br>这里的异步组件工厂函数也可以返回一个如下格式的对象：<br>const AsyncComponent &#x3D; () &#x3D;&gt; ({<br>  &#x2F;&#x2F; 需要加载的组件 (应该是一个 <code>Promise</code> 对象)<br>  component: import(‘.&#x2F;MyComponent.vue’),<br>  &#x2F;&#x2F; 异步组件加载时使用的组件<br>  loading: LoadingComponent,<br>  &#x2F;&#x2F; 加载失败时使用的组件<br>  error: ErrorComponent,<br>  &#x2F;&#x2F; 展示加载时组件的延时时间。默认值是 200 (毫秒)<br>  delay: 200,<br>  &#x2F;&#x2F; 如果提供了超时时间且组件加载也超时了，<br>  &#x2F;&#x2F; 则使用加载失败时使用的组件。默认值是：<code>Infinity</code><br>  timeout: 3000<br>})<br>注意如果你希望在 Vue Router 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-自定义组件</title>
    <link href="https://superq314.github.io/posts/272de8cd/"/>
    <id>https://superq314.github.io/posts/272de8cd/</id>
    <published>2022-10-13T14:34:21.000Z</published>
    <updated>2022-10-14T09:17:58.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自定义事件<br>事件名<br>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：<br>this.$emit(‘myEvent’)<br>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p><!-- 没有效果 --><p><code>&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code><br>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。<br>因此，我们推荐你始终使用 kebab-case 的事件名。<br>自定义组件的 v-model<br>2.2.0+ 新增<br>一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：<br>Vue.component(‘base-checkbox’, {<br>  model: {<br>    prop: ‘checked’,<br>    event: ‘change’<br>  },<br>  props: {<br>    checked: Boolean<br>  },<br>  template: <code>  &lt;input       type=&quot;checkbox&quot;       v-bind:checked=&quot;checked&quot;       v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;     &gt;</code><br>})<br>现在在这个组件上使用 v-model 的时候：<br><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code><br>这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 change事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。<br>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。<br>将原生事件绑定到组件<br>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符：<br><code>&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;</code><br>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：<br><code>&lt;label&gt;</code><br>  <br>  &lt;input<br>    v-bind&#x3D;”$attrs”<br>    v-bind:value&#x3D;”value”<br>    v-on:input&#x3D;”$emit(‘input’, $event.target.value)”</p></label>这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。为了解决这个问题，Vue 提供了一个 $listeners property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：{  focus: function (event) { /* ... */ }  input: function (value) { /* ... */ },}有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：Vue.component('base-input', {  inheritAttrs: false,  props: ['label', 'value'],  computed: {    inputListeners: function () {      var vm = this      // `Object.assign` 将所有的对象合并为一个新对象      return Object.assign({},        // 我们从父级添加所有的监听器        this.$listeners,        // 然后我们添加自定义监听器，        // 或覆写一些监听器的行为        {          // 这里确保组件配合 `v-model` 的工作          input: function (event) {            vm.$emit('input', event.target.value)          }        }      )    }  },  template: `    <label>            <input        v-bind="$attrs"        v-bind:value="value"        v-on="inputListeners"      >    </label>  `})现在 <base-input> 组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 <input> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 .native 监听器。.sync 修饰符2.3.0+ 新增在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：this.$emit('update:title', newTitle)然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：<text-document  v-bind:title="doc.title"  v-on:update:title="doc.title = $event"></text-document>为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：<text-document v-bind:title.sync="doc.title"></text-document>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 v-model。当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：<text-document v-bind.sync="doc"></text-document>这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-Prop</title>
    <link href="https://superq314.github.io/posts/56c3872d/"/>
    <id>https://superq314.github.io/posts/56c3872d/</id>
    <published>2022-10-13T14:34:09.000Z</published>
    <updated>2022-10-14T09:18:12.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Prop<br>Prop 的大小写 (camelCase vs kebab-case)<br>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：<br>Vue.component(‘blog-post’, {<br>  &#x2F;&#x2F; 在 JavaScript 中是 camelCase 的<br>  props: [‘postTitle’],<br>  template: ‘<code>&lt;h3&gt;</code><code>&lt;/h3&gt;</code>‘<br>})</p><!-- 在 HTML 中是 kebab-case 的 --><p><code>&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</code><br>重申一次，如果你使用字符串模板，那么这个限制就不存在了。<br>Prop 类型<br>到这里，我们只看到了以字符串数组形式列出的 prop：<br>props: [‘title’, ‘likes’, ‘isPublished’, ‘commentIds’, ‘author’]<br>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：<br>props: {<br>  title: String,<br>  likes: Number,<br>  isPublished: Boolean,<br>  commentIds: Array,<br>  author: Object,<br>  callback: Function,<br>  contactsPromise: Promise &#x2F;&#x2F; or any other constructor<br>}<br>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。<br>接下来是类型检查和其它 prop 验证。<br>传递静态或动态 Prop<br>给 prop 传入一个静态的值：<br><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code><br> prop 可以通过 v-bind 动态赋值，例如：</p><!-- 动态赋予一个变量的值 --><p><code>&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 动态赋予一个复杂表达式的值 --><p>&lt;blog-post<br>  v-bind:title&#x3D;”post.title + ‘ by ‘ + post.author.name”</p><blockquote></blog-post></blockquote><p>任何类型的值都可以传给一个 prop。<br>传入一个数字</p><!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个布尔值</p><!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--><p><code>&lt;blog-post is-published&gt;&lt;/blog-post&gt;</code></p><!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个数组</p><!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p><code>&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</code></p><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:comment-ids=&quot;post.commentIds&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个对象</p><!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --><!-- 这是一个 JavaScript 表达式而不是一个字符串。--><p>&lt;blog-post<br>  v-bind:author&#x3D;”{<br>    name: ‘Veronica’,<br>    company: ‘Veridian Dynamics’<br>  }”</p><blockquote></blog-post></blockquote><!-- 用一个变量进行动态赋值。--><p><code>&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;</code><br>传入一个对象的所有 property<br>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：<br>post: {<br>  id: 1,<br>  title: ‘My Journey with Vue’<br>}<br>下面的模板：<br><code>&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;</code><br>等价于：<br>&lt;blog-post<br>  v-bind:id&#x3D;”post.id”<br>  v-bind:title&#x3D;”post.title”</p><blockquote></blog-post></blockquote><p>单向数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样防止子组件意外变更父级组件的状态，从而导致应用的数据流向难以理解。<br>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>这里有两种常见的试图变更一个 prop 的情形：</p><ol><li>prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：<br>props: [‘initialCounter’],<br>data: function () {<br>return {<br>counter: this.initialCounter<br>}<br>}</li><li>这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：<br>props: [‘size’],<br>computed: {<br>normalizedSize: function () {<br>return this.size.trim().toLowerCase()<br>}<br>}<br>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。<br>Prop 验证<br>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。<br>为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：<br>Vue.component(‘my-component’, {<br>props: {<br>&#x2F;&#x2F; 基础的类型检查 (<code>null</code> 和 <code>undefined</code> 会通过任何类型验证)<br>propA: Number,<br>&#x2F;&#x2F; 多个可能的类型<br>propB: [String, Number],<br>&#x2F;&#x2F; 必填的字符串<br>propC: {<br>type: String,<br>required: true<br>},<br>&#x2F;&#x2F; 带有默认值的数字<br>propD: {<br>type: Number,<br>default: 100<br>},<br>&#x2F;&#x2F; 带有默认值的对象<br>propE: {<br>type: Object,<br>&#x2F;&#x2F; 对象或数组默认值必须从一个工厂函数获取<br>default: function () {<br>return { message: ‘hello’ }<br>}<br>},<br>&#x2F;&#x2F; 自定义验证函数<br>propF: {<br>validator: function (value) {<br>&#x2F;&#x2F; 这个值必须匹配下列字符串中的一个<br>return [‘success’, ‘warning’, ‘danger’].indexOf(value) !&#x3D;&#x3D; -1<br>}<br>}<br>}<br>})<br>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。<br>注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。<br>类型检查<br>type 可以是下列原生构造函数中的一个：<br>String<br>Number<br>Boolean<br>Array<br>Object<br>Date<br>Function<br>Symbol<br>额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数：<br>function Person (firstName, lastName) {<br>this.firstName &#x3D; firstName<br>this.lastName &#x3D; lastName<br>}<br>你可以使用：<br>Vue.component(‘blog-post’, {<br>props: {<br>author: Person<br>}<br>})<br>来验证 author prop 的值是否是通过 new Person 创建的。<br>非 Prop 的 Attribute<br>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。<br>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。<br>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上：<br><code>&lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;</code><br>然后这个 data-date-picker&#x3D;”activated” attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。<br>替换&#x2F;合并已有的 Attribute<br>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：<br><code>&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</code><br>为了给日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：<br>&lt;bootstrap-date-input<br>data-date-picker&#x3D;”activated”<br>class&#x3D;”date-picker-theme-dark”</li></ol><blockquote></bootstrap-date-input></blockquote><p>在这种情况下，我们定义了两个不同的 class 的值：<br>form-control，这是在组件的模板内设置好的<br>date-picker-theme-dark，这是从组件的父级传入的<br>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type&#x3D;”text” 就会替换掉 type&#x3D;”date” 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。<br>禁用 Attribute 继承<br>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如：<br>Vue.component(‘my-component’, {<br>  inheritAttrs: false,<br>  &#x2F;&#x2F; …<br>})<br>这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：<br>{<br>  required: true,<br>  placeholder: ‘Enter your username’<br>}<br>有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的：<br>Vue.component(‘base-input’, {<br>  inheritAttrs: false,<br>  props: [‘label’, ‘value’],<br>  template: <code>  &lt;label&gt;       &#123;&#123; label &#125;&#125;       &lt;input         v-bind=&quot;$attrs&quot;         v-bind:value=&quot;value&quot;         v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;       &gt;     &lt;/label&gt;</code><br>})<br>注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。<br>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：<br>&lt;base-input<br>  v-model&#x3D;”username”<br>  required<br>  placeholder&#x3D;”Enter your username”</p><blockquote></base-input></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化-插槽slot</title>
    <link href="https://superq314.github.io/posts/68dc4785/"/>
    <id>https://superq314.github.io/posts/68dc4785/</id>
    <published>2022-10-13T14:33:44.000Z</published>
    <updated>2022-10-14T09:17:30.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>vue中的代码slot是什么呢，它叫插槽，<code>&lt;slot&gt;</code>元素作为组件模板之中的内容分发插槽，传入内容后 <code>&lt;slot&gt;</code>元素自身将被替换。<br>v-slot用法：<br>1.默认插槽<br>2.具名插槽<br>3.作用域插槽<br>4.slot以及slot-scope的用法：子组件编写，父组件编写</p><h2 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h2><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。<br>它允许你像这样合成组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至其它的组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>&lt;navigation-link&gt;</code> 的 template 中没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>当你想在一个插槽中使用数据时，例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Logged in as </span><span class="template-variable">&#123;&#123; <span class="name">user.name</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 <code>&lt;navigation-link&gt;</code> 的作用域。例如 url 是访问不到的：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Clicking here will send you to: </span><span class="template-variable">&#123;&#123; <span class="name">url</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>作为一条规则，请记住：<br>父级模板里的所有内容都是在父级作用域中编译的；<br>子模板里的所有内容都是在子作用域中编译的。</p><h2 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h2><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：<br><code>&lt;submit-button&gt;&lt;/submit-button&gt;</code><br>后备内容“Submit”将会被渲染：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果我们提供内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;submit-button&gt;</span></span><br><span class="line">  <span class="attribute">Save</span></span><br><span class="line"><span class="section">&lt;/submit-button&gt;</span></span><br></pre></td></tr></table></figure><p>则这个提供的内容将会被渲染从而取代后备内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Save</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=&quot;<span class="symbol">container</span>&quot;&gt;</span><br><span class="line">  &lt;<span class="symbol">header</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span> <span class="symbol">name</span>=&quot;<span class="symbol">header</span>&quot;&gt;&lt;/他<span class="symbol">lot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">header</span>&gt;</span><br><span class="line">  &lt;<span class="symbol">main</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span>&gt;&lt;/<span class="symbol">slot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">main</span>&gt;</span><br><span class="line">  &lt;<span class="symbol">footer</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">slot</span> <span class="symbol">name</span>=&quot;<span class="symbol">footer</span>&quot;&gt;&lt;/<span class="symbol">slot</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">footer</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure><p>一个不带 name 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。<br>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。<br>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code> 中包裹默认插槽的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>任何一种写法都会渲染出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 v-slot 只能添加在 <code>&lt;template&gt;</code> 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>自 2.6.0 起有所更新。已废弃的使用 slot-scope attribute 的语法在这里。<br>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">user.lastName</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 user 而我们提供的内容是在父级渲染的。<br>为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">user.lastName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。</p><h3 id="独占默认插槽的缩写语法"><a href="#独占默认插槽的缩写语法" class="headerlink" title="独占默认插槽的缩写语法"></a>独占默认插槽的缩写语法</h3><p>在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 无效，会导致警告 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    slotProps is NOT available here</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="解构插槽-Prop"><a href="#解构插槽-Prop" class="headerlink" title="解构插槽 Prop"></a>解构插槽 Prop</h3><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="params">(slotProps)</span> &#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (单文件组件或现代浏览器)，你也可以使用 ES2015 解构来传入具体的插槽 prop，如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">person.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h2><p>2.6.0 新增<br>动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><p>2.6.0 新增<br>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="其它示例"><a href="#其它示例" class="headerlink" title="其它示例"></a>其它示例</h2><p>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 todo 作为一个插槽 prop 进行绑定：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    我们为每个 todo 准备了一个插槽，</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">v-bind:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-variable">&#123;&#123; <span class="name">todo.text</span> &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这只是作用域插槽用武之地的冰山一角。想了解更多现实生活中的作用域插槽的用法，我们推荐浏览诸如 Vue Virtual Scroller、Vue Promised 和 Portal Vue 等库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>完美极致的变量</title>
    <link href="https://superq314.github.io/posts/4df373ee/"/>
    <id>https://superq314.github.io/posts/4df373ee/</id>
    <published>2022-10-13T07:00:36.000Z</published>
    <updated>2022-10-13T11:10:36.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="完美极致的变量"><a href="#完美极致的变量" class="headerlink" title="完美极致的变量"></a>完美极致的变量</h3><p><strong>变量</strong>又名 <strong>自定义属性</strong> ，指可在整个文档中重复使用的值。它由自定义属性 <code>--var</code>和函数 <code>var()</code>组成，<code>var()</code>用于引用自定义属性。使用变量能带来以下好处。</p><ul><li>减少样式代码的重复性</li><li>增加样式代码的扩展性</li><li>提高样式代码的灵活性</li><li>增多一种CSS与JS的通讯方式</li><li>不用深层遍历DOM改变某个样式</li></ul><p>同时变量也是 <code>浏览器原生特性</code>，无需经过任何转译可直接运行，也是DOM对象，极大便利了CSS与JS间的联系。变量除了具备简洁性和复用性，在重构组件样式时能让代码更易控制，同时还隐藏了一个强大的技巧，那就是与 <code>calc()</code>结合使用。</p><p>看看一个简单的例子。一个条形加载条通常由几条线条组成，每条线条对应一个存在不同时延的相同动画，通过时间差运行相同动画，从而产生加载效果。估计大部分同学可能会把代码编写成以下形式。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d26b53bd008447348f046f9b381ccef0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="条形加载条"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;strip-loading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.strip-loading</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">        <span class="attribute">animation</span>: beat <span class="number">1s</span> ease-in-out infinite;</span><br><span class="line">        &amp; + <span class="selector-tag">li</span> &#123;</span><br><span class="line">            <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="attribute">animation-delay</span>: <span class="number">200ms</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="attribute">animation-delay</span>: <span class="number">400ms</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">            <span class="attribute">animation-delay</span>: <span class="number">600ms</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="attribute">animation-delay</span>: <span class="number">800ms</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;<span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">            <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> beat &#123;</span><br><span class="line">    <span class="number">0%</span>,</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析代码发现，每个 <code>&lt;li&gt;</code>只是 <code>animation-delay</code>不同，其余代码则完全相同，换成其他类似的 <strong>List集合</strong> ，那岂不是有10个 <code>&lt;li&gt;</code>就写10个 <code>:nth-child(n)</code>。显然这种方式不灵活也不易封装成组件，若能像JS那样封装成一个函数，并根据参数输出不同样式效果，那就更棒了。</p><p>对于HTML部分的修改，让每个 <code>&lt;li&gt;</code>拥有一个自己作用域下的变量。对于CSS部分的修改，就需分析哪些属性是随着 <code>index</code>递增而发生规律变化的，对规律变化的部分使用变量表达式代替即可。当然以下 <code>&lt;li style=&quot;--line-index: n;&quot;&gt;&lt;/li&gt;</code>可用 <code>React JSX</code>或 <code>Vue Template</code>的遍历语法编写。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;strip-loading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 1;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 2;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 3;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 4;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 5;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 6;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.strip-loading</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attr">--time</span>: <span class="built_in">calc</span>((<span class="built_in">var</span>(--line-index) - <span class="number">1</span>) * <span class="number">200ms</span>);</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">        <span class="attribute">animation</span>: beat <span class="number">1.5s</span> ease-in-out <span class="built_in">var</span>(--time) infinite;</span><br><span class="line">        &amp; + <span class="selector-tag">li</span> &#123;</span><br><span class="line">            <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> beat &#123;</span><br><span class="line">    <span class="number">0%</span>,</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的变量 <code>--line-index</code>和 <code>--time</code>使每个 <code>&lt;li&gt;</code>拥有一个属于自己的作用域。例如第二个 <code>&lt;li&gt;</code>，<code>--line-index</code>的值为2，<code>--time</code>的计算值为 <code>200ms</code>，换成第三个 <code>&lt;li&gt;</code>后这两个值又会不同了。这就是变量的作用范围所致(<code>在当前节点块作用域及其子节点块作用域下有效</code>)。</p><p><code>calc(var(--line-index) * 200ms)</code>就像一个JS函数，在当前节点的作用域上读取相应的变量，从而计算出具体数值并交由浏览器初始化。从中可得出一个技巧： <strong>List集合里具备与索引递增相关的属性值都可用变量与 <code>calc()</code>结合使用生成出来</strong> 。</p><p>还记得小学时代学习圆周率的场景吗，曾经有学者将一个圆形划分为很多很小的矩形，若这些矩形划分得足够细，那么也可拼在一起变成一个圆形。</p><p>将圆形划分为360个小矩形且每个矩形相对于父容器绝对定位，声明 <code>transform-origin</code>为 <code>center bottom</code>将小矩形的变换基准变更为 <code>最底部最中间</code>，每个小矩形按照递增角度顺时针旋转N度，就会形成一个圆形。此时按照递增角度调整小矩形的背景色相，就会看到意想不到的渐变效果了。</p><ul><li>每个小矩形的递增角度：<code>--Θ:calc(var(--line-index) / var(--line-count) * 1turn)</code></li><li>每个小矩形的背景色相：<code>filter:hue-rotate(var(--Θ))</code></li><li>每个小矩形的旋转角度：<code>transform:rotate(var(--Θ))</code></li></ul><p>若将小矩形的尺寸和数量设置更细更多，整体的渐变效果就会更均匀。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cefc7b8fd45477c8b7d171ef185d97f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="渐变圆形"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;gradient-circular&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--line-count: 360;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 1;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;--line-index: 360;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 360个&lt;li&gt;，可用模板语法生成  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.gradient-circular</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        --Θ: <span class="built_in">calc</span>(<span class="built_in">var</span>(--line-index) / <span class="built_in">var</span>(--line-count) * <span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#3c9</span>;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="built_in">var</span>(--Θ));</span><br><span class="line">        <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="built_in">var</span>(--Θ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="CSS" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>promise面试题</title>
    <link href="https://superq314.github.io/posts/5f68450a/"/>
    <id>https://superq314.github.io/posts/5f68450a/</id>
    <published>2022-10-13T03:15:53.000Z</published>
    <updated>2022-10-13T11:10:36.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>同步代码块是从上往下执行的</li><li>当我们 new 一个 Promise 时，里面的起始函数会立即调用，而且里面的代码块是同步代码<br>代码输出结果为：<code>1 2 3</code></li></ul><h2 id="出现异步代码"><a href="#出现异步代码" class="headerlink" title="出现异步代码"></a>出现异步代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conse p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这部分代码中，出现了一段异步代码：也就是 .then() 中的回调函数</p><p>要记住一个原则：同步先行，异步靠后，Javascript 引擎总是先执行同步代码，然后在执行异步代码。</p><p>此时，我们只需要区分同步代码和异步代码即可。</p><p>代码输出结果为：<code>start 1 end 2</code></p><h2 id="有-resolve-的地方"><a href="#有-resolve-的地方" class="headerlink" title="有 resolve 的地方"></a>有 resolve 的地方</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;strt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码与前面的代码基本一致，唯一区别是在 resolve() 之后有一个 console.log()</p><p>要记住：resolve 方法不会中断函数的执行，它背后的代码仍然会继续执行。</p><p>代码输出结果为：<code>start 1 3 end 2</code></p><h2 id="不被调用-resolve-的地方"><a href="#不被调用-resolve-的地方" class="headerlink" title="不被调用 resolve 的地方"></a>不被调用 resolve 的地方</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这段代码中，resolve 方法从未被调用过，因此 p始终处于挂起状态 。 所以 p.then(…) 从未被执行过，故不会在控制台中打印。</p><p>代码输出结果为：<code>start 1 end</code></p><h2 id="带有函数的"><a href="#带有函数的" class="headerlink" title="带有函数的"></a>带有函数的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码部分人开起来可能会有些迷惑，因为加了一层 fn</p><p>但我们要要记住，无论有多少层函数调用，我们的基本原则都是一样的：</p><ul><li>同步先行，异步靠后</li><li>同步代码按照调用顺序执行</li></ul><p>代码输出结果为：<code>start 3 1 end 2</code></p><p>详细解析：</p><p>首先，第一步输出 start ，相信大家都没什么疑问。<br>fn 是一个函数，里面返回的是一个 new Promise 对象，new Promise 对象中的回调函数会立即执行，但由于此时 fn 函数还未调用，故先不执行。<br>接下来输出 3<br>下一行代码 fn() 函数调用，所以立即 打印 1<br>调用 resolve() 方法，这是一个异步代码，作为异步，需要等到同步代码执行完成后才会执行，故打印 end<br>同步代码全部执行完成后，执行异步代码， 打印 2<br>所以输出结果为 start 3 1 end 2</p><h2 id="Fulfilling-Promise"><a href="#Fulfilling-Promise" class="headerlink" title="Fulfilling Promise"></a>Fulfilling Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>代码输出结果为：<code>start end 1 2</code></p><p>详细解析：</p><p>首先，我们要明白 Promise.resolve(1) 这行代码<br>Promise.resolve方法返回一个promise的实例，状态为已完成<br>这行代码等价于：<br>new Promise((resolve) &#x3D;&gt; { resolve(1) })<br>看到这里，是不是就明白了？<br>Promise.resolve(1) 是同步代码，但后面的 then() 是异步<br>所以输出结果为： start end 1 2</p><h2 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 微任务"></a>宏任务 微任务</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>详细解析：</p><p>这段代码相比较上一个来说，多了一个定时器，我们知道，定时器也是一个异步操作。那么这时候问题就来了，同步代码是按照调用顺序执行的，那么异步回调函数时按照什么顺序执行的呢？大家可以参考下我的上一篇博客：Promise原理解析及执行顺序。</p><p>在上面的代码中，setTimeout的定时器是0秒，Promise.resolve() 也会在执行后立即返回一个已完成的 Promise 对象。</p><p>两个异步任务都是立即完成的，那么谁的回调函数会先执行呢？</p><p>有人会说 setTimeout 在前面，所以先打印 setTimeout，然后打印 resolve，实际上，当我们在控制台运行下代码时会发现，实际情况并不是我们想的那样。</p><p>它们是有优先级的。</p><p>微任务 &gt; 宏任务</p><ul><li>具有较高优先级的任务叫做微任务。包括：Promise、ObjectObserver、MutationObserver、Process.nextTick、async&#x2F;await。</li><li>优先级较低的任务称为宏任务。包括：setTimeout、setInterval、XHR</li></ul><p>虽然 setTimeout 和 Promise.resolve() 是同时完成的，甚至 setTimeout 的代码写在前面，但是由于它的优先级较低，所以它的回调函数是在后面执行的。</p><p>代码输出结果为：<code>start end resolve success</code></p><h2 id="微任务-宏任务-升级"><a href="#微任务-宏任务-升级" class="headerlink" title="微任务 + 宏任务 升级"></a>微任务 + 宏任务 升级</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timerStart&#x27;</span>)</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;resolve&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timerEnd&#x27;</span>)</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>详细解析：</p><p>首先执行同步代码： 1 2 end</p><p>然后找到 微任务 和 宏任务</p><p>从上一个代码解析中我们知道，定时器是宏任务，Promise 是微任务：</p><p>但这里有一个陷阱： 当前的promise 还处于 pending 状态，所以promise.then() 这部分代码（微任务）暂时不会被执行。</p><p>所以会先执行定时器中的回调函数，然后在执行微任务。</p><p>代码输出结果为：<code>1 2 end timerStart timerEnd resolve</code></p><h2 id="微任务-宏任务-交替执行排序"><a href="#微任务-宏任务-交替执行排序" class="headerlink" title="微任务 宏任务 交替执行排序"></a>微任务 宏任务 交替执行排序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>详细解析：</p><p>关于 宏任务 和 微任务，正确的理解是：</p><ol><li>首先执行所有的微任务</li><li>执行宏任务</li><li>再次执行所有（新添加的）微任务</li><li>执行下一个宏任务</li></ol><p>在上面代码中，没有和宏任务同步的微任务，所以开始执行 timer1 这个宏任务；</p><p>在 timer1 的宏任务中，新增了一个微任务，且该promise 对象的状态已经变为 fufilled（已成功），所以Promise.then() 的回调函数会在第二个宏任务 setTimeout 的回调函数之前执行。</p><p>代码输出结果为：<code>timer1 promise1 tiemr2</code></p><h2 id="最终升级版"><a href="#最终升级版" class="headerlink" title="最终升级版"></a>最终升级版</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果能够正确写出答案且能说明原因的话，说明你对 Promise 的理解已经很强了，面试基本上没有问题。</p><p>详细解析:</p><p>按照以下思路进行思考：</p><ol><li><p>同步代码</p></li><li><p>所有微任务</p></li><li><p>第一个宏任务</p></li><li><p>所有新添加的微任务</p></li><li><p>下一个宏任务</p></li><li><p>…</p></li><li><p>执行所有同步代码<br>打印 start end</p></li><li><p>执行所有微任务<br><img src="/image/promise%E9%9D%A2%E8%AF%95%E9%A2%98/1665631067922.png" alt="1665631067922"><br>打印 promise1</p></li><li><p>执行第一个宏任务<br><img src="/image/promise%E9%9D%A2%E8%AF%95%E9%A2%98/1665631073786.png" alt="1665631073786"><br>打印 timer1</p></li></ol><p>注意：在这一步中，宏任务将一个新的为任务添加到任务队列中</p><ol start="4"><li><p>执行所有新添加的微任务<br><img src="/image/promise%E9%9D%A2%E8%AF%95%E9%A2%98/1665631079929.png" alt="1665631079929"><br>打印 promise2</p></li><li><p>执行下一个宏任务<br><img src="/image/promise%E9%9D%A2%E8%AF%95%E9%A2%98/1665631085376.png" alt="1665631085376"><br>打印 timer2</p></li></ol><p>代码输出结果为：start end promise1 timer1 promise2 timer2</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>记住三个核心要点，问题即可迎刃而解。</p><ol><li>JavaScript 引擎总是先执行同步代码，然后在执行异步代码（同步先行，异步靠后）</li><li>微任务的优先级高于宏任务</li><li>微任务可以在 Event Loop 中插队。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue高级-前后端分离</title>
    <link href="https://superq314.github.io/posts/4eac5812/"/>
    <id>https://superq314.github.io/posts/4eac5812/</id>
    <published>2022-10-13T03:07:34.000Z</published>
    <updated>2022-10-14T09:13:11.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装Nodejs服务器。-注意-不要安装到中文目录下"><a href="#安装Nodejs服务器。-注意-不要安装到中文目录下" class="headerlink" title="安装Nodejs服务器。[注意:不要安装到中文目录下]"></a>安装Nodejs服务器。[注意:不要安装到中文目录下]</h2><p>验证是否安装完成:   node –version<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630519420.png" alt="1665630519420"></p><ol><li><p>安装npm<br>因为前端项目也需要依赖一些插件:比如:axios elementui 那么可以使用npm下载并安装到当前项目。</p><p>但无需安装因为在nodejs中默认带了该软件<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630527706.png" alt="1665630527706"></p></li><li><p>安装vue的脚手架<br>脚手架的作用:就是用来帮你创建前端vue工程。</p><p>安装的命令: npm install -g @vue&#x2F;cli<br>速度很慢</p><p>查看vue脚手架版本:  vue -V<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630545635.png" alt="1665630545635"></p></li></ol><h2 id="使用脚手架创建Vue工程"><a href="#使用脚手架创建Vue工程" class="headerlink" title="使用脚手架创建Vue工程"></a>使用脚手架创建Vue工程</h2><ol><li>在cmd窗口中输入   vue ui<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630553214.png" alt="1665630553214"></li><li>创建<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630563172.png" alt="1665630563172"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630574262.png" alt="1665630574262"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630581169.png" alt="1665630581169"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630587995.png" alt="1665630587995"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630595335.png" alt="1665630595335"><br>创建完成后<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630612029.png" alt="1665630612029"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630603882.png" alt="1665630603882"></li><li>安装需要的插件和依赖<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630657614.png" alt="1665630657614"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630663107.png" alt="1665630663107"></li><li>安装axios发送异步请求的依赖<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630669720.png" alt="1665630669720"></li></ol><h2 id="webstorm打开vue工程"><a href="#webstorm打开vue工程" class="headerlink" title="webstorm打开vue工程"></a>webstorm打开vue工程</h2><p>关联:npm命令<br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630678298.png" alt="1665630678298"><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630686786.png" alt="1665630686786"></p><p>整个项目中node_modules占用项目的空间99%。以后拿到的项目一定没有node_modules。需要自己在本地安装。<br><code>npm install  -- 安装项目需要的模块</code><br><code>npm run serve  --运行项目 nodejs</code><br><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630700736.png" alt="1665630700736"></p><h2 id="聊聊main-js"><a href="#聊聊main-js" class="headerlink" title="聊聊main.js"></a>聊聊main.js</h2><p><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630715989.png" alt="1665630715989"></p><p>一个组件引用另一个组件:</p><ol><li>当前组件中导入另一个组件</li></ol><p><code>import hello from &#39;./components/Hello.vue&#39;</code></p><ol start="2"><li>注册另一个组件</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">    <span class="comment">// 注册组件</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用注册的组件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用组件--&gt;</span></span><br><span class="line">`<span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span>`</span><br></pre></td></tr></table></figure><h2 id="说说路由"><a href="#说说路由" class="headerlink" title="说说路由"></a>说说路由</h2><p><img src="/image/Vue%E9%AB%98%E7%BA%A7%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/1665630728190.png" alt="1665630728190"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="深入Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E6%B7%B1%E5%85%A5Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Vue-生命周期</title>
    <link href="https://superq314.github.io/posts/8002737b/"/>
    <id>https://superq314.github.io/posts/8002737b/</id>
    <published>2022-10-13T03:03:27.000Z</published>
    <updated>2022-10-14T09:13:54.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/image/%E5%88%9D%E8%AF%86Vue%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1665630371205.png" alt="1665630371205"></p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>组件的data和methods以及页面DOM结构都还没有初始化，所以这里什么都做不了</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>此时，组件的data和methods可用。但页面还没被渲染出来，在该函数中，我们经常会发起ajax请求</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>模板结构已经在内存中编译完成，但还没有真正渲染到页面上。页面上看不到真实的数据，能看到的只是一个模板而已</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>组件创建阶段的最后一个生命周期。此时，页面已经真正渲染好了，用户可以看到真实页面数据。</p><p>以上执行完，组件就离开了创建阶段，进入运行阶段。如果用到了一些第三方UI插件，必须在mounted中来初始化插件。</p><p>运行中的生命周期函数，会根据data数据的变化有选择性的触发0次或n次</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>此时数据是最新的，但页面上呈现的数据还是旧的</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>页面已经完成了更新，此时data数据是最新的，同时页面上呈现的数据也是最新的。</p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>执行该函数的时候，组件即将被销毁但还没有真正销毁，此时组件（data、methods等数据或方法）还可以正常用。</p><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>组件完成销毁，组件废了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/"/>
    
    <category term="初识Vue" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Vue/%E5%88%9D%E8%AF%86Vue/"/>
    
    
  </entry>
  
</feed>
