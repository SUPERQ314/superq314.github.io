<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/a6ab0041a82fc211db50fce9d5b5aaa7</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://github.com/SUPERQ314/atom.xml" rel="self"/>
  
  <link href="https://github.com/SUPERQ314/"/>
  <updated>2022-05-02T12:49:24.127Z</updated>
  <id>https://github.com/SUPERQ314/</id>
  
  <author>
    <name>superQ</name>
    <email>1078857679@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络题</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-17T10:25:33.934Z</published>
    <updated>2022-05-02T12:49:24.127Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="HTTP-常用状态码及其含义"><a href="#HTTP-常用状态码及其含义" class="headerlink" title="HTTP-常用状态码及其含义"></a><strong>HTTP-常用状态码及其含义</strong></h3><table><thead><tr><th>状态码</th><th>类别</th></tr></thead><tbody><tr><td>1××</td><td>信息性状态码</td></tr><tr><td>2××</td><td>成功状态码</td></tr><tr><td>3××</td><td>重定向状态码</td></tr><tr><td>4××</td><td>客户端错误状态码</td></tr><tr><td>5××</td><td>服务端错误状态码</td></tr></tbody></table><h4 id="常用状态码的含义："><a href="#常用状态码的含义：" class="headerlink" title="常用状态码的含义："></a><strong>常用状态码的含义：</strong></h4><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>101</td><td>切换请求协议</td></tr><tr><td>200</td><td>请求成功</td></tr><tr><td>301</td><td>永久性重定向，会缓存</td></tr><tr><td>302</td><td>临时重定向，不会缓存</td></tr><tr><td>400</td><td>客户端请求的语法错误</td></tr><tr><td>403</td><td>服务器禁止访问，权限有关</td></tr><tr><td>404</td><td>服务器无法根据客户端的请求找资源</td></tr><tr><td>500</td><td>服务端错误</td></tr></tbody></table><h4 id="状态码-301和302的区别"><a href="#状态码-301和302的区别" class="headerlink" title="状态码-301和302的区别"></a><strong>状态码-301和302的区别</strong></h4><p>301和302都有重定向的含义，但有区别。</p><ul><li>301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</li><li>302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。</li></ul><h3 id="HTTP-常用的请求方式，区别和用途"><a href="#HTTP-常用的请求方式，区别和用途" class="headerlink" title="HTTP 常用的请求方式，区别和用途"></a><strong>HTTP 常用的请求方式，区别和用途</strong></h3><table><thead><tr><th>请求方式</th><th>用途</th></tr></thead><tbody><tr><td>get</td><td>对服务器资源获取的简单请求</td></tr><tr><td>post</td><td>用于发送包含用户提交数据的请求</td></tr><tr><td>put</td><td>向服务器提交数据，以修改数据</td></tr><tr><td>delete</td><td>删除服务器上的某些资源</td></tr><tr><td>head</td><td>请求页面的首部,获取资源的元信息</td></tr><tr><td>connect</td><td>用于ssl隧道的基于代理的请求</td></tr><tr><td>options</td><td>返回所有可用的方法，常用于跨域</td></tr><tr><td>trace</td><td>追踪请求-响应的传输路径</td></tr></tbody></table><h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a><strong>GET和POST的区别</strong></h4><p>从<strong>数据包、编码方式、请求参数、收藏为书签、历史记录、安全性</strong>等几方面回答。</p><table><thead><tr><th>请求方式</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>数据包</td><td>产生一个TCP数据包</td><td>可能产生两个TCP数据包</td></tr><tr><td>编码方式</td><td>只能进行url编码</td><td>支持多种编码方式</td></tr><tr><td>请求参数</td><td>把参数包含在URL中,用&amp;连接起来</td><td>通过request body传递参数</td></tr><tr><td>请求缓存</td><td>会被主动Cache</td><td>不会缓存,除非手动设置</td></tr><tr><td>收藏为书签</td><td>支持</td><td>不支持</td></tr><tr><td>历史记录</td><td>参数会被完整保留在浏览历史记录里</td><td>不会保留</td></tr><tr><td>参数数据类型</td><td>ASCII的字符</td><td></td></tr></tbody></table><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>XMLHttpRequest是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest在AJAX中被大量使用。</p><ul><li>使用XMLHttpRequest</li><li>POST方法，浏览器会先发送Header再发送Data。</li><li>GET方法，Header和Data会一起发送。</li></ul><h3 id="浏览器地址栏中输入url到显示主页的过程"><a href="#浏览器地址栏中输入url到显示主页的过程" class="headerlink" title="浏览器地址栏中输入url到显示主页的过程"></a><strong>浏览器地址栏中输入url到显示主页的过程</strong></h3><p>HTTP：基于TCP&#x2F;IP协议来传递数据的超文本传输协议，传输的数据类型有HTML,图片等。</p><p>HTTP的请求过程：<strong>DNS解析，TCP三次握手，四次挥手</strong></p><p>以访问百度为例，了解Http的请求过程</p><p><img src="https://pic2.zhimg.com/80/v2-989d1421fa6d46b8ad0a5f54086bc04d_720w.jpg"></p><ol><li>客户端进行DNS域名解析，查找域名对应的IP地址</li><li>根据这个IP地址，找到对应的服务器建立TCP连接（三次握手）</li><li>建立TCP连接后，向服务器发起HTTP请求（一个完整的HTTP请求报文）</li><li>服务器响应HTTP请求，客户端得到html代码</li><li>客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。</li><li>服务器关闭TCP连接（四次挥手）</li></ol><p><img src="https://pic3.zhimg.com/80/v2-8c33715beb25959e046b67ac23746dae_720w.jpg"></p><h4 id="DNS-域名解析过程"><a href="#DNS-域名解析过程" class="headerlink" title="DNS 域名解析过程"></a><strong>DNS 域名解析过程</strong></h4><blockquote><p>★ DNS，英文全称是<strong>domain name system</strong>，域名解析系统，是<strong>域名</strong>和<strong>IP地址</strong>相互映射的一个分布式数据库。</p><p>作用：根据域名查找对应的IP地址。</p></blockquote><p>DNS的解析过程如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-d2ec98abedf62400562a05893901665a_720w.jpg"></p><p>假设要查询<strong><a href="http://www.baidu.com/">http://www.baidu.com</a></strong>的IP地址:</p><ol><li>查找浏览器的缓存,寻找<strong><a href="http://www.baidu.com/">http://www.baidu.com</a></strong>对应的IP地址，找到就直接返回；否则进行下一步。</li><li>将请求发往给本地DNS服务器，如果找到，直接返回；否则进行下一步；</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器返回负责 <code>.com</code>的顶级域名服务器的IP地址的列表。</li><li>本地DNS服务器再向其中一个负责 <code>.com</code>的顶级域名服务器发送一个请求，返回负责 <code>.baidu</code>的权威域名服务器的IP地址列表。</li><li>本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回<strong><strong><a href="http://www.baidu.com/">http://www.baidu.com</a></strong></strong>所对应的IP地址。</li></ol><h3 id="端口号及对应服务"><a href="#端口号及对应服务" class="headerlink" title="端口号及对应服务"></a><strong>端口号及对应服务</strong></h3><table><thead><tr><th>端口</th><th>服务</th></tr></thead><tbody><tr><td>21</td><td>FTP(文件传输协议)</td></tr><tr><td>22</td><td>SSH</td></tr><tr><td>23</td><td>Telnet(远程登录)服务</td></tr><tr><td>25</td><td>SMTP(简单邮件传输协议)</td></tr><tr><td>53</td><td>DNS域名服务器</td></tr><tr><td>80</td><td>HTTP超文本传输协议</td></tr><tr><td>110</td><td>POP3邮件协议3</td></tr><tr><td>443</td><td>HTTPS</td></tr><tr><td>1080</td><td>Sockets</td></tr><tr><td>1521</td><td>Oracle数据库默认端口</td></tr><tr><td>3306</td><td>MySQL服务默认端口</td></tr></tbody></table><h3 id="HTTP-协议是无状态的，如何使它有状态"><a href="#HTTP-协议是无状态的，如何使它有状态" class="headerlink" title="HTTP 协议是无状态的，如何使它有状态"></a><strong>HTTP 协议是无状态的，如何使它有状态</strong></h3><p>无状态：</p><blockquote><p>★ 当浏览器第一次发送请求给服务器时，服务器响应了；</p><p>如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p><p>简言之，服务器不会去记住你是谁，所以是无状态协议。</p></blockquote><h3 id="HTTP-1-0-x2F-1-1-x2F-2-0"><a href="#HTTP-1-0-x2F-1-1-x2F-2-0" class="headerlink" title="HTTP-1.0&#x2F;1.1&#x2F;2.0"></a><strong>HTTP-1.0&#x2F;1.1&#x2F;2.0</strong></h3><p>主要考察：</p><ul><li><strong>HTTP-1.0</strong> 默认是短连接，可以强制开启</li><li><strong>HTTP-1.1</strong> 默认长连接</li><li><strong>HTTP-2.0 <strong>采用</strong>多路复用</strong></li></ul><p><strong>HTTP&#x2F;1.0</strong></p><ul><li>默认使用 <strong>短连接</strong> ，每次请求都需要建立一个TCP连接。它可以设置 <code>Connection: keep-alive</code> 这个字段，强制开启长连接。</li></ul><p><strong>HTTP&#x2F;1.1</strong></p><ul><li>引入 <strong>持久连接</strong>，即TCP连接默认不关闭，可以被多个请求复用。</li><li>分块传输编码，即服务端没产生一块数据，就发送一块，用”流模式”取代”缓存模式”。</li><li>管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。</li></ul><p><strong>HTTP&#x2F;2.0</strong></p><ul><li>二进制协议，1.1版本的头信息是文本（ASCII编码），数据体可以是文本或者二进制；2.0中，头信息和数据体都是二进制。</li><li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</li><li>报头压缩，HTTP协议不带有状态，每次请求都必须附上所有信息。Http&#x2F;2.0引入了头信息压缩机制，使用gzip或compress压缩后再发送。</li><li>服务端推送，允许服务器未经请求，主动向客户端发送资源。</li></ul><h3 id="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"><a href="#在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？" class="headerlink" title="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"></a><strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></h3><p>HTTP中，响应体的<strong>Connection</strong>字段指定为 <code>keep-alive</code></p><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a><strong>计算机网络体系结构</strong></h3><p>计算机网路体系结构，有三层：ISO七层模型、TCP&#x2F;IP四层模型、五层体系结构。</p><p><img src="https://pic3.zhimg.com/80/v2-c21d3ee1bd237370ea4a41e4bffab03a_720w.jpg"></p><h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a><strong>OSI 七层模型</strong></h4><p>OSI 七层模型是国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系。</p><ul><li>应用层：负责给应用程序提供统一的接口，协议有：<strong>HTTP、FTP、SMTP、SNMP、DNS</strong></li><li>表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层识别</li><li>会话层：建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的通信会话</li><li>传输层：负责端到端的数据传输，协议有 <strong>TCP、UDP</strong></li><li>网络层：负责数据的路由、转发、分片，协议有 <strong>ICMP、IGMP、IP</strong></li><li>数据链路层：负责数据的封帧和差错检测，以及 MAC 寻址</li><li>物理层：建立、维护、断开物理连接</li></ul><h4 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a><strong>TCP&#x2F;IP 四层模型</strong></h4><p>网络七层模型是一个标准，而非实现。</p><p>网络四层模型是一个实现的应用模型。</p><p>网络四层模型由七层模型简化合并而来。</p><ul><li>应用层：对应于<strong>OSI参考模型的应用层、表示层、会话层</strong>。</li><li>传输层: 对应<strong>OSI参考模型的传输层</strong>，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</li><li>网际层：对应于<strong>OSI参考模型的网络层</strong>，主要解决主机到主机的通信问题。</li><li>网络接口层：对应于<strong>OSI参考模型的数据链路层、物理层</strong>。</li></ul><h4 id="网络五层模型"><a href="#网络五层模型" class="headerlink" title="网络五层模型"></a><strong>网络五层模型</strong></h4><ul><li>应用层：对应于OSI参考模型的应用层、表示层、会话层</li><li>传输层：对应于OSI参考模型的传输层</li><li>网络层：对应于OSI参考模型的网络层</li><li>数据链路层：对应于OSI参考模型的数据链路层</li><li>物理层：对应于OSI参考模型的物理层</li></ul><h4 id="五层计算机网络体系结构中，每一层对应的网络协议"><a href="#五层计算机网络体系结构中，每一层对应的网络协议" class="headerlink" title="五层计算机网络体系结构中，每一层对应的网络协议"></a><strong>五层计算机网络体系结构中，每一层对应的网络协议</strong></h4><p><img src="https://pic1.zhimg.com/80/v2-16d4858be906057dee9dcb3c8a92780c_720w.jpg"></p><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a><strong>HTTP 与 HTTPS 的区别</strong></h3><p>从<strong>安全性</strong>、<strong>数据是否加密</strong>、<strong>默认端口</strong>等这几个方面回答。</p><p>HTTP：超文本传输协议，基于TCP&#x2F;IP通信协议来传递明文数据的协议。</p><p>HTTP会存在以下<strong>问题</strong> ：</p><ul><li>请求信息是明文传输，容易被窃听截取。</li><li>没有验证对方身份，存在被冒充的风险</li><li>数据的完整性未校验，容易被中间人篡改</li></ul><p>为了解决HTTP存在的问题，出现HTTPS。</p><p><strong>HTTPS：</strong></p><p><strong>HTTPS&#x3D; HTTP+SSL&#x2F;TLS</strong> ，可以理解HTTPS是身披SSL(Secure Socket Layer，安全套接层)的HTTP。</p><p>主要区别如下：</p><table><thead><tr><th></th><th>Http</th><th>Https</th></tr></thead><tbody><tr><td>安全性</td><td>不安全</td><td>安全</td></tr><tr><td>默认端口</td><td>80</td><td>443</td></tr><tr><td>资源消耗</td><td>较少</td><td>较多</td></tr><tr><td>是否需要证书</td><td>不需要</td><td>需要</td></tr><tr><td>报文是否加密</td><td>明文</td><td>加密</td></tr></tbody></table><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a><strong>HTTPS 工作流程</strong></h3><p><strong>公私钥、数字证书、加密、对称加密、非对称加密</strong></p><ul><li>HTTPS &#x3D; HTTP + SSL&#x2F;TLS，也就是用SSL&#x2F;TLS对数据进行加密和解密，Http进行传输。</li><li>SSL，即Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。</li><li>TLS，即Transport Layer Security(安全传输层协议)，它是SSL3.0的后续版本。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-6273d3dc5947ed3d0b17b3ddd32de725_720w.jpg"></p><ol><li>客户端发起HTTPS请求，连接到服务器的443端口。</li><li>服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li><li>服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li><li>客户端将公钥加密后的密钥发送到服务器。</li><li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li><li>服务器将加密后的密文返回到客户端。</li><li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li></ol><h3 id="数字签名-数字证书"><a href="#数字签名-数字证书" class="headerlink" title="数字签名  数字证书"></a><strong>数字签名  数字证书</strong></h3><p>HTTPS原理跟数字证书有关，需要掌握HTTPS原理。</p><p>数字证书：在互联网通讯中标志通讯各方身份信息的一个数字认证，在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。比如HTTPS的数字证书，就是为了避免公钥被中间人冒充篡改：</p><p><img src="https://pic3.zhimg.com/80/v2-82ff87bab5731fbb04980296e2b57682_720w.jpg"></p><p><strong>数字证书构成</strong></p><ul><li><strong>公钥</strong>和<strong>个人等信息</strong>，经过Hash摘要算法加密，形成<strong>消息摘要</strong></li><li>将<strong>消息摘要</strong>拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成 <strong>数字签名</strong></li><li><strong>公钥</strong>和<strong>个人信息</strong>、<strong>数字签名</strong>共同构成 <strong>数字证书</strong></li></ul><h3 id="对称加密与非对称加密的区别"><a href="#对称加密与非对称加密的区别" class="headerlink" title="对称加密与非对称加密的区别"></a><strong>对称加密与非对称加密的区别</strong></h3><p><strong>对称加密</strong>：加密和解密使用同一密钥</p><p>优点：运算速度较快</p><p>缺点：如何安全将密钥传输给另一方。</p><p>常见的对称加密算法：DES、AES等。</p><p><img src="https://pic4.zhimg.com/80/v2-7243afc7200a003e3dfe4eda131ee2e3_720w.jpg"></p><p><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。</p><p>常见的非对称加密算法：RSA。</p><p><img src="https://pic1.zhimg.com/80/v2-ca59e19646a1eb5a57a8d526e4ea3338_720w.jpg"></p><h3 id="WebSocket与socket的区别"><a href="#WebSocket与socket的区别" class="headerlink" title="WebSocket与socket的区别"></a><strong>WebSocket与socket的区别</strong></h3><ul><li><strong>Socket</strong> <strong>&#x3D;</strong> <strong>IP地址 + 端口 + 协议</strong></li></ul><blockquote><p>★ 具体来说，Socket是一套标准，它完成了对TCP&#x2F;IP的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p></blockquote><ul><li>WebSocket：持久化协议，伴随H5而出，用来解决<strong>HTTP不支持持久化连接</strong>的问题。</li><li>WebSocket：应用层通信协议</li><li>Socket：<strong>网编编程的标准接口</strong></li></ul><h3 id="forward和redirect的区别"><a href="#forward和redirect的区别" class="headerlink" title="forward和redirect的区别"></a><strong>forward和redirect的区别</strong></h3><ul><li><strong>直接转发方式（Forward）</strong>：客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li><li><strong>间接转发方式（Redirect）</strong>：实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</li></ul><p>看下这两个图，可以更容易理解一些:</p><ul><li>Redirect 的工作原理：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-5d056c03218601f9c1ceb039be486708_720w.jpg"></p><ul><li>forward 的工作原理</li></ul><p><img src="https://pic4.zhimg.com/80/v2-9d5646635cf3907b1c1cbfb01d3188bf_720w.jpg"></p><h3 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a><strong>Session和Cookie的区别</strong></h3><ul><li>Session：服务器和客户端一次会话的过程。Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。</li><li>Cookie：保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。</li></ul><p><strong>Session 和Cookie的区别主要有这些：</strong></p><table><thead><tr><th></th><th>Session</th><th>Cookie</th></tr></thead><tbody><tr><td>存放位置</td><td>服务器</td><td>客户端</td></tr><tr><td>存储数据类型</td><td>任意数据类型</td><td>ASCII</td></tr><tr><td>安全性</td><td>较高</td><td>较低</td></tr><tr><td>存储空间小</td><td>大</td><td>小</td></tr><tr><td>有效期</td><td>较短，超时或者客户端关闭都会失效</td><td>可设置长时间</td></tr></tbody></table><p>来看个图吧：</p><p><img src="https://pic4.zhimg.com/80/v2-3a0d423ac0c21b22f061d839afb8aab7_720w.jpg" alt="img"></p><ul><li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie中，同时Cookie记录此SessionID是属于哪个域名。</li><li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID查找对应的 Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。</li></ul><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a><strong>IP地址分类</strong></h3><p>IP地址&#x3D;网络号+主机号。</p><ol><li>网络号：标志主机所连接的网络地址表示属于互联网的哪一个网络。</li><li>主机号：标志主机地址表示其属于该网络中的哪一台主机。</li></ol><p>IP地址分为A，B，C，D，E五大类：</p><ul><li>A类地址(1~126)：以0开头，网络号占前8位，主机号占后面24位。</li><li>B类地址(128~191)：以10开头，网络号占前16位，主机号占后面16位。</li><li>C类地址(192~223)：以110开头，网络号占前24位，主机号占后面8位。</li><li>D类地址(224~239)：以1110开头，保留位多播地址。</li><li>E类地址(240~255)：以11110开头，保留位为将来使用</li></ul><p><img src="https://pic4.zhimg.com/80/v2-f376714d7166c8f6fe51532a1192894b_720w.jpg"></p><h3 id="IP地址和MAC地址的区别及各自作用"><a href="#IP地址和MAC地址的区别及各自作用" class="headerlink" title="IP地址和MAC地址的区别及各自作用"></a><strong>IP地址和MAC地址的区别及各自作用</strong></h3><p>IP 地址主要用来网络寻址用的，就是大致定位你在哪里</p><p>MAC 地址，则是身份的唯一象征，通过 MAC 来唯一确认这人是不是就是你，MAC 地址不具备寻址的功能。</p><h3 id="ARP-协议的工作过程"><a href="#ARP-协议的工作过程" class="headerlink" title="ARP 协议的工作过程"></a><strong>ARP 协议的工作过程</strong></h3><p>ARP 协议， <strong>Address Resolution Protocol</strong> ，地址解析协议，用于实现IP地址到MAC地址的映射。</p><ol><li>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。</li><li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址；如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</li><li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。</li><li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ol><h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a><strong>TCP 和 UDP</strong></h3><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a><strong>TCP和UDP的区别</strong></h4><p><strong>思路：</strong> 这道题，校招的时候，问的概率高点，概念性的东西， <strong>TCP是面向连接，而UDP是无连接</strong> 。</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>面向连接</td><td>面向无连接</td></tr><tr><td>是否可靠</td><td>可靠</td><td>不可靠</td></tr><tr><td>传输数据</td><td>有序</td><td>不保证无序性</td></tr><tr><td>传输速度</td><td>慢</td><td>快</td></tr><tr><td>数据边界</td><td>不保存</td><td>保留</td></tr><tr><td>报文格式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>适用场景</td><td>网页、邮件</td><td>语音、广播</td></tr></tbody></table><h4 id="TCP-和-UDP-分别对应的常见应用层协议"><a href="#TCP-和-UDP-分别对应的常见应用层协议" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议"></a><strong>TCP 和 UDP 分别对应的常见应用层协议</strong></h4><p><strong>基于可靠的TCP协议</strong></p><ul><li><strong>FTP</strong>：文件传输协议，默认端口(20用于传输数据，21用于传输控制信息)</li><li><strong>SSH</strong>：安全外壳协议，默认端口 22</li><li><strong>TELNET</strong>：远程登陆协议，默认端口23</li><li><strong>SMTP</strong>：简单邮件传输协议，默认端口25</li><li><strong>HTTP</strong>：超文本传输协议，默认端口80</li></ul><p><strong>基于不可靠的UDP协议</strong></p><ul><li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为 IP 地址，默认端口 53</li><li><strong>TFTP</strong>：简单文件传输协议，默认端口69</li><li><strong>SNMP</strong>：简单网络管理协议，用来管理网络设备的，通过UDP端口161接收，只有Trap信息采用UDP端口162。</li></ul><h4 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a><strong>TCP 和 UDP 应用场景</strong></h4><p>TCP 应用场景：</p><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。</p><p>UDP 应用场景：</p><p>效率要求相对高，对准确性要求相对低的场景。</p><h3 id="URI-和-URL-的区别"><a href="#URI-和-URL-的区别" class="headerlink" title="URI 和 URL 的区别"></a><strong>URI 和 URL 的区别</strong></h3><ul><li>URI，全称是Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。</li><li>URL，全称是Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。 打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</li></ul><h3 id="ICMP协议的功能"><a href="#ICMP协议的功能" class="headerlink" title="ICMP协议的功能"></a><strong>ICMP协议的功能</strong></h3><p>ICMP,Internet Control Message Protocol ,Internet控制消息协议。</p><ul><li>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。</li><li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li><li>当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</li></ul><p>比如我们日常使用得比较多的 <strong>ping</strong> ，就是基于ICMP的。</p><h3 id="说下ping的原理"><a href="#说下ping的原理" class="headerlink" title="说下ping的原理"></a><strong>说下ping的原理</strong></h3><blockquote><p>★ ping， <strong>Packet Internet Groper</strong> ，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP&#x2F;IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态<br>”</p></blockquote><p>一般来说，ping可以用来检测网络通不通。它是基于 <code>ICMP</code>协议工作的。假设<strong>机器A</strong> ping <strong>机器B</strong> ，工作过程如下：</p><ol><li>ping通知系统，新建一个固定格式的ICMP请求数据包</li><li>ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层</li><li>IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包</li><li>先获取目标机器B的MAC地址。</li><li>数据链路层构建一个数据帧，目的地址是IP层传过来的 <strong>MAC地址</strong> ，源地址是本机的<strong>MAC地址</strong></li><li>机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。</li><li>根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间</li><li>最终显示结果有这几项：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大&amp; 平均值</li></ol><h3 id="TCP-三次握手机制"><a href="#TCP-三次握手机制" class="headerlink" title="TCP 三次握手机制"></a><strong>TCP 三次握手机制</strong></h3><p>需要记住：通讯过程  客户端、服务器的对应状态</p><p>TCP提供可靠的连接服务，连接是通过三次握手进行初始化的。</p><p>三次握手的目的：同步连接双方的序列号和确认号并交换TCP窗口大小信息。</p><p>流程图：</p><p><img src="https://pic1.zhimg.com/80/v2-245b7a106bae594ff2a84d1a305a3764_720w.jpg"></p><p>刚开始客户端处于closed的状态，服务端处于listen状态。然后：</p><ul><li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号<strong>ISN(client)<strong>。此时客户端处于</strong>SYN_Send状态</strong>。</li><li>第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号<strong>ISN(server)<strong>，同时会把客户端的</strong>ISN ＋1</strong> &#x3D;&gt; <strong>ACK</strong>，表示自己已经收到了客户端的SYN，此时服务器处于<strong>SYN_RCVD****状态</strong>。</li><li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的<strong>ISN +1 &#x3D;&gt; ACK</strong>，表示已经收到了服务端的SYN报文，此时客户端处于<strong>established状态</strong>。</li><li>服务器收到ACK报文之后，也处于<strong>established状态</strong>，此时，双方以建立起了链接</li></ul><h4 id="为什么握手不能是两次呢？"><a href="#为什么握手不能是两次呢？" class="headerlink" title="为什么握手不能是两次呢？"></a><strong>为什么握手不能是两次呢？</strong></h4><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论:客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论:服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论:客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><h3 id="TCP-四次挥手过程"><a href="#TCP-四次挥手过程" class="headerlink" title="TCP 四次挥手过程"></a><strong>TCP 四次挥手过程</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-5ab61a8e3d4b30c5f7fb661b3daead71_720w.jpg"></p><ol><li>第一次挥手(FIN&#x3D;1,seq&#x3D;u)，客户端发送一个FIN报文，报文中会指定一个序列号。发送完毕后，客户端进入<strong>FIN_WAIT_1状态</strong>。</li><li>第二次挥手(ACK&#x3D;1,ack&#x3D;u+1,seq &#x3D;v)，服务端收到 FIN 报文之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文。发送完毕后，服务器端进入<strong>CLOSE_WAIT状态</strong>，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2状态</strong>。</li><li>第三次挥手(FIN&#x3D;1,ACK1,seq&#x3D;w,ack&#x3D;u+1)，如果服务端也想断开连接了，发送一个FIN 报文，且指定一个序列号。发送完毕后，服务器端进入<strong>LAST_ACK状态</strong>，等待来自客户端的最后一个<strong>ACK</strong>。</li><li>第四次挥手(ACK&#x3D;1,seq&#x3D;u+1,ack&#x3D;w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包FIN，并进入<strong>TIME_WAIT状态</strong>， 等待某个固定时间<strong>（2MSL）</strong>之后，没有收到服务器端的ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED状态</strong>。</li><li>服务端接收到这个ACK确认包之后，关闭连接，进入<strong>CLOSED状态</strong>。</li></ol><h4 id="☆TCP-四次挥手过程中，需要等待2MSL-才进入CLOSED关闭状态☆"><a href="#☆TCP-四次挥手过程中，需要等待2MSL-才进入CLOSED关闭状态☆" class="headerlink" title="☆TCP 四次挥手过程中，需要等待2MSL,才进入CLOSED关闭状态☆"></a><strong>☆TCP 四次挥手过程中，需要等待2MSL,才进入CLOSED关闭状态☆</strong></h4><p><strong>询问频率特别高</strong></p><p><img src="https://pic4.zhimg.com/80/v2-23c7f55ac62cf64274ffbe8018dddb9f_720w.jpg"></p><p>2MSL， 即两个最大段生命周期。假设 <strong>主动发起挥手的是客户端</strong> ，那么需要2MSL的原因是：</p><ul><li><strong>1.为了保证客户端发送的最后一个ACK报文段能够到达服务端。</strong> 这个ACK报文段有可能丢失，因而使处在<strong>LAST-ACK</strong>状态的服务端就收不到对已发送的<strong>FIN + ACK</strong>报文段的确认。服务端会超时重传这个FIN+ACK 报文段，而客户端就能在 2MSL 时间内（ <strong>超时 + 1MSL 传输</strong> ）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动2MSL计时器。最后，客户端和服务器都正常进入到<strong>CLOSED</strong>状态。</li><li><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong> 。客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li></ul><h4 id="如果服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#如果服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="如果服务器出现了大量CLOSE_WAIT状态如何解决"></a><strong>如果服务器出现了大量CLOSE_WAIT状态如何解决</strong></h4><ul><li>服务器端收到客户端发送的 <code>FIN</code>后，TCP协议栈就会自动发送ACK，接着进入<strong>CLOSE_WAIT</strong>状态。</li><li>但是如果服务器端不执行socket的close()操作，那么就没法进入LAST_ACK,导致大量连接处于<strong>CLOSE_WAIT</strong>状态</li><li>所以，如果服务器出现了大量<strong>CLOSE_WAIT</strong>状态，一般是程序Bug，或者关闭socket不及时。</li></ul><h3 id="TCP-的粘包和拆包"><a href="#TCP-的粘包和拆包" class="headerlink" title="TCP 的粘包和拆包"></a><strong>TCP 的粘包和拆包</strong></h3><p>TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一 <strong>个完整的包可能会被TCP拆分成多个包进行发送</strong> ， <strong>也有可能把多个小的包封装成一个大的数据包发送</strong> ，这就是所谓的TCP粘包和拆包问题。</p><p><img src="https://pic3.zhimg.com/80/v2-c9ff4bf21f8f26e940eaa48446328e22_720w.jpg"></p><p><strong>为什么会产生粘包和拆包呢?</strong></p><ul><li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。</li></ul><p><strong>解决方案：</strong></p><ul><li>发送端将每个数据包封装为固定长度</li><li>在数据尾部增加特殊字符进行分割</li><li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li></ul><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP-流量控制"></a><strong>TCP-流量控制</strong></h3><p>TCP三次握手，发送端和接收端进入到ESTABLISHED状态，它们即可以愉快地传输数据啦。</p><p>但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。</p><blockquote><p>★ TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是 <strong>流量控制</strong> 。<br>”</p></blockquote><p>TCP通过滑动窗口来控制流量，我们看下流量控制的<strong>简要流程</strong>吧：</p><p>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</p><p><img src="https://pic1.zhimg.com/80/v2-986b62cafdbfbc45aa64cfd9c9917114_720w.jpg"></p><ol><li>假如当前发送方给接收方发送了200个字节，那么，发送方的 <code>SND.NXT</code>会右移200个字节，也就是说当前的可用窗口减少了200 个字节。</li><li>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200字节，所以win&#x3D;200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节</li><li>发送方又发送200字节过来，200字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理100字节，剩余的100字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100字节，即win&#x3D;100返回发送方。</li><li>发送方继续干活，发送100字节过来，这时候，接受窗口win变为0。</li><li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到win大于0，才继续开始发送。</li></ol><h3 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP-滑动窗口"></a><strong>TCP-滑动窗口</strong></h3><p><strong>思路讲解：</strong> TCP滑动窗口是个高频考点，我们需要知道TCP报文首部有个字段<strong>win</strong>控制窗口大小的，同时也需要掌握，滑动窗口是怎么滑的。</p><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p><blockquote><p>★ 这就好像我们面对面在聊天，你说完一句，我应答之后，你才能说下一句。那么，如果我在忙其他事情，没有能够及时回复你呢？你说完一句后，要等到我忙完回复你，你才说下句，这显然不现实，效率太低。<br>”</p></blockquote><p>为了解决这个问题，TCP引入了 <strong>窗口</strong> ，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p><p>TCP头部有个字段叫win，也即那个 <strong>16位的窗口大小</strong> ，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p><blockquote><p>★ 通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是win。<br>”</p></blockquote><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p><ul><li>已发送且已收到ACK确认</li><li>已发送但未收到ACK确认</li><li>未发送但可以发送</li><li>未发送也不可以发送</li></ul><p><img src="https://pic1.zhimg.com/80/v2-ad570770e061565c3a39fbc999ce9a28_720w.jpg"></p><ul><li>虚线矩形框，就是发送窗口。</li><li>SND.WND: 表示发送窗口的大小,上图虚线框的格子数是14个，即发送窗口大小是14。</li><li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li><li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li></ul><p>接收方的滑动窗口包含三大部分，如下：</p><ul><li>已成功接收并确认</li><li>未收到数据但可以接收</li><li>未收到数据并不可以接收的数据</li></ul><p><img src="https://pic3.zhimg.com/80/v2-288d6df65cdfa7c3a3350d2ac0f0397a_720w.jpg"></p><ul><li>虚线矩形框，就是接收窗口。</li><li>REV.WND: 表示接收窗口的大小,上图虚线框的格子就是9个。</li><li>REV.NXT:下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li></ul><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP-拥塞控制"></a><strong>TCP-拥塞控制</strong></h3><p><strong>思路讲解：</strong> TCP拥塞机制也是个高频考点，需要掌握<strong>它跟流量控制</strong>的区别，也需要掌握拥塞控制的这几种算法： <strong>慢启动算法、拥塞避免、拥塞发生、快速恢复算法</strong> 。</p><p>拥塞控制是 <strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong> 。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟<strong>流量控制</strong>又有什么区别呢？流量控制是作用于接收者的，根据 <strong>接收端的实际接收能力控制发送速度</strong> ，防止分组丢失的。</p><p>我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。</p><p><img src="https://pic1.zhimg.com/80/v2-aee11f05c2522dfe1a93e2cb5266c2fc_720w.jpg"></p><p>发送方维护一个<strong>拥塞窗口cwnd（congestion window）</strong> 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？</p><p>一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP的描述就是：</p><blockquote><p>★ 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。<br>”</p></blockquote><p>实际上，拥塞控制主要有这几种常用算法</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h4><p>慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包， <strong>每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）</strong> 。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p><ul><li>TCP连接完成，初始化cwnd &#x3D; 1，表明可以传一个MSS单位大小的数据。</li><li>每当收到一个ACK，cwnd就加一;</li><li>每当过了一个RTT，cwnd就增加一倍; 呈指数让升</li></ul><p><img src="https://pic3.zhimg.com/80/v2-afa39dc300d2dc1fe03f2e76356c3a12_720w.jpg"></p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个 <strong>慢启动阀值ssthresh</strong> （slow start threshold）状态变量。当 <code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当<strong>cwnd &gt;ssthresh</strong>时，进入了<strong>拥塞避免</strong>算法。</p><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h4><p>一般来说，慢启动阀值ssthresh是65535字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p><ul><li>每收到一个ACK时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</li><li>当每过一个RTT时，cwnd &#x3D; cwnd + 1</li></ul><p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p><p><img src="https://pic3.zhimg.com/80/v2-3cbed3f4792b23f7441ae352134097c6_720w.jpg"></p><h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h4><p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p><ul><li>RTO超时重传</li><li>快速重传</li></ul><p>如果是发生了 <strong>RTO超时重传</strong> ，就会使用拥塞发生算法</p><ul><li>慢启动阀值sshthresh &#x3D; cwnd &#x2F;2</li><li>cwnd 重置为 1</li><li>进入新的慢启动过程</li></ul><p><img src="https://pic3.zhimg.com/80/v2-d6f0ae834507afe19de4f5e630340fb2_720w.jpg"></p><p>这真的是 <strong>辛辛苦苦几十年，一朝回到解放前</strong> 。其实还有更好的处理方式，就是 <strong>快速重传</strong> 。发送方收到3个连续重复的ACK时，就会快速地重传，不必等待<strong>RTO超时</strong>再重传。</p><p><img src="https://pic2.zhimg.com/80/v2-01eff11b4555af8a412d4403a39e98a5_720w.jpg"></p><p>慢启动阀值ssthresh 和 cwnd 变化如下：</p><ul><li>拥塞窗口大小 cwnd &#x3D; cwnd&#x2F;2</li><li>慢启动阀值 ssthresh &#x3D; cwnd</li><li>进入快速恢复算法</li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h4><p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，所以没有必要像RTO超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- cwnd = cwnd /2</span><br><span class="line">- sshthresh = cwnd</span><br></pre></td></tr></table></figure><p>然后，真正的快速算法如下：</p><ul><li>cwnd &#x3D; sshthresh + 3</li><li>重传重复的那几个ACK（即丢失的那几个数据包）</li><li>如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1</li><li>如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-0c268ce0c2fb44d4992357df85bb9c19_720w.jpg"></p><h3 id="TCP-如何确保可靠性"><a href="#TCP-如何确保可靠性" class="headerlink" title="TCP 如何确保可靠性"></a><strong>TCP 如何确保可靠性</strong></h3><p>TCP是可靠的连接，依靠以下几点：连接和断开的可靠性（三次握手，四次挥手）、有状态（哪些数据发送了，哪些没发）、可控制（超时重传、流量控制、拥塞控制等）</p><ul><li>首先，TCP的连接是基于 <strong>三次握手</strong> ，而断开则是基于 <strong>四次挥手</strong> 。确保连接和断开的可靠性。</li><li>其次，TCP的可靠性，还体现在 <strong>有状态</strong> ;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li><li>再次，TCP的可靠性，还体现在 <strong>可控制</strong> 。它有数据包校验、ACK应答、 超时重传(发送方) 、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。<ul><li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li><li><strong>ACK应答</strong>：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>**超时重发(发送方)**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>**失序数据重传(接收方)**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</li><li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据</li><li>**流量控制(滑动窗口)**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li></ul></li></ul><h3 id="TCP-报文首部含有的字段及其作用"><a href="#TCP-报文首部含有的字段及其作用" class="headerlink" title="TCP 报文首部含有的字段及其作用"></a><strong>TCP 报文首部含有的字段及其作用</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-af1c05a8bbf5beaef1cf0d7fa1b0bd41_720w.jpg"></p><ul><li><strong>16位端口号</strong> ：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li><li><strong>32位序号</strong> ：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li><li><strong>32位确认号</strong> ：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</li><li><strong>4位头部长度</strong> ：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</li><li><strong>6位标志位</strong> ：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li><li><strong>16位窗口大小</strong> ：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li><li><strong>16位校验和</strong> ：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li><li><strong>16位紧急指针</strong> ：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul><h3 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP-重传机制"></a><strong>TCP-重传机制</strong></h3><p><strong>思路讲解：</strong> TCP的重传机制，也是道非常高频的面试题。包括 <strong>超时重传、快速重传、带选择确认的重传（SACK）、重复SACK四种</strong> 。</p><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a><strong>超时重传</strong></h4><p>超时重传：TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p><p>这个一定时间内，一般是多少比较合理呢？来看下什么叫 <strong>RTT（Round-Trip Time，往返时间）</strong> 。</p><p><img src="https://pic1.zhimg.com/80/v2-33ed03c0b232a6b40750a05e72395834_720w.jpg"></p><p>RTT就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。超时重传时间，就是RTO（Retransmission Timeout)。</p><p>那么，<strong>RTO到底设置多大呢？</strong></p><ul><li>如果RTO设置很大，等了很久都没重发，这样肯定就不行。</li><li>如果RTO设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。</li></ul><p>一般来说，RTO略微大于RTT，效果是最佳的。其实，RTO有个标准方法的计算公式，也叫 <strong>Jacobson &#x2F; Karels 算法</strong> 。一起来看下吧：</p><p><strong>1. 首先计算SRTT（即计算平滑的RTT）</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均</span><br></pre></td></tr></table></figure><p><strong>2. 其次，计算RTTVAR (round-trip time variation)</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距</span><br></pre></td></tr></table></figure><p><strong>3. 最后，得出最终的RTO</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  </span><br></pre></td></tr></table></figure><p>一般情况，α、β等的参数取值如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">α = 0.125，β = 0.25， μ = 1，∂ = 4</span><br></pre></td></tr></table></figure><p>别问这些参数是怎么来的，它们是大量实践，调出的最优参数。</p><p>超时重传不是十分完美的重传方案，它有这些缺点：</p><blockquote><p>★</p></blockquote><ul><li>当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。</li><li>当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li></ul><p>并且，对于TCP，如果发生一次超时重传，时间间隔下次就会加倍。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><strong>快速重传</strong></h4><p><strong>快速重传</strong>：可解决超时重发的时间等待问题。它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。快速重传流程如下：</p><p><img src="https://pic3.zhimg.com/80/v2-f24801fb963518c9ca1eec2b421a305e_720w.jpg"></p><p>发送方发送了 1，2，3，4，5,6份数据:</p><ul><li>第一份 Seq&#x3D;1 先送到了，于是就 Ack回2；</li><li>第二份 Seq&#x3D;2 也送到了，于是ACK回3；</li><li>第三份 Seq&#x3D;3 由于网络等某些原因，没送到；</li><li>第四份 Seq&#x3D;4 送到了，但是由于Seq&#x3D;3没收到。因此ACK还是回3；</li><li>后面的 Seq&#x3D;5,6的也送到了，ACK还是回复3，因为Seq&#x3D;3没有收到。</li><li>发送方连着收到三个重复冗余ACK&#x3D;3的确认（其实是4个哈，但是因为前面的一个是正常的ACK，后面三个才是重复冗余的），于是知道哪个报文段在传输过程中丢失了；发送方在定时器过期之前，重传该报文段。</li><li>最后，接收方收到了 Seq&#x3D;3，此时因为 Seq&#x3D;4，5，6都收到了，于是它回ACK&#x3D;7。</li></ul><p>但是呢，<strong>快速重传</strong>也可能有问题：ACK只向告知发送方，最大的有序报文段。到底是哪个报文丢失了呢？ <strong>并不确定</strong> ！那到底该重传多少个包呢？</p><blockquote><p>★ 是重传 Seq&#x3D;3 ？还是重传 Seq&#x3D;3、Seq&#x3D;4、Seq&#x3D;5、Seq&#x3D;6 呢？因为发送端并不清楚这三个连续的 ACK&#x3D;3 是谁传回来的。</p></blockquote><h4 id="带选择确认的重传（SACK）"><a href="#带选择确认的重传（SACK）" class="headerlink" title="带选择确认的重传（SACK）"></a><strong>带选择确认的重传（SACK）</strong></h4><p>为了解决：<strong>应该重传多少个包</strong>的问题? TCP提供了 <strong>带选择确认的重传</strong> （即SACK，Selective Acknowledgment）</p><blockquote><p>★ <strong>SACK机制</strong>就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-9ceac05b4042f2b55deee28981ed803b_720w.jpg"></p><p>如上图中，发送方收到了三次同样的ACK&#x3D;30的确认报文，于是就会触发快速重发机制，通过SACK信息发现只有 <code>30~39</code>这段数据丢失，于是重发时，就只选择了这个 <code>30~39</code>的TCP报文段进行重发。</p><h4 id="重复SACK（D-SACK）"><a href="#重复SACK（D-SACK）" class="headerlink" title="重复SACK（D-SACK）"></a><strong>重复SACK（D-SACK）</strong></h4><blockquote><p>★ D-SACK，英文是Duplicate SACK，是在SACK的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK的目的是帮助发送方判断，是否发生了包失序、ACK丢失、包重复或伪重传。让TCP可以更好的做网络流控。来看个图吧：</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-4f3d6756eaac5ab2be8a08ea1ccc7416_720w.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;HTTP-常用状态码及其含义&quot;&gt;&lt;a href=&quot;#HTTP-常用状态码及其含义&quot; class=&quot;headerlink&quot; title=&quot;HTTP-常用状态码及其含义&quot;&gt;&lt;/a&gt;&lt;strong&gt;HTTP-常用状态码及其含义&lt;/strong&gt;&lt;/h3&gt;&lt;ta</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://github.com/SUPERQ314/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="https://github.com/SUPERQ314/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>gulp</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AE%A1%E7%90%86/gulp/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AE%A1%E7%90%86/gulp/</id>
    <published>2022-06-17T10:25:33.879Z</published>
    <updated>2022-04-19T16:45:11.967Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><h4 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h4><ol><li>通过gulp.task注册任务</li><li>通过gulp.src方法获取到想要处理的文件流</li><li>然后把文件流通过pipe方法导入到gulp插件中</li><li>最后把经过插件处理后的流再通过pipe方法导入到gulp.dest中</li><li>gulp.dest方法则把流中的内容写入到文件中</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.tast(&#x27;scss&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;app/sass/!*.sass&#x27;)</span><br><span class="line">        .pipe(sass())</span><br><span class="line">        .pipe(gulp(&#x27;dist/css&#x27;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h3><table><thead><tr><th>api</th><th>描述</th></tr></thead><tbody><tr><td>task</td><td>创建一个任务</td></tr><tr><td>series</td><td>顺序执行多个任务</td></tr><tr><td>prallel</td><td>并行执行多个任务</td></tr><tr><td>src</td><td>读取数据资源转换成stream</td></tr><tr><td>pipe</td><td>管道-可以在中间对数据进行处理</td></tr><tr><td>dest</td><td>输出数据到目标路径</td></tr><tr><td>on</td><td>事件监听</td></tr><tr><td>watch</td><td>数据源监听</td></tr></tbody></table><p><strong>注册任务</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(name[,deps],fn)</span><br></pre></td></tr></table></figure><p>参数：<br>name是任务名称，执行任务时，使用这个名称<br>deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。<br>如果没有依赖，则可省略这个参数<br>fn是一个回掉函数，代表这个任务要做的事情</p><p><strong>读取文件</strong><br>将本地文件读取到gulp内存中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(globs[, options])</span><br></pre></td></tr></table></figure><p>参数：<br>globs是读取目标源文件的路径<br>opttions是一个可配置对象 通常不需要用到</p><p><strong>输出到文件</strong><br>将内存中数据输出到本地文件中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">dest</span>(path[,options])</span><br></pre></td></tr></table></figure><p>参数：<br>path是将数据输出目标文件路径<br>opttions是一个可配置对象 通常不需要用到</p><p><strong>监视文件变化</strong><br>用来监视某个或某些文件发生变化，可以在变化的时候，执行一个回掉函数，利用它来执行相应的任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">watch</span>(globs[,opts]),tasks);</span><br></pre></td></tr></table></figure><p>globs是要监视的文件匹配模式 ，规则和用法与gulp.src方法中的glob相同 opts是一个可配置对象 通常不需要用到 tasks是文件变化后要执行的任务，为一个数组</p><h2 id="gulp插件"><a href="#gulp插件" class="headerlink" title="gulp插件"></a>gulp插件</h2><p>我们要处理文件的合并、压缩等操作，接口中没有提供，都放在了插件中。</p><h3 id="1-4-1插件下载："><a href="#1-4-1插件下载：" class="headerlink" title="1.4.1插件下载："></a>1.4.1插件下载：</h3><blockquote><p>npm install 插件名 –save-dev</p></blockquote><p>gulp-concat : 合并文件(js&#x2F;css)</p><p>gulp-uglify : 压缩js文件</p><p>gulp-rename : 文件重命名</p><p>gulp-less : 编译less</p><p>gulp-sass：编译sass</p><p>gulp-clean-css : 压缩css文件</p><p>gulp-livereload : 实时自动编译刷新</p><p>gulp-htmlmin：压缩html文件</p><p>gulp-connect：热加载，配置一个服务器</p><p>gulp-load-plugins：打包插件（里面包含了其他所有插件）</p><h3 id="1-4-2使用插件："><a href="#1-4-2使用插件：" class="headerlink" title="1.4.2使用插件："></a>1.4.2使用插件：</h3><p>通过 npm install 插件名 –save-dev 安装插件到当前的项目<br>可以在gulpfile.js顶部通过require引入此插件<br>也可以在创建任务的时候使用 gulp-load-plugins插件 这个插件会自动帮你加载package.json文件里的gulp插件，不需要每个依次引入<br>在gulpfile.js声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>); <span class="comment">//引入gulp模块</span></span><br><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&quot;gulp-load-plugins&quot;</span>)(); <span class="comment">//引入gulp-load-plugins</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在使用过中，不需要使用require依次引入每一个插件，直接使用$.插件名称()的效果与require效果一致</p><p><strong>合并文件：</strong> gulp-concat</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;concat-js&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/!*.js&#x27;</span>) <span class="comment">//合并的文件</span></span><br><span class="line">         .<span class="title function_">pipe</span>(<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>)) <span class="comment">//执行合并</span></span><br><span class="line">         .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/js&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>编译Sass：</strong> gulp-sass</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;sass-css&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/sass/!*.sass&#x27;</span>) <span class="comment">//编译的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">sass</span>()) <span class="comment">//执行编译</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/css&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>编译less：</strong> gulp-less</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;less-css&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/less/!*.less&#x27;</span>) <span class="comment">//编译的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">less</span>()) <span class="comment">//执行编译</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/css&#x27;</span>); <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>自动前缀：</strong> gulp-autoprefixer</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;autoprefixer&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/css/*.css&#x27;</span>) <span class="comment">//编译的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">autoprefixer</span>()) <span class="comment">//执行编译</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/css&#x27;</span>); <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>压缩图片：</strong> gulp-imagemin</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;imagemin&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/images/*.&#123;jpg,png,JPG,PNG&#125;&#x27;</span>) <span class="comment">//优化的图片</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">imagemin</span>()) <span class="comment">//执行优化</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/images&#x27;</span>)) <span class="comment">//输出</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>压缩html文件：</strong> gulp-minify-html</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;min-html&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/html/*.html&#x27;</span>) <span class="comment">//压缩的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">minifyHtml</span>()) <span class="comment">//执行压缩</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/html&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>压缩css文件：</strong> gulp-minify-css</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;min-css&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/css/*.css&#x27;</span>) <span class="comment">//压缩的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">minifyCss</span>()) <span class="comment">//执行压缩</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/css&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>压缩js文件：</strong> gulp-uglify</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;min-js&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/js/*.js&#x27;</span>) <span class="comment">//压缩的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>()) <span class="comment">//执行压缩</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/js&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>重命名js文件：</strong> gulp-rename</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;rename-js&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/js/*.js&#x27;</span>) <span class="comment">//重命名的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">rename</span>(<span class="string">&#x27;app.min.js&#x27;</span>)) <span class="comment">//执行重命名及重命名名字</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/js&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>es6转es5：</strong>  <a href="https://link.juejin.cn/?target=mailto:gulp-babel@7.0.1" title="mailto:gulp-babel@7.0.1">gulp-babel@7.0.1</a> babel-core babel-preset-es2015</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入的时候只要导入一个即可：</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>)</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;babel-js&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./src/js/**&#x27;</span>) <span class="comment">//转码的文件</span></span><br><span class="line">     .<span class="title function_">pipe</span>(<span class="title function_">babel</span>(&#123;<span class="attr">presets</span>:[<span class="string">&#x27;es2015&#x27;</span>]<span class="comment">// 设置转码规则</span></span><br><span class="line">     .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>()) <span class="comment">//执行转码</span></span><br><span class="line">     .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./dist/js&#x27;</span>)) <span class="comment">//输出文件</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>创建本地服务器：</strong> gulp-connect</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;server&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> connect.<span class="title function_">server</span>(&#123;</span><br><span class="line">        <span class="attr">root</span>:<span class="string">&#x27;dist&#x27;</span>, <span class="comment">//服务器的根目录</span></span><br><span class="line">        <span class="attr">port</span>:<span class="number">8080</span>,  <span class="comment">//服务器的地址，没有此配置项默认也是 8080</span></span><br><span class="line">        <span class="attr">livereload</span>:<span class="literal">true</span> <span class="comment">//启用实时刷新的功能</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>实时预览：</strong> gulp-connect</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;reload&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/index.html&#x27;</span>) <span class="comment">//指定源文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist&#x27;</span>)) <span class="comment">//拷贝到dist目录</span></span><br><span class="line">        .<span class="title function_">pipe</span>(connect.<span class="title function_">reload</span>()) <span class="comment">//通知浏览器重启</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>代码检查：</strong> gulp-jshint</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;jslint&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;app/!*.js&#x27;</span>) <span class="comment">//检查的文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">jshint</span>()) <span class="comment">//执行代码检查</span></span><br><span class="line">        .<span class="title function_">pipe</span>(jshint.<span class="title function_">reporter</span>()) <span class="comment">// 输出检查结果</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>清除目标文件夹：</strong>  gulp-clean</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;clean&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./dist&#x27;</span>)  <span class="comment">//清除的文件夹</span></span><br><span class="line">               .<span class="title function_">pipe</span>(<span class="title function_">clean</span>()) <span class="comment">//执行清除</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="1-4-3使用gulp-watch-监听文件变化，自动执行任务"><a href="#1-4-3使用gulp-watch-监听文件变化，自动执行任务" class="headerlink" title="1.4.3使用gulp.watch()监听文件变化，自动执行任务"></a>1.4.3使用gulp.watch()监听文件变化，自动执行任务</h3><p>创建auto任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>( <span class="string">&#x27;auto&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/!*.js&#x27;</span>, [<span class="string">&#x27;concat-js&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/sass/!*.sass&#x27;</span>, [<span class="string">&#x27;sass-css&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/less/!*.less&#x27;</span>, [<span class="string">&#x27;less-css&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/css/*.css&#x27;</span>, [<span class="string">&#x27;autoprefixer&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>(<span class="string">&#x27;app/images/*.&#123;jpg,png,JPG,PNG&#125;&#x27;</span>, [<span class="string">&#x27;imagemin&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/html/*.html&#x27;</span>, [<span class="string">&#x27;min-html&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/css/*.css&#x27;</span>, [<span class="string">&#x27;min-css&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/js/*.js&#x27;</span>, [<span class="string">&#x27;min-js&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;./src/js/**&#x27;</span>, [<span class="string">&#x27;babel-js&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/index.html&#x27;</span>, [<span class="string">&#x27;reload&#x27;</span>] );</span><br><span class="line">  gulp.<span class="title function_">watch</span>( <span class="string">&#x27;app/!*.js&#x27;</span>, [<span class="string">&#x27;jslint&#x27;</span>] );</span><br><span class="line">&#125; );</span><br><span class="line">gulp.<span class="title function_">task</span>( <span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;auto&#x27;</span>] ); <span class="comment">//设置auto为默认任务</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>命令行执行 gulp</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>本文就用一个实际的例子把这几个api全部串联起来，我将实现一个这样的功能：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786f73278dc64027960cc68438fcaf06~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="流程管理"></p><h4 id="全局安装gulp"><a href="#全局安装gulp" class="headerlink" title="全局安装gulp"></a>全局安装gulp</h4><p>首先确保你已经正确安装了nodejs环境，然后以全局方式安装gulp环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp -g</span><br></pre></td></tr></table></figure><p>然后切换到你的项目文件夹中，为项目单独安装gulp开发依赖</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp --save-dev</span><br></pre></td></tr></table></figure></blockquote><h4 id="项目根目录新建gulpfile-js文件"><a href="#项目根目录新建gulpfile-js文件" class="headerlink" title="项目根目录新建gulpfile.js文件"></a>项目根目录新建gulpfile.js文件</h4><h5 id="文件头引入模块"><a href="#文件头引入模块" class="headerlink" title="文件头引入模块"></a>文件头引入模块</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulpfile.js</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并文件插件</span></span><br><span class="line"><span class="comment"> * gulp的插件很多，有4000多个，足够满足大家日常的各种需求，而且插件写起来也超级简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> concat = <span class="built_in">require</span>(<span class="string">&quot;gulp-concat&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> through2 = <span class="built_in">require</span>(<span class="string">&quot;through2&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="创建合并文件任务"><a href="#创建合并文件任务" class="headerlink" title="创建合并文件任务"></a>创建合并文件任务</h5><p>新建合并任务，读取 <code>20201108</code>目录下所有 <code>txt</code>文件，合并为 <code>20201108.txt</code>文件并存储在 <code>demo</code>文件夹下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task 为创建gulp子任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;concat&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./20201108/*.txt&#x27;</span>) <span class="comment">// src: 读取文件转化为可读流，参数可以是文件通配符匹配</span></span><br><span class="line">.<span class="title function_">pipe</span>(<span class="title function_">gulpConcat</span>(<span class="string">&#x27;20201108.txt&#x27;</span>)) <span class="comment">// pipe:管道，把gulp的执行步骤一步步串联起来，也是gulp的核心</span></span><br><span class="line">.<span class="title function_">pipe</span>(<span class="title function_">dest</span>(<span class="string">&#x27;./demo/&#x27;</span>)) <span class="comment">// dest：存放文件</span></span><br><span class="line">.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 事件监听</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;concat: 文件合并完成&#x27;</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="创建文件去除空行任务"><a href="#创建文件去除空行任务" class="headerlink" title="创建文件去除空行任务"></a>创建文件去除空行任务</h5><p>因为是需要顺序执行子任务，所以用的 <code>series</code>，如果是需要并行执行的话用 <code>parallel</code></p><p>代码中的 <code>through2</code>主要是用来做文件流转换过滤，写 <code>gulp</code>插件必备，下一节会大概的介绍一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;format&#x27;, gulp.series(&#x27;concat&#x27;, () =&gt; &#123;</span><br><span class="line">  return gulp.src(&#x27;./demo/20201108.txt&#x27;)</span><br><span class="line">      .pipe(through2.obj(function (file, encoding, cb) &#123; // through2：文件流转换，写gulp插件必备，下面会大概的介绍一下</span><br><span class="line">          let contents = file.contents.toString();</span><br><span class="line">          contents = contents</span><br><span class="line">              .replace(/(\n[\s\t]\r\n)/g, &quot;\n&quot;)</span><br><span class="line">              .replace(/^[\n\r\n\t]|[\n\r\n\t]$/g, &quot;&quot;); // 去除空行</span><br><span class="line">          let lines = contents.split(/\n/g);</span><br><span class="line">          totalLine = lines.length;</span><br><span class="line">          contents = lines.join(&quot;\n&quot;);</span><br><span class="line">          file.contents = Buffer.from(contents);</span><br><span class="line">          this.push(file);</span><br><span class="line">          cb();</span><br><span class="line">      &#125;))</span><br><span class="line">  .pipe(dest(&#x27;./demo/&#x27;))</span><br><span class="line">  .on(&#x27;end&#x27;, () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;format: 去除空行完成&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h5 id="创建监听任务"><a href="#创建监听任务" class="headerlink" title="创建监听任务"></a>创建监听任务</h5><p>当 <code>20201108</code>文件夹下的文件有写入操作时，去执行 <code>format</code>任务，<code>format</code>任务又依赖 <code>concat</code>任务执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;watch&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 因为是需要顺序执行子任务，所以用的concat，如果是需要并行执行的话用parallel</span></span><br><span class="line">  gulp.<span class="title function_">watch</span>(<span class="string">&#x27;./20201108/*.txt&#x27;</span>, gulp.<span class="title function_">series</span>(<span class="string">&#x27;format&#x27;</span>, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">  &#125;)).<span class="title function_">on</span>(<span class="string">&#x27;change&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 更多事件监听可以查看官方文档</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watch: 文件被改变&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="在项目目录下执行"><a href="#在项目目录下执行" class="headerlink" title="在项目目录下执行"></a>在项目目录下执行</h5><p>以上几步的代码合并到一个 <code>gulpfile.js</code>文件中即可运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控20201108文件夹下所有文件变化，则执行format子任务</span></span><br><span class="line">$ gulp watch</span><br></pre></td></tr></table></figure><p>下图为命令行中输入日志</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f427f3836be84251894df87b614a6881~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p><p>看了上面的 <code>demo</code>可能大家会对 <code>through2</code>比较好奇吧，接下来会大概介绍一下</p><h3 id="gulp插件机制"><a href="#gulp插件机制" class="headerlink" title="gulp插件机制"></a>gulp插件机制</h3><p>我们先提一提 <code>gulp</code>的机制，<code>gulp</code>内部的实现很简单，用了三个sdk实现 <code>undertaker</code>，<code>vinyl-fs</code>, <code>glob-watcher</code></p><ul><li>undertaker: 主要用来实现gulp的子任务流程管理</li><li>vinyl-fs: <code>.src</code> 接口可以匹配一个文件 <strong>通配符</strong> ，将匹配到的文件转为 <code>Vinyl Stream</code>(流)，<code>gulp</code>理念就是万物皆可流</li><li>glob-watcher: 也就是去实现 <code>gulp.watch</code>功能，监控文件流变化</li></ul><p>核心就是把文件转换成 <code>Stream</code>流，然后对 <code>Stream</code>进行操作。</p><p>所以 <code>gulp</code>采用 <code>pipe</code>(管道)的概念，意味着顺着管道流淌，然后我们对于 <code>gulp</code>的插件，也很好理解了，就是在管道中间有个过滤站，对流进行过滤处理，这就用到了上面提到的 <code>through2</code>，这个插件主要的作用也是对流文件进行处理，类似的插件还有 <code>map-stream</code>等，不过 <code>gulp</code>的主流的插件都是基于 <code>through2</code>编写的.</p><p>例如上面的例子（文件去除空行任务），单独封装一下，使用的时候就是一个简单的插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// gulp-file-format.jsmodule.exports = () =&gt; &#123;</span><br><span class="line">  return through2.obj(function (file, encoding, cb) &#123;</span><br><span class="line">let contents = file.contents.toString();</span><br><span class="line">contents = contents</span><br><span class="line">  .replace(/(\n[\s\t]\r\n)/g, &quot;\n&quot;)</span><br><span class="line">  .replace(/^[\n\r\n\t]|[\n\r\n\t]$/g, &quot;&quot;); // 去除空行</span><br><span class="line">let lines = contents.split(/\n/g);</span><br><span class="line">totalLine = lines.length;</span><br><span class="line">contents = lines.join(&quot;\n&quot;);</span><br><span class="line">file.contents = Buffer.from(contents);</span><br><span class="line">this.push(file);</span><br><span class="line">cb();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换文件去除空行任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulpFormact = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-format.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;format&#x27;</span>, gulp.<span class="title function_">series</span>(<span class="string">&#x27;concat&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./demo/20201108.txt&#x27;</span>)</span><br><span class="line">     .<span class="title function_">pipe</span>(<span class="title function_">gulpFormact</span>())</span><br><span class="line">     .<span class="title function_">pipe</span>(<span class="title function_">dest</span>(<span class="string">&#x27;./demo/&#x27;</span>))</span><br><span class="line">     .<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;format: 去除空行完成&#x27;</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>这就是一个很简单的 <code>gulp</code>插件了，是不是很简单，比 <code>webpack</code>的插件简单多了</p><p>下面讲一个日常中对于重复工作提效写的一个脚本，讲讲思路，让大家对gulp的使用场景有个更深的理解。</p><h3 id="实际应用案例思路拆解-支付中间页改版后数据统计"><a href="#实际应用案例思路拆解-支付中间页改版后数据统计" class="headerlink" title="实际应用案例思路拆解-支付中间页改版后数据统计"></a>实际应用案例思路拆解-支付中间页改版后数据统计</h3><p>由于实际的代码涉及到一些敏感数据，所以这个段落只是讲一下解决这个实际问题的思路拆解，怎么去用 <code>gulp</code>完成想要的结果，不贴详细的代码了。</p><p>例如，作者最近做了一个支付中间页的改版</p><p>我需要统计从这个支付中间页转化的用户产生了多少收入，人工流程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3533d085794549b5b520ec01c28e338e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="统计流程"></p><p>把以上几个步骤拆解成 <code>gulp</code>的任务，用 <code>gulp</code>的任务机制管理起来，每一个任务可以单独执行，又可以统一执行</p><ol><li>export：下载用户uid</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出uid表</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;export&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>concat：合并文件并去重</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对excel文件进行合并去重</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;cocat&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol start="3"><li>money：循环uid，远程请求接口，拿到支付金额</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取每一个uid的支付金额</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;money&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>total: 汇总数据，生成汇总excel表格并输出</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据汇总</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;total&#x27;</span>, gulp.<span class="title function_">series</span>(<span class="string">&#x27;export&#x27;</span>, <span class="string">&#x27;concat&#x27;</span>, <span class="string">&#x27;money&#x27;</span>, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ol start="5"><li>执行命令</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp total</span><br></pre></td></tr></table></figure><p>以上任务都可以独立执行，也可以合并执行</p><h3 id="更复杂的应用场景-转转sdk生成命令工具"><a href="#更复杂的应用场景-转转sdk生成命令工具" class="headerlink" title="更复杂的应用场景-转转sdk生成命令工具"></a>更复杂的应用场景-转转sdk生成命令工具</h3><p>更复杂的应用场景可以查看我们之前产出的一套 <code>sdk</code>命令生成工具：<a href="https://link.juejin.cn/?target=https://github.com/zhuanzhuanfe/commander-tools" title="https://github.com/zhuanzhuanfe/commander-tools">commander-tools</a>，现已在 <code>github</code>开源，在转转支撑团队的维护下功能越来强大，主要实现以下命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;lint&quot;: &quot;commander-tools run lint&quot;, // 校验</span><br><span class="line">    &quot;fix&quot;: &quot;commander-tools run lint --fix&quot;, // 修复</span><br><span class="line">    &quot;staged&quot;: &quot;commander-tools run lint --staged&quot;,</span><br><span class="line">    &quot;staged-fix&quot;: &quot;commander-tools run lint --staged --fix&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;commander-tools run dev&quot;, // 启动本地调试服务</span><br><span class="line">    &quot;compile&quot;: &quot;commander-tools run compile&quot;, // 编译</span><br><span class="line">    &quot;dist&quot;: &quot;commander-tools run dist&quot;, // 外链打包</span><br><span class="line">    &quot;analyz&quot;: &quot;commander-tools run dist --analyz&quot;, // 代码分析</span><br><span class="line">    &quot;build&quot;: &quot;commander-tools run build&quot;,</span><br><span class="line">    &quot;pub&quot;: &quot;commander-tools run pub&quot;, // 发布正式版</span><br><span class="line">    &quot;pub-beta&quot;: &quot;commander-tools run pub-beta&quot;, // 发布beta版本</span><br><span class="line">    &quot;unpub&quot;: &quot;commander-tools run unpub&quot;, // 卸载版本</span><br><span class="line">    &quot;doc&quot;: &quot;commander-tools run doc&quot;, // 预览文档</span><br><span class="line">    &quot;build-doc&quot;: &quot;commander-tools run build-doc&quot;, // 生成文档</span><br><span class="line">    &quot;doc-upload&quot;: &quot;commander-tools run doc-upload&quot; // 文档上传ftp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：一个上传注释文档的功能</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run doc-upload</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 上传文档</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ftp = <span class="built_in">require</span>(<span class="string">&#x27;vinyl-ftp&#x27;</span>)</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;doc-upload&#x27;</span>, gulp.<span class="title function_">series</span>(<span class="string">&#x27;build-doc&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;running doc-upload&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ftpConfig) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;请配置 ftp.config.js&#x27;</span>))</span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> businessLine = <span class="title function_">getBusinessLine</span>(program)</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = packageJson</span><br><span class="line">  <span class="keyword">const</span> conn = ftp.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">parallel</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">log</span>: fancyLog,</span><br><span class="line">    ...ftpConfig</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pipe = gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">`<span class="subst">$&#123;cwd&#125;</span>/<span class="subst">$&#123;program.docsDirName || <span class="string">&#x27;docs&#x27;</span>&#125;</span>/**/*`</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(conn.<span class="title function_">dest</span>(<span class="string">`/<span class="subst">$&#123;businessLine&#125;</span>/<span class="subst">$&#123;name&#125;</span>/`</span>))</span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success: 文档上传成功&#x27;</span>))</span><br><span class="line">      ftp.<span class="property">docUrl</span> &amp;&amp; <span class="title function_">open</span>(ftp.<span class="property">docUrl</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pipe</span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;gulp&quot;&gt;&lt;a href=&quot;#gulp&quot; class=&quot;headerlink&quot; title=&quot;gulp&quot;&gt;&lt;/a&gt;gulp&lt;/h3&gt;&lt;h4 id=&quot;使用流程&quot;&gt;&lt;a href=&quot;#使用流程&quot; class=&quot;headerlink&quot; title=&quot;使用流程</summary>
      
    
    
    
    <category term="前端开发流程规范管理" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="gulp" scheme="https://github.com/SUPERQ314/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>特性化前端脚手架</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E7%89%B9%E6%80%A7%E5%8C%96%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E7%89%B9%E6%80%A7%E5%8C%96%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2022-06-17T10:25:33.754Z</published>
    <updated>2022-04-20T14:49:24.908Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="https://juejin.cn/post/6989190324757200932">使用gulp让小程序开发更顺滑</a></p><h1 id="Gulp-amp-Webpack搭建特性化前端脚手架"><a href="#Gulp-amp-Webpack搭建特性化前端脚手架" class="headerlink" title="Gulp &amp; Webpack搭建特性化前端脚手架"></a>Gulp &amp; Webpack搭建特性化前端脚手架</h1><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul><li>专题等静态页面多</li><li>后台主导逻辑业务,前端主导交互等</li><li>需要整合es6,scss,eslint等</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>webpack^3</li><li>gulp-webpack^1.5</li><li>gulp-pug^3.3</li><li>gulp^3.9</li><li>eslint^4</li><li>eslint-config-alloy^1.4</li><li>babel^6.5</li><li>gulp-postcss^6.2</li><li>autoprefixer^6.4</li><li>browser-sync^2.1</li><li>gulp-sass^2.3</li></ul><p>当然还有一些就不一一列出了,这里只列出几个主要的模块 下面来解释一下上述模块对应的功能。s</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>这里，webpack只负责js相关的事情就好，负责的范围为es6-&gt;es5、eslint的检测、js的sourcemap文件的生成。</p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>这个没什么好说的，babel也提供了cli的形式，但这里整合进了webpack当中。</p><h2 id="gulp-sourcemaps-amp-gulp-sass-amp-gulp-postcss-amp-autoprefixer"><a href="#gulp-sourcemaps-amp-gulp-sass-amp-gulp-postcss-amp-autoprefixer" class="headerlink" title="gulp-sourcemaps &amp; gulp-sass &amp; gulp-postcss &amp; autoprefixer"></a>gulp-sourcemaps &amp; gulp-sass &amp; gulp-postcss &amp; autoprefixer</h2><p>这些都是用来处理sass的相关，比如sass的编译、css的浏览器兼容性处理、css的sourcemap对应。</p><h2 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h2><p>这里，选择使用browser-sync提供了静态服务器。<br>browser-sync可以快速的搭建起一个静态服务器并且支持api级别的接口刷新。</p><p>可以很方便的去自动或者手动调用刷新页面功能</p><h2 id="eslint-amp-eslint-config-alloy"><a href="#eslint-amp-eslint-config-alloy" class="headerlink" title="eslint &amp; eslint-config-alloy"></a>eslint &amp; eslint-config-alloy</h2><p>这里，使用腾讯alloy团队的eslint检测配置</p><h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>这里，所有模块都是由gulp来主导并且粘合的。</p><p>当所有的模块都不知道啥时候去调用，啥时候去做该做的事情时，就用gulp.watch和gulp.src。<br>简单来个例子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *监听文件 /</span><br><span class="line">gulp.task(&quot;watch&quot;, () =&gt; &#123;</span><br><span class="line">    let bs = browserSync.init(&#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: &quot;./&quot;,</span><br><span class="line">            directory: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        open: false,</span><br><span class="line">        ui: &#123;</span><br><span class="line">            port: 3008,</span><br><span class="line">            weinre: &#123;</span><br><span class="line">                port: 3009</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        port: devConf.gulp.webPort?devConf.gulp.webPort:3012,</span><br><span class="line">        ghostMode: false</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.watch([&quot;dev/jade-html/**/.pug&quot;, &quot;dev/jade-component//*.pug&quot;], [&quot;compile:pug&quot;]);</span><br><span class="line">    gulp.watch([&quot;dev/js//.js&quot;], [&quot;compile:js&quot;]);</span><br><span class="line">    gulp.watch([&quot;dev/sass/**/.scss&quot;], [&quot;compile:sass&quot;]);</span><br><span class="line">    gulp.watch([&quot;dev/img//.&quot;, &quot;dev/lib//.&quot;], [&quot;copy&quot;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>大意就是监听某些文件变动的时候执行对应的task。</p><h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><p>1、gulp-webpack编译每次都是重新编译</p><p>gulp-webpack每次调用webpack都需要重新编译,所以时间会很长很长很长。其实还好 个人测试中,webpack增量编译时间为1s的话,gulp-webpack编译时间为2s-3s左右。如果对时间不是特别敏感的可以忽略。 当然这个问题还是有解决方案的,也是之前看的某篇文章提出的 使用proxy机制, webpack的增量编译刷新调动browserSync的刷新。 这样一来可以做到同步刷新 并且不适用gulp-webpack来重新编译转而使用webpack的增量编译和静态服务器功能。当然具体怎么实现还没有研究 但是可以得出的结论就是 不难。</p><p>2、pug,sass文件过多，每次都编译出额外的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&quot;compile:sass&quot;, (event) =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;dev/sass/output/**/*.scss&#x27;)</span><br><span class="line">    //.pipe(changed(&quot;dist/css&quot;)) disabled changed sass需要全部编译..</span><br><span class="line">        .pipe(sourcemaps.init())</span><br><span class="line">        .pipe(sass(sassOptions).on(&quot;error&quot;, sass.logError))</span><br><span class="line">        .pipe(gulpif(extBase64File,base64(&#123;</span><br><span class="line">            maxImageSize: 15*1024, // bytes 15KB</span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(postcss([autoprefixer()]))</span><br><span class="line">        .pipe(sourcemaps.write(&quot;./&quot;))</span><br><span class="line">        .pipe(gulp.dest(&quot;dist/css&quot;))</span><br><span class="line">        .pipe(gulp.dest(copyCssPath))</span><br><span class="line">        .on(&quot;finish&quot;, () =&gt; &#123;</span><br><span class="line">            browserReload()</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里如果编译的话 每次都会把output下面所有的scss文件编译出来,同理 编译pug的时候也是一样会把某个文件夹下面的所有pug全部编译出来。当然解决办法也很简单</p><p>配置文件，没错,再使用额外的配置文件,比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const devConf=require(&quot;./dev-conf&quot;);</span><br><span class="line">let compilePugFile= devConf.gulp.compilePugFile?devConf.gulp.compilePugFile:[&quot;dev/jade-html/**/*.pug&quot;];</span><br><span class="line">let compileSassFile= devConf.gulp.compileSassFile?devConf.gulp.compileSassFile:[&quot;dev/sass/output/**/*.scss&quot;];</span><br><span class="line">let copyJsPath=devConf.gulp.copyJsPath?devConf.gulp.copyJsPath:`/public/dist/js`;</span><br><span class="line">let copyCssPath=devConf.gulp.copyCssPath?devConf.gulp.copyCssPath:`/public/dist/css`;</span><br><span class="line">let copyImgPath=devConf.gulp.copyImgPath?devConf.gulp.copyImgPath:`/public/img`;</span><br></pre></td></tr></table></figure><p>使用额外的配置文件来做到按需编译和加载</p><p>3、prod和dev如何区分。</p><p>这个其实很简单 可以使用npm run 也可以使用gulp的多个任务方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;default::production&#x27;,[&#x27;set-env::production&#x27;,&#x27;watch&#x27;]);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置环境变量</span><br><span class="line"> */</span><br><span class="line">gulp.task(&#x27;set-env::production&#x27;,()=&gt;&#123;</span><br><span class="line">    webpackEnv=&#x27;production&#x27;;</span><br><span class="line">    return Promise.resolve(true);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要dev模式那么直接 gulp就好 需要生产模式就 gulp default::production 这里的设置变量可以通过process.env来设置,这样就可以在全局拿到参数了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process.env.NODE_ENV = &#x27;dev&#x27;||&#x27;prod&#x27;;</span><br></pre></td></tr></table></figure><p>4、报错退出机制</p><p>gulp的每次报错都会导致gulp退出,比如调用gulp-webpack编译js的时候 某个js错误导致整个gulp退出, 当然解决办法也很简单</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const plumber = require(&#x27;gulp-plumber&#x27;);</span><br><span class="line">const webpackFile=require(&quot;./webpack.config.js&quot;);</span><br><span class="line">gulp.task(&quot;compile:js&quot;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&quot;dev/js/main.js&quot;)</span><br><span class="line">        .pipe(plumber(&#123;errorHandler:function () &#123;    &#125;&#125;))</span><br><span class="line">        .pipe(webpack(webpackFile(&#123;env:webpackEnv&#125;)))</span><br><span class="line">        .pipe(gulp.dest(&quot;dist/js/&quot;))</span><br><span class="line">        .pipe(gulp.dest(copyJsPath))</span><br><span class="line">        .on(&quot;finish&quot;, () =&gt; &#123;</span><br><span class="line">            browserReload()</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用gulp-plumber便可以解决问题了, 因为webpack自带错误提示功能 所以不需要gulp-plumber再次报错, 这里就把errorHandler给定义了空函数不做处理。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>基本上说到这里整个方案就差不多了。 这一套方案的好处就是 html,css,js分离并且互不影响。 html,css,js都使用了代替品来方便开发 比如html使用了pug(说pug不好的同学,你们有嵌套过10层以上的html吗？),css使用了sass,js使用了es6,并且三者可以快速替换和代替 比如 我哪天不想使用pug了 那么可以快速使用ejs等其他模板 只需要改改gulp的task, 哪天我想使用vue了 那么只需要改改webpack的配置文件,并且增加gulp.watch范围就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6989190324757200932&quot;&gt;使用gulp让小程序开发更顺滑&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Gulp-amp-Webpack搭建特性化前端脚手架&quot;&gt;&lt;a href=&quot;#Gulp-amp-</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://github.com/SUPERQ314/tags/webpack/"/>
    
    <category term="gulp" scheme="https://github.com/SUPERQ314/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>前端构建工具</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</id>
    <published>2022-06-17T10:25:33.740Z</published>
    <updated>2022-04-20T14:46:30.420Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a><strong>什么是构建工具</strong></h2><p>构建工具是一段自动根据源代码生成可使用文件的程序，构建过程包括打包、编译、压缩、测试等一切需要对源代码进行的相关处理。构建工具的目的是实现构建过程的自动化，使用它可以让咱们避免机械重复的劳动（这怕是程序员最不能忍受的了），从而解放我们的双手。</p><h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a><strong>gulp</strong></h2><p>作为一个 node 包，标准打开方式当然是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g gulp</span><br></pre></td></tr></table></figure><p>然后呢，这里以编译 less 为例，首先安装编译 less 需要用到的 node 包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save-dev gulp gulp-less</span><br></pre></td></tr></table></figure><p><strong>前面已经全局安装过 gulp 了，怎么又本地安装了一遍</strong><br>前面的 <code>-g</code> 是全局安装，是为了执行你所编写的 gulp 任务，即 gulp yourTask。而后面的 –save-dev 是本地安装，是为了咱们编写任务时使用 gulp 提供的 api，例如 <code>gulp.src()</code>、<code>gulp.task()</code>、<code>gulp.dest()</code> 等等。当然也是可以直接使用全局安装的 gulp 的 api 的，但是强烈不推荐，因为这样涉及到 gulp 版本控制的问题，而且使用全局 gulp 的 api 的话就会产生环境依赖（你假设环境已经全局安装了gulp，万一没装呢，程序不就出错了）。</p><p>接着在项目的根目录下新建一个 <strong>gulpfile.js</strong> 文件，这是 gulp 的默认配置文件。</p><p><strong>gulpfile.js 必须放在项目根目录？</strong><br>当然也可放在其他目录，但这样的话就得在启动 gulp 任务时手动指定 gulp 配置文件 gulp yourTask –gulpfile yourGulpfilePath，可能还需要全局安装 gulp-cli，所以除非有特殊需要，否则就放在项目根目录就行了，这样最简单。</p><p><strong>配置文件的名字必须是 gulpfile.js 吗？</strong><br>不区分大小写，取成 gULPFile.js 的话 gulp 也能认识，只要 toLowerCase 之后是 gulpfile 就行了，如果取其它名字那你就又得使用 –gulpfile 选项去指定了。</p><p>现在工程目录结构已经成了下面的样子：</p><p><img src="https://images2018.cnblogs.com/blog/882926/201711/882926-20171129154902769-897844315.png"></p><p>构建前 gulp 工程目录结构</p><p>接下来就是在 gulpfile.js 里编写  <strong>gulp task</strong> （gulp 把为每个痛苦又耗时任务编写的处理方法称为一个  <strong>task</strong> ）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;build:less&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./src/*.less&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">less</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./dist&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后就是打开一个终端，在终端里运行 gulp build:less。好了，编译后的文件已经被输出到了 <strong>dist</strong> 目录：</p><p><img src="https://images2018.cnblogs.com/blog/882926/201711/882926-20171129155301362-376259255.png"></p><p>构建后 gulp 工程目录结构</p><p>至此你已经算是一个 gulp 砖家了，这基本上就是 gulp 的全部内容。怎么样，是不是够简单，够丝滑。这也是 gulp 的突出特点——易于学习，易于使用，五分钟成砖家。如果想要执行解决其他痛苦又耗时的任务，只需下载安装对应的 gulp 插件包，然后依次类推写一个 <code>gulp.task</code> 出来就行了。</p><p><strong>这些源代码具体是怎样被处理的</strong><br>这通常不需要关心，因为 gulp 插件包已为你做好了，并且封装的非常漂亮，你只需要告诉 gulp 你要什么，gulp 及其插件会帮你打点好一切。这就好比你把一份电子文档传进打印机，告诉它我要一份 A4 纸打印，呲呲呲~，打印机就吐出来一张 A4 纸，上面是你的文档内容。源代码就是你的电子文档，gulp 插件就是打印机，生成的可用文件就是你手里的那张 A4 纸，你不用关心打印机内部是怎样工作的，因为它封装的很好，或者你可以把打印机拆了一探究竟也行。</p><p><strong>Gulp 是基于流的？</strong><br>流（Stream）不是 gulp 创造的概念，而是从 unix 时代就开始使用的 I&#x2F;O 机制，一直到现在仍在广泛使用。Node 封装了一个 <a href="http://nodejs.cn/api/stream.html">stream</a> 模块专门用来对流进行操作。gulp 所基于的流即是 Node 封装起来的 stream。上面 <code>gulp.task()</code> 代码里面的 <a href="http://nodejs.cn/api/stream.html#stream_readable_pipe_destination_options">pipe</a> 方法并不是 gulp 提供的 api，而是 node 的 api，准确的说应该是 node 的 stream 模块提供的 api。具体是怎么实现的呢：<code>gulp.src()</code> 的返回值是 node Stream 的一个实例，之后的 <code>pipe</code> 调用的其实是这个实例的 <code>pipe</code> 方法，而 <code>pipe</code> 方法的返回值依然是 node Stream 实例，以此实现前面的 <code>.pipe().pipe().pipe()</code> 这种串联写法。熟悉 jQuery 的同学应该很清楚这种技巧。</p><h2 id="webpack-又是从哪冒出来的"><a href="#webpack-又是从哪冒出来的" class="headerlink" title="webpack 又是从哪冒出来的"></a>webpack 又是从哪冒出来的</h2><p>gulp 似乎是完美的，对前端开发工作中每一项痛苦又耗时任务都能见招拆招，各个击破。然而前端发展速度之快超乎想象，对页面性能和用户体验更是追求极致，以至于 gulp 某些领域尤其大型  <strong>SPA</strong> （单页应用）显得有些不够用了：</p><ul><li>单页应用的核心是模块化，ES6 之前 JavaScript 语言本身一直是没有模块系统的，导致 AMD，CMD，UMD 各种轮子模块化方案都蹦出来。对这种模块化乱象，gulp 显得无能为力，gulp 插件对这一块也没有什么想法。不过也可以理解，模块化解决方案可不是谁都能 hold 住的，需要考虑的问题太多了；</li><li>对前沿的 SPA 技术 gulp 处理起来显得有些力不从心，例如 Vue 的单文件组件，gulp 配合一些插件可以勉强处理，但是很蹩脚。其实归根结底，还是模块化处理方面的不足；</li><li>优化页面加载速度的一条重要法则就是减少 http 请求。gulp 只是对静态资源做流式处理，处理之后并未做有效的优化整合，也就是说 gulp 忽略了系统层面的处理，这一块还有很大的优化空间，尤其是移动端，那才真的是一寸光阴一寸金啊，哪怕是几百毫秒的优化所带来的收益（用户？流量？付费？）绝对超乎你的想象。别跟我说 gulp-concat，CSS Sprites，这俩玩意儿小打小闹还行，遇上大型应用根本拿不上台面。现在的页面动辄上百个零碎资源（图片，样式表，脚本），也就是上百个 http 请求，因此这个优化需求还是相当迫切的。关于为何减少 http 请求可以有效降低页面加载时间<a href="http://www.cnblogs.com/iovec/p/7904416.html">戳这里</a>。</li><li>blabla… 你自己想吧，主要就是大型单页应用方面有短板；</li></ul><p>时势造英雄。webpack 一声吼，大张旗鼓地挖起了gulp 的墙角。</p><p>老规矩，先看看webpack官网怎么<del>吹牛逼</del>介绍自己的：</p><p><strong>Webpack</strong> 是当下最热门的前端资源模块化 <strong>管理和打包</strong> 工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载。</p><p>是不是看完一脸懵逼，不明觉厉。其实翻译过来就是 “在我眼里，什么都是模块”。webpack “万物皆模块” 的理念和 SPA 配合起来简直是金童玉女，天作之合。这也是 webpack 短时间内名声大噪，直接撼动 gulp 地位的主要原因。</p><p>webpack 的理念比较前卫，它本身也带来了很多新的概念和内容，诸如加载器（loader）、依赖图（Dependency Graph）等等。和 gulp 两小时成砖家的学习难度相比，webpack 或许你研究两天仍然会晕头转向。</p><p>接下来简单看一下 webpack 的主要工作方式。</p><p>webpack 和 gulp 一样也是一个小 node 包，打开方式自然是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g webpack</span><br><span class="line">npm i --save-dev webpack</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>和 gulp 一样，全局安装是为了执行 webpack 任务，本地安装是为了使用 webpack 提供的 api。</p><p>安装完 webpack 之后在项目根目录下新建一个  <strong>webpack.config.js</strong> ，这是 webpack 的默认配置文件，同 gulp 的 gulpfile.js 的功能类似。webpack.config.js 同样是不区分大小写的，取成 webPACk.CONfig.js 的话 webpack 也能认识，但是取成其他名字或放在别的目录就需要使用 –config 选项去指定配置文件了。</p><p>现在工程目录结构如下：</p><p><img src="https://images2017.cnblogs.com/blog/882926/201712/882926-20171206114604300-1207786283.png"></p><p>构建前webpack工程目录结构</p><p>接下来就是在 webpack.config.js 里配置需要的选项，注意了，webpack 与 gulp 的重要不同就是使用方式  <strong>由编程式变成了配置式</strong> ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,        <span class="comment">// 告诉 webpack 你要编译哪个文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;                       <span class="comment">// 告诉 webpack 你要把编译后生成的文件放在哪</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>最后仍然和 gulp 类似，就是在终端里运行 webpack（终端里一般会出现一大坨编译信息）。好了，现在 webpack 已经把编译好的文件输出到了 dist 目录：</p><p><img src="https://images2017.cnblogs.com/blog/882926/201712/882926-20171206115136253-991690971.png"></p><p>构建后webpack工程目录结构</p><p>看到这是不是已经一头雾水了，在你还没明白发生了什么的时候 webpack 已经把事情干完了。这也是 webpack 和 gulp 作业方式的重要不同：<strong>Gulp</strong> 是搭了个台子，让 gulp 插件在上面唱戏，尽情表演，所有构建相关的具体事情都交由 gulp 插件去做。而 <strong>Webpack</strong> 就牛逼了，webpack 先搭了个台子，然后自己在上面唱嗨了，仔细一听，他在上面唱的是《我们不一样》，当然了他也是让 webpack 插件在上面唱戏的。</p><p>也就是说 webpack 把很多功能都封装进了自己身体里面，使得自己强大同时臃肿。现在你可以在 <code>./src/index.js</code> 文件里直接写 ES6 代码，因为 webpack 把编译 ES6 的工作已经封装到自己的实现里了，使得 webpack 看起来原生支持 ES6 而不需要借助第三方插件，其实他内部也是用了第三方插件的，所以你不用再专门去下一个 babel 之类的插件去转译 ES6。这样封装的好处是使用起来很方便，不好的地方就是使用者完全不知道发生了什么，构建完了还一脸懵逼。</p><p>上面仅是 webpack 使用的最最最简单示例，简直连 “hello world” 都算不上。具体怎样打包各种资源（typescript，样式表，图片，字体等等）可前往 <a href="http://webpack.github.io/">webpack官网</a> 深入学习，想看中文的同学使劲 <a href="http://www.css88.com/doc/webpack/">戳这里</a>。</p><p>webpack “一切皆模块” 的特点完美解决了上面 gulp 暴露的几个短板，连 webpack 官网也说自己是因为看到现存的模块打包器都不太适合大型 SPA 应用，于是决定打造一个适合大型 SPA 应用的模块打包器，也就是说 <a href="http://webpack.github.io/docs/what-is-webpack.html">webpack 其实就是为大型 SPA 而生的</a>。</p><p><strong>webpack 怎么实现像 gulp 一样对大量源文件进行流式处理</strong><br>人家 webpack 本来就没打算做这事。webpack 不是以取代 gulp 为目的的，而是为了给大型 SPA 提供更好的构建方案。对大量源文件进行流式处理是 gulp 擅长的事，webpack 不想抢，也没必要抢。即使抢，也无非是再造一个蹩脚的 gulp 出来而已。</p><p><strong>既然 webpack 模块化这么强，那以后模块化就全用 webpack 好了</strong><br>webpack 模块化是强，但是他胖啊，不是所有人都抱得动，主要是他为了提供更多的功能封装进了太多东西，所以选择上还是需要因地制宜。如果单纯只是打包 js（多页应用往往是这种需求），完全可以使用 rollup，browserify 这种小而美的实现，因为他们只做一件事——打包js。而如果需要将图片，样式，字体等所有静态资源全部打包，webpack 毫无疑问是首选。这也是为什么越来越多的流行库和框架开始从 webpack 转向使用 rollup 进行打包，因为他们只需要打包 js，webpack 好多强大功能根本用不到。连 rollup 官网也坦言如果你在构建一个库，rollup 绝对是首选，但如果是构建一个应用，那么请选 webpack。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;什么是构建工具&quot;&gt;&lt;a href=&quot;#什么是构建工具&quot; class=&quot;headerlink&quot; title=&quot;什么是构建工具&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是构建工具&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;构建工具是一段自动根据源代码生成可使用文件的程序，构建过</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://github.com/SUPERQ314/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack 和 gulp 的区别</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack%E5%92%8Cgulp%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack%E5%92%8Cgulp%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-06-17T10:25:33.684Z</published>
    <updated>2022-04-19T16:45:01.096Z</updated>
    
    <content type="html"><![CDATA[<hr><table><thead><tr><th></th><th>gulp</th><th>webpack</th></tr></thead><tbody><tr><td>定位</td><td>强调：规范前端开发的流程</td><td>前端模块化方案</td></tr><tr><td>目标</td><td>自动化和优化开发工作流，为通用website开发而生</td><td>通用模块打包加载器，为移动端大型SPA应用而生</td></tr><tr><td>学习难度</td><td>易于学习，易于使用，api总共只有5个方法</td><td>有大量新的概念和api，有详尽的官方文档</td></tr><tr><td>使用场景</td><td>基于流的作用方式，合适多页面应用开发</td><td>一切皆模块的特点，适合单页面应用开发</td></tr><tr><td>作业方式</td><td>对输入（gulp.src）的js，ts，scss，less等资源文件进行打包（bundle）、编译（compile）、压缩、重命名等处理后（guld.dest）到指定目录中去，为了构建而打包</td><td>对入口文件（entry）递归解析生成依赖关系图，然后将所有以来打包在一起，在打包之前将所有依赖转译成可打包的js模块，为了打包而构建</td></tr><tr><td>使用方式</td><td>常规js开发，编写一些列构建任务（task）</td><td>编辑各种JSON配置</td></tr><tr><td>优点</td><td>适合多页面开发，易于学习，易于使用，接口优雅</td><td>可以打包一切资源，适配各种模块系统</td></tr><tr><td>缺点</td><td>在大页面应用方面输出乏力，而且对流行的大页面技术有些难以处理(比如vue但文件组织，使用gulp处理就会很困难，而webpack一个loader就能轻松搞定)</td><td>不适合多页应用开发，灵活度高但同时配置很繁琐复杂，”打包一切”这个优点对于HTTP1.1尤其重要，因为所有资源打包在一起能明显减少浏览器访问页面时的请求数量，从而减少应用程序必须等待的时间。但这个有点可能会随着HTTP&#x2F;2的流行而变得不那么突出，因为HTTP&#x2F;2的多路复用可以有效解决客服端并行请求的瓶颈问题。</td></tr><tr><td>结论</td><td>浏览器多页应用（MPA）首选方案</td><td>浏览器单页应用（SPA）首选方案</td></tr><tr><td></td><td>是一个基于流的自动化构建工具，不包括模块化的功能，通过配置一系列的task，例如文件压缩合并、雪碧图、启动server、版本控制等，然后定义执行顺序来让gulp执行task，从而构建前端项目的流程</td><td>是一个自动化模块打包工具，把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，划分成不同的模块，需要哪个加载哪个，实现按需加载的功能，入口引入的更多是js文件</td></tr></tbody></table><h2 id="gulp和webpack的对比："><a href="#gulp和webpack的对比：" class="headerlink" title="gulp和webpack的对比："></a>gulp和webpack的对比：</h2><p>gulp 是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作</p><ol><li>构建工具</li><li>自动化</li><li>提高效率用</li></ol><p>webpack 是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案</p><ol><li>打包工具</li><li>模块化</li><li>编译模块代码方案</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;gulp&lt;/th&gt;
&lt;th&gt;webpack&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;定位&lt;/td&gt;
&lt;td&gt;强调：规范前端开发的流程&lt;/td&gt;
&lt;td&gt;前端模块化方案&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://github.com/SUPERQ314/tags/webpack/"/>
    
    <category term="gulp" scheme="https://github.com/SUPERQ314/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/</id>
    <published>2022-06-17T10:25:33.631Z</published>
    <updated>2022-04-19T16:44:56.020Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f4ef99bccb34946a83c2842b0ee1b0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p><img src="/SUPERQ314.github.io.git/image/webpack/1650386612820.png"></p><p><code>webpack</code> 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后会调用 <code>Compiler</code>的 <code>run</code>来真正启动 <code>webpack</code>编译构建过程，<code>webpack</code>的构建流程包括 <code>compile</code>、<code>make</code>、<code>build</code>、<code>seal</code>、<code>emit</code>阶段，执行完这些阶段就完成了构建过程。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f4ef99bccb34946a83c2842b0ee1b0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://github.com/SUPERQ314/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>优化页面加载速度</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-06-17T10:25:33.613Z</published>
    <updated>2022-04-19T16:45:16.331Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="优化页面加载速度的法则"><a href="#优化页面加载速度的法则" class="headerlink" title="优化页面加载速度的法则"></a>优化页面加载速度的法则</h3><p>减少http请求</p><p>gulp值是对静态资源做流式处理，处理后未做有效的优化整合，也就是会所gulp忽略了系统层面的处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;优化页面加载速度的法则&quot;&gt;&lt;a href=&quot;#优化页面加载速度的法则&quot; class=&quot;headerlink&quot; title=&quot;优化页面加载速度的法则&quot;&gt;&lt;/a&gt;优化页面加载速度的法则&lt;/h3&gt;&lt;p&gt;减少http请求&lt;/p&gt;
&lt;p&gt;gulp值是对静态资源做流</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/SUPERQ314/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="优化页面加载速度" scheme="https://github.com/SUPERQ314/tags/%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>vue基础面试题</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/vue/vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/vue/vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-17T10:25:33.471Z</published>
    <updated>2022-04-22T12:08:15.446Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="Vue的优点？Vue的缺点？"><a href="#Vue的优点？Vue的缺点？" class="headerlink" title="Vue的优点？Vue的缺点？"></a>Vue的优点？Vue的缺点？</h3><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p><p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h3 id="Vue和React的异同点？"><a href="#Vue和React的异同点？" class="headerlink" title="Vue和React的异同点？"></a>Vue和React的异同点？</h3><p>相同点：</p><ul><li>使用虚拟dom</li><li>组件化开发</li><li>单向数据流(父子组件之间，不建议子修改父传递的数据)</li><li>支持服务端渲染</li></ul><p>不同点：</p><ul><li>React的JSX，Vue的template</li><li>数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)</li><li>React单向绑定，Vue双向绑定</li><li>React的Redux，Vue的Vuex</li></ul><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892fde0e56324868921d0e924c84858a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="vuex的有哪些属性？用处是什么？"><a href="#vuex的有哪些属性？用处是什么？" class="headerlink" title="vuex的有哪些属性？用处是什么？"></a>vuex的有哪些属性？用处是什么？</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9566927e955c4d0ba19df942534e5b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="MVVM是什么？和MVC有何区别呢？"><a href="#MVVM是什么？和MVC有何区别呢？" class="headerlink" title="MVVM是什么？和MVC有何区别呢？"></a>MVVM是什么？和MVC有何区别呢？</h3><p>MVC</p><ul><li>Model(模型)：负责从数据库中取数据</li><li>View(视图)：负责展示数据的地方</li><li>Controller(控制器)：用户交互的地方，例如点击事件</li><li>思想：Controller将Model的数据展示在View上</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4636ebbfa25049179c27a6b5ab8bb308~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>MVVM</p><ul><li>VM：也就是View-Model，做了两件事达到了数据的双向绑定<ul><li>一、将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</li><li>二、将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li></ul></li><li>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac31b27392b4b0e90ca2f67c64c59c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>区别</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><h3 id="Vue是不是MVVM框架？"><a href="#Vue是不是MVVM框架？" class="headerlink" title="Vue是不是MVVM框架？"></a>Vue是不是MVVM框架？</h3><p>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的 <code>ref</code>可以做到这点</p><h3 id="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><a href="#Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？" class="headerlink" title="Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"></a>Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</h3><ul><li>jQuery直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可</li><li>在操作DOM频繁的场景里，jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能</li><li>Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</li><li>Vue集成的一些库，大大提高开发效率，比如Vuex，Router等</li></ul><h3 id="为什么data是个函数并且返回一个对象呢？"><a href="#为什么data是个函数并且返回一个对象呢？" class="headerlink" title="为什么data是个函数并且返回一个对象呢？"></a>为什么data是个函数并且返回一个对象呢？</h3><p><code>data</code>之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行 <code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的 <code>数据污染</code>。</p><h3 id="如何获取data中某一个数据的初始状态？"><a href="#如何获取data中某一个数据的初始状态？" class="headerlink" title="如何获取data中某一个数据的初始状态？"></a>如何获取data中某一个数据的初始状态？</h3><blockquote><p>在开发中，有时候需要拿初始状态去计算。例如</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">howMuch</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 计算出num增加了多少，那就是1000 - 初始值</span></span><br><span class="line">        <span class="comment">// 可以通过this.$options.data().xxx来获取初始值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> - <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="title function_">data</span>().<span class="property">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Vue的修饰符"><a href="#Vue的修饰符" class="headerlink" title="Vue的修饰符"></a>Vue的修饰符</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1c911988f74cea91da79af3c6049c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="截屏2021-07-11 下午9.56.53.png"></p><h3 id="Vue的内部指令"><a href="#Vue的内部指令" class="headerlink" title="Vue的内部指令"></a>Vue的内部指令</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39d348e686b449e8931f5a85802e3c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="组件之间的传值方式有哪些？"><a href="#组件之间的传值方式有哪些？" class="headerlink" title="组件之间的传值方式有哪些？"></a>组件之间的传值方式有哪些？</h3><ul><li>父组件传值给子组件，子组件使用 <code>props</code>进行接收</li><li>子组件传值给父组件，子组件使用 <code>$emit+事件</code>对父组件进行传值</li><li>组件中可以使用 <code>$parent</code>和 <code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li><li>使用 <code>$attrs</code>和 <code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li><li>使用 <code>$refs</code>获取组件实例，进而获取数据</li><li>使用 <code>Vuex</code>进行状态管理</li><li>使用 <code>eventBus</code>进行跨组件触发事件，进而传递数据</li><li>使用 <code>provide</code>和 <code>inject</code>，官方建议我们不要用这个，我在看 <code>ElementUI</code>源码时发现大量使用</li><li>使用浏览器本地缓存，例如 <code>localStorage</code></li></ul><h3 id="路由有哪些模式呢？又有什么不同呢？"><a href="#路由有哪些模式呢？又有什么不同呢？" class="headerlink" title="路由有哪些模式呢？又有什么不同呢？"></a>路由有哪些模式呢？又有什么不同呢？</h3><ul><li>hash模式：通过 <code>#号</code>后面的内容的更改，触发 <code>hashchange</code>事件，实现路由切换</li><li>history模式：通过 <code>pushState</code>和 <code>replaceState</code>切换url，实现路由切换，需要后端配合</li></ul><h3 id="相同的路由组件如何重新渲染？"><a href="#相同的路由组件如何重新渲染？" class="headerlink" title="相同的路由组件如何重新渲染？"></a>相同的路由组件如何重新渲染？</h3><blockquote><p>开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">MyComponent</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/b&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">MyComponent</span></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>如果依然想重新渲染，怎么办呢？可以使用 <code>key</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">&quot;$route.path&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="动态指令和参数使用过吗？"><a href="#动态指令和参数使用过吗？" class="headerlink" title="动态指令和参数使用过吗？"></a>动态指令和参数使用过吗？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;aButton @[someEvent]=<span class="string">&quot;handleSomeEvent()&quot;</span> :[someProps]=<span class="string">&quot;1000&quot;</span> /&gt;...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">someEvent</span>: someCondition ? <span class="string">&quot;click&quot;</span> : <span class="string">&quot;dbclick&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">someProps</span>: someCondition ? <span class="string">&quot;num&quot;</span> : <span class="string">&quot;price&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">handleSomeEvent</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// handle some event</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="如何设置动态class，动态style？"><a href="#如何设置动态class，动态style？" class="headerlink" title="如何设置动态class，动态style？"></a>如何设置动态class，动态style？</h3><ul><li><p>动态class对象：</p><p><code>&lt;div :class=&quot;&#123; &#39;is-active&#39;: true, &#39;red&#39;: isRed &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态class数组：</p><p><code>&lt;div :class=&quot;[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style对象：</p><p><code>&lt;div :style=&quot;&#123; color: textColor, fontSize: &#39;18px&#39; &#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>动态style数组：</p></li></ul><p><code>&lt;div :style=&quot;[&#123; color: textColor, fontSize: &#39;18px&#39; &#125;, &#123; fontWeight: &#39;300&#39; &#125;]&quot;&gt;&lt;/div&gt;</code></p><h3 id="v-if和v-show有何区别？"><a href="#v-if和v-show有何区别？" class="headerlink" title="v-if和v-show有何区别？"></a>v-if和v-show有何区别？</h3><ul><li><code>v-if</code>：通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</li><li><code>v-show</code>：通过控制dom元素的css样式来实现显隐，不会销毁</li><li>频繁或者大数量显隐使用 <code>v-show</code>，否则使用 <code>v-if</code></li></ul><h3 id="为什么v-if和v-for不建议用在同一标签？"><a href="#为什么v-if和v-for不建议用在同一标签？" class="headerlink" title="为什么v-if和v-for不建议用在同一标签？"></a>为什么v-if和v-for不建议用在同一标签？</h3><p>在Vue2中，<code>v-for</code>优先级是高于 <code>v-if</code>的，咱们来看例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in [1, 2, 3, 4, 5, 6, 7]&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;item !== 3&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的写法是 <code>v-for</code>和 <code>v-if</code>同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">computed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">list</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="computed和watch有何区别？"><a href="#computed和watch有何区别？" class="headerlink" title="computed和watch有何区别？"></a>computed和watch有何区别？</h3><ul><li><code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是 <code>多个变量</code>凑在一起计算出 <code>一个变量</code>，并且 <code>computed</code>具有 <code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行 <code>异步操作</code></li><li><code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是 <code>一个变量</code>的变化决定 <code>多个变量</code>的变化，<code>watch</code>可以进行 <code>异步操作</code></li><li>简单记就是：一般情况下 <code>computed</code>是 <code>多对一</code>，<code>watch</code>是 <code>一对多</code></li></ul><h3 id="computed如何实现传参？"><a href="#computed如何实现传参？" class="headerlink" title="computed如何实现传参？"></a>computed如何实现传参？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div&gt;&#123;&#123; <span class="title function_">total</span>(<span class="number">3</span>) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">total</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> n * <span class="variable language_">this</span>.<span class="property">num</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="watch有哪些属性，分别有什么用？"><a href="#watch有哪些属性，分别有什么用？" class="headerlink" title="watch有哪些属性，分别有什么用？"></a>watch有哪些属性，分别有什么用？</h3><p>当我们监听一个基本数据类型时：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    value () &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们监听一个引用数据类型时：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;</span><br><span class="line">       handler () &#123; <span class="comment">// 执行回调</span></span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 是否进行深度监听</span></span><br><span class="line">       <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// 是否初始执行handler函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch的immediate属性有什么用？"><a href="#watch的immediate属性有什么用？" class="headerlink" title="watch的immediate属性有什么用？"></a>watch的immediate属性有什么用？</h3><blockquote><p>比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">searchInputValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>immediate</code>完全可以这么写，当它为 <code>true</code>时，会初始执行一次</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">searchInputValue</span>:&#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="string">&#x27;getList&#x27;</span>,</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch监听一个对象时，如何排除某些属性的监听"><a href="#watch监听一个对象时，如何排除某些属性的监听" class="headerlink" title="watch监听一个对象时，如何排除某些属性的监听"></a>watch监听一个对象时，如何排除某些属性的监听</h3><blockquote><p>下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">params</span>)</span><br><span class="line">      .<span class="title function_">filter</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> ![<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>].<span class="title function_">includes</span>(_)) <span class="comment">// 排除对c，d属性的监听</span></span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span> vm.<span class="property">params</span>[_], handler, &#123;</span><br><span class="line">          <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">d</span>: <span class="number">4</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getList</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。"><a href="#State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。" class="headerlink" title="* State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。"></a>* State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</h3><ul><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="不需要响应式的数据应该怎么处理？"><a href="#不需要响应式的数据应该怎么处理？" class="headerlink" title="不需要响应式的数据应该怎么处理？"></a>不需要响应式的数据应该怎么处理？</h3><p>在我们的Vue开发中，会有一些数据，从始至终都 <code>未曾改变过</code>，这种 <code>死数据</code>，既然 <code>不改变</code>，那也就 <code>不需要对他做响应式处理</code>了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的 <code>死数据</code>，如果都进行响应式处理，那会消耗大量性能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：将数据定义在data之外</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list1</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list2</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list3</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list4</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list5</span> = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法二：Object.freeze()</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">list1</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list2</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list3</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list4</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        <span class="attr">list5</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="headerlink" title="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"></a>对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3><ul><li>原因：<code>Object.defineProperty</code>没有对对象的新属性进行属性劫持</li><li>对象新属性无法更新视图：使用 <code>Vue.$set(obj, key, value)</code>，组件中 <code>this.$set(obj, key, value)</code></li><li>删除属性无法更新视图：使用 <code>Vue.$delete(obj, key)</code>，组件中 <code>this.$delete(obj, key)</code></li></ul><h3 id="直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？"><a href="#直接arr-index-x3D-xxx无法更新视图怎么办？为什么？怎么办？" class="headerlink" title="直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？"></a>直接arr[index] &#x3D; xxx无法更新视图怎么办？为什么？怎么办？</h3><ul><li>原因：Vue没有对数组进行 <code>Object.defineProperty</code>的属性劫持，所以直接arr[index] &#x3D; xxx是无法更新视图的</li><li>使用数组的splice方法，<code>arr.splice(index, 1, item)</code></li><li>使用 <code>Vue.$set(arr, index, value)</code></li></ul><h3 id="为什么不建议用index做key，为什么不建议用随机数做key？"><a href="#为什么不建议用index做key，为什么不建议用随机数做key？" class="headerlink" title="为什么不建议用index做key，为什么不建议用随机数做key？"></a>为什么不建议用index做key，为什么不建议用随机数做key？</h3><p>举个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in list&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;&#123;&#123;item.<span class="property">name</span>&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">list</span>: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;124&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;小花&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;125&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小明&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">现在我执行 </span><br><span class="line">list.<span class="title function_">unshift</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;122&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;0&quot;</span>&gt;小明&lt;<span class="regexp">/div&gt;  &lt;div key=&quot;0&quot;&gt;小林&lt;/</span>div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                         <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能</span><br><span class="line"></span><br><span class="line">现在我们使用id来做key，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;123&quot;</span>&gt;小明&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">现在我执行 list.<span class="title function_">unshift</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;122&#x27;</span> &#125;)，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=<span class="string">&quot;122&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">                           &lt;div key=<span class="string">&quot;122&quot;</span>&gt;小林&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;123&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;124&quot;</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;125&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果</span><br></pre></td></tr></table></figure><p>用 <code>index</code>和用 <code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，很 <code>渣男</code>，也很消耗性能，所以，拒绝 <code>渣男</code>，选择 <code>老实人</code></p><h3 id="nextTick的原理"><a href="#nextTick的原理" class="headerlink" title="nextTick的原理"></a>nextTick的原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callbacks = []; <span class="comment">//回调函数</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pending = <span class="literal">false</span>; <span class="comment">//把标志还原为false</span></span><br><span class="line">    <span class="comment">// 依次执行回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        callbacks[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> timerFunc; <span class="comment">//先采用微任务并按照优先级优雅降级的方式实现异步刷新</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果支持promise</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(flushCallbacks);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// MutationObserver 主要是监听dom变化 也是一个异步方法</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks);</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">        <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前面都不支持 判断setImmediate</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setImmediate</span>(flushCallbacks);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 最后降级采用setTimeout</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    callbacks.<span class="title function_">push</span>(cb);</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">timerFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextTick的用处"><a href="#nextTick的用处" class="headerlink" title="nextTick的用处"></a>nextTick的用处</h3><p>我举个例子，在vue中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><p>我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是 <code>异步更新</code>的策略，通俗点说就是，<code>同一事件循环内</code>多次修改，会 <code>统一</code>进行一次 <code>视图更新</code>，这样才能节省性能嘛</p><p>看懂了上面，那你应该也看得懂下面的例子了吧：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;testDiv&quot;</span>&gt;&#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;小林&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 这里是啥呢</span></span><br></pre></td></tr></table></figure><p>答案是“小林”，前面说了，Vue是 <code>异步更新</code>，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">testDiv</span>.<span class="property">innerHTML</span>) <span class="comment">// 林三心</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue的SSR是什么？有什么好处？"><a href="#Vue的SSR是什么？有什么好处？" class="headerlink" title="Vue的SSR是什么？有什么好处？"></a>Vue的SSR是什么？有什么好处？</h3><ul><li><code>SSR</code>就是服务端渲染</li><li>基于 <code>nodejs serve</code>服务环境开发，所有 <code>html</code>代码在服务端渲染</li><li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码</li><li><code>SSR</code>首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好</li></ul><h3 id="Vue响应式是怎么实现的？"><a href="#Vue响应式是怎么实现的？" class="headerlink" title="Vue响应式是怎么实现的？"></a>Vue响应式是怎么实现的？</h3><p>整体思路：数据劫持+观察者模式</p><p>对象内部通过 <code> defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 <code>dep</code>属性，存放他所依赖的 <code> watcher</code>（依赖收集），当属性变化后会通知自己对应的 <code> watcher</code> 去更新(派发更新)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; arrayMethods &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./array&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="variable language_">this</span>,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            value.<span class="property">__proto__</span> = arrayMethods</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">walk</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> key = keys[i]</span><br><span class="line">            <span class="keyword">const</span> value = data[key]</span><br><span class="line">            <span class="title function_">defineReactive</span>(data, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">observeArray</span>(<span class="params">items</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">observe</span>(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childOb = <span class="title function_">observe</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">                        <span class="title function_">dependArray</span>(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === value) <span class="keyword">return</span></span><br><span class="line">            <span class="title function_">observe</span>(newVal)</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dependArray</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        e = value[i]</span><br><span class="line"></span><br><span class="line">        e &amp;&amp; e.<span class="property">__ob__</span> &amp;&amp; e.<span class="property">__ob__</span>.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.js</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    arrayMethods[method] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = arrayProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> inserted</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">                inserted = args</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">                inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line"></span><br><span class="line">        ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为什么只对对象劫持，而要对数组进行方法重写？"><a href="#为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="为什么只对对象劫持，而要对数组进行方法重写？"></a>为什么只对对象劫持，而要对数组进行方法重写？</h3><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p><h3 id="Vue-set方法的原理"><a href="#Vue-set方法的原理" class="headerlink" title="Vue.set方法的原理"></a>Vue.set方法的原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 判断谁大谁小</span></span><br><span class="line">        target.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(target.<span class="property">length</span>, key)</span><br><span class="line">        <span class="comment">// 执行splice</span></span><br><span class="line">        target.<span class="title function_">splice</span>(key, <span class="number">1</span>, val)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此对象没有不是响应式对象，直接设置并返回</span></span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> target.<span class="property"><span class="keyword">prototype</span></span>) || !ob) &#123;</span><br><span class="line">        target[key] = val</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，新增属性，并响应式处理</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(target, key, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-delete方法的原理？"><a href="#Vue-delete方法的原理？" class="headerlink" title="Vue.delete方法的原理？"></a>Vue.delete方法的原理？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">del</span> (target, key) &#123;</span><br><span class="line">    <span class="comment">// 判断是否为数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 执行splice</span></span><br><span class="line">        target.<span class="title function_">splice</span>(key, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象本身就没有这个属性，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，删除这个属性</span></span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是响应式对象，不是的话，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!ob) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 是的话，删除后要通知视图更新</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果子组件改变props里的数据会发生什么"><a href="#如果子组件改变props里的数据会发生什么" class="headerlink" title="如果子组件改变props里的数据会发生什么"></a>如果子组件改变props里的数据会发生什么</h3><ul><li>改变的props数据是基本类型</li></ul><blockquote><p>如果修改的是基本类型，则会报错</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047859eda3bf47a5930dd0b28e842017~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="0458e2ff1538ee85d42953cec9a94ca.png"></p><ul><li>改变的props数据是引用类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">item</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不报错，并且父级数据会跟着变</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">name</span> = <span class="string">&#x27;sanxin&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 会报错，跟基础类型报错一样</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span> = <span class="string">&#x27;sss&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="props怎么自定义验证"><a href="#props怎么自定义验证" class="headerlink" title="props怎么自定义验证"></a>props怎么自定义验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="comment">// 返回值为false则验证不通过，报错</span></span><br><span class="line">          <span class="keyword">return</span> [</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">          ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="审查元素时发现data-v-xxxxx，这是啥？"><a href="#审查元素时发现data-v-xxxxx，这是啥？" class="headerlink" title="审查元素时发现data-v-xxxxx，这是啥？"></a>审查元素时发现data-v-xxxxx，这是啥？</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff63f90f2d924ff6b20622a2d05ba367~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><blockquote><p>这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p></blockquote><h3 id="vue的hook的使用"><a href="#vue的hook的使用" class="headerlink" title="vue的hook的使用"></a>vue的hook的使用</h3><ul><li>同一组件中使用</li></ul><blockquote><p>这是我们常用的使用定时器的方式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="attr">timer</span>:<span class="literal">null</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//具体执行内容</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">beforeDestory</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//具体执行代码</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">      &#125;,<span class="number">1000</span>);</span><br><span class="line">      <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7.2 父子组件使用</li></ul><blockquote><p>如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;rl-child @childMounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;childMounted&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用hook的话可以更方便：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;rl-child @<span class="attr">hook</span>:mounted=<span class="string">&quot;childMountedHandle&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  <span class="title function_">childMountedHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="provide和inject是响应式的吗？"><a href="#provide和inject是响应式的吗？" class="headerlink" title="provide和inject是响应式的吗？"></a>provide和inject是响应式的吗？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="comment">// keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型</span></span><br><span class="line">      <span class="attr">keyName</span>: <span class="variable language_">this</span>.<span class="property">changeValue</span> <span class="comment">// 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]</span></span><br><span class="line">   <span class="comment">// keyName: &#x27;test&#x27; value 如果是基本类型，就无法实现响应式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;改变后的名字-李四&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后代组件</span></span><br><span class="line">  <span class="attr">inject</span>:[<span class="string">&#x27;keyName&#x27;</span>]</span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">keyName</span>) <span class="comment">// 改变后的名字-李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue的el属性和-mount优先级？"><a href="#Vue的el属性和-mount优先级？" class="headerlink" title="Vue的el属性和$mount优先级？"></a>Vue的el属性和$mount优先级？</h3><blockquote><p>比如下面这种情况，Vue会渲染到哪个节点上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#ggg&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这是官方的一张图，可以看出 <code>el</code>和 <code>$mount</code>同时存在时，<code>el优先级</code> &gt; <code>$mount</code></p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6331091cb145459e0b543c76e9bfc6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="自定义v-model"><a href="#自定义v-model" class="headerlink" title="自定义v-model"></a>自定义v-model</h3><blockquote><p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="attr">default</span>: &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算变量时，methods和computed哪个好？"><a href="#计算变量时，methods和computed哪个好？" class="headerlink" title="计算变量时，methods和computed哪个好？"></a>计算变量时，methods和computed哪个好？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch1()&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch2&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;index&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">         index: 0</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    howMuch1() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">    howMuch2() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>computed</code>会好一些，因为computed会有 <code>缓存</code>。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;Vue的优点？Vue的缺点？&quot;&gt;&lt;a href=&quot;#Vue的优点？Vue的缺点？&quot; class=&quot;headerlink&quot; title=&quot;Vue的优点？Vue的缺点？&quot;&gt;&lt;/a&gt;Vue的优点？Vue的缺点？&lt;/h3&gt;&lt;p&gt;优点：渐进式，组件化，轻量级，虚拟</summary>
      
    
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/categories/vue/"/>
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/tags/vue/"/>
    
    <category term="VSCode" scheme="https://github.com/SUPERQ314/tags/VSCode/"/>
    
    <category term="扩展插件" scheme="https://github.com/SUPERQ314/tags/%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vuejs目录结构</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/vue/vuejs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/vue/vuejs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2022-06-17T10:25:33.441Z</published>
    <updated>2022-04-16T08:14:07.320Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://www.runoob.com/wp-content/uploads/2017/01/B6E593E3-F284-4C58-A610-94C6ACDAD485.jpg" alt="img"></p><table><thead><tr><th>目录&#x2F;文件</th><th>说明</th></tr></thead><tbody><tr><td>build</td><td>项目构建(webpack)相关代码</td></tr><tr><td>config</td><td>配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td>node_modules</td><td>npm 加载的项目依赖模块</td></tr><tr><td>src</td><td>要开发的目录，基本上要做的事情都在这个目录里。<br />里面包含了几个目录及文件：<br />* assets: 放置一些图片，如logo等。<br />* components: 目录里面放了一个组件文件，可以不用。<br />* App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。<br />* main.js: 项目的核心文件。</td></tr><tr><td>static</td><td>静态资源目录，如图片、字体等。</td></tr><tr><td>test</td><td>初始测试目录，可删除</td></tr><tr><td>.xxxx文件</td><td>这些是一些配置文件，包括语法配置，git配置等。</td></tr><tr><td>index.html</td><td>首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td>package.json</td><td>项目配置文件。</td></tr><tr><td>README.md</td><td>项目的说明文档，markdown 格式</td></tr></tbody></table><p>重新打开页面 <a href="http://localhost:8080/%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BF%AE%E6%94%B9%E5%90%8E%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%EF%BC%8C%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA![img](https://www.runoob.com/wp-content/uploads/2017/01/AEDE7289-0479-4F14-A9C9-898470E5620E.jpg)">http://localhost:8080/，一般修改后会自动刷新，显示效果如下所示![img](https://www.runoob.com/wp-content/uploads/2017/01/AEDE7289-0479-4F14-A9C9-898470E5620E.jpg)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2017/01/B6E593E3-F284-4C58-A610-94C6ACDAD485.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;</summary>
      
    
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/categories/vue/"/>
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/tags/vue/"/>
    
    <category term="VSCode" scheme="https://github.com/SUPERQ314/tags/VSCode/"/>
    
    <category term="扩展插件" scheme="https://github.com/SUPERQ314/tags/%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>VSCode开发 Vue 必备插件</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/vue/VSCode%E5%BC%80%E5%8F%91vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/vue/VSCode%E5%BC%80%E5%8F%91vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/</id>
    <published>2022-06-17T10:25:33.382Z</published>
    <updated>2022-04-16T07:36:59.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vetur"><a href="#vetur" class="headerlink" title="vetur"></a>vetur</h3><p>vetur能够实现在 .vue 文件中：</p><ul><li>语法错误检查，包括 CSS&#x2F;SCSS&#x2F;LESS&#x2F;Javascript&#x2F;TypeScript</li><li>语法高亮，包括 html&#x2F;jade&#x2F;pug css&#x2F;sass&#x2F;scss&#x2F;less&#x2F;stylus js&#x2F;ts emmet 支持</li><li>代码自动补全（目前还是初级阶段），包括 HTML&#x2F;CSS&#x2F;SCSS&#x2F;LESS&#x2F;JavaScript&#x2F;TypeScript 配合 ESLint 插件使用效果更佳</li></ul><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><ul><li>eslint插件能够检测代码语法问题，与格式问题，对项目代码风格统一至关重要。</li></ul><h3 id="EditorConfig-for-Visual-Studio-Code"><a href="#EditorConfig-for-Visual-Studio-Code" class="headerlink" title="EditorConfig for Visual Studio Code"></a>EditorConfig for Visual Studio Code</h3><ul><li>EditorConfig 是一种被各种编辑器广泛支持的配置，使用此配置有助于项目在整个团队中保持一致的代码风格。</li></ul><h3 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h3><ul><li>在编辑器中输入路径时，自动补全。</li></ul><h2 id="View-In-Browser"><a href="#View-In-Browser" class="headerlink" title="View In Browser"></a>View In Browser</h2><ul><li>在浏览器中查看静态文件。</li></ul><h3 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h3><p>　　这个插件很有用，安装之后可以打开一个简单的服务器。而且还会自动更新。安装之后，打开项目文件夹，再在文件上点击右键就会出现一个Open with Live Server的选项，</p><p>就会自动打开浏览器了。默认端口号是5500</p><h3 id="GitLens—–-Git-Supercharged-必备"><a href="#GitLens—–-Git-Supercharged-必备" class="headerlink" title="GitLens—– Git Supercharged(必备)"></a>GitLens—– Git Supercharged(必备)</h3><ul><li>查看git文件提交历史。</li></ul><h3 id="Document-This"><a href="#Document-This" class="headerlink" title="Document This"></a>Document This</h3><ul><li>注释文档生成</li></ul><h3 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h3><ul><li>直接在vscode里面进行调试js文件，跟谷歌的控制台是一样的功能，下载了它就不用打开浏览器的控制台就能进行打断点。</li><li>需要配置vscode的lauch.json的谷歌调试相关配置</li></ul><h3 id="HTML-CSS-Support"><a href="#HTML-CSS-Support" class="headerlink" title="HTML CSS Support"></a>HTML CSS Support</h3><ul><li>在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！</li></ul><h2 id="JavaScript-Snippet-Pack"><a href="#JavaScript-Snippet-Pack" class="headerlink" title="JavaScript Snippet Pack"></a>JavaScript Snippet Pack</h2><ul><li>针对js的插件，包含了js的常用语法关键字，很实用。</li></ul><h3 id="HTML-Snippets"><a href="#HTML-Snippets" class="headerlink" title="HTML Snippets"></a>HTML Snippets</h3><ul><li>这款插件包含html标签，非常全，很实用。</li></ul><h3 id="One-Monokai-Theme"><a href="#One-Monokai-Theme" class="headerlink" title="One Monokai Theme"></a>One Monokai Theme</h3><ul><li>能够选择自己喜欢的颜色主题，来编写代码，比较喜欢用的是monokai。</li></ul><h3 id="vscode-icons-很好用"><a href="#vscode-icons-很好用" class="headerlink" title="vscode-icons(很好用)"></a>vscode-icons(很好用)</h3><ul><li>能够选择自己喜欢的图标主题，比较推荐vscode icons</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vetur&quot;&gt;&lt;a href=&quot;#vetur&quot; class=&quot;headerlink&quot; title=&quot;vetur&quot;&gt;&lt;/a&gt;vetur&lt;/h3&gt;&lt;p&gt;vetur能够实现在 .vue 文件中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误检查，包括 CSS&amp;#x2F;SCSS&amp;</summary>
      
    
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/categories/vue/"/>
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/tags/vue/"/>
    
    <category term="VSCode" scheme="https://github.com/SUPERQ314/tags/VSCode/"/>
    
    <category term="扩展插件" scheme="https://github.com/SUPERQ314/tags/%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Axios封装 + API接口管理</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/vue/Axios%E5%B0%81%E8%A3%85%20+%20API%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/vue/Axios%E5%B0%81%E8%A3%85%20+%20API%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86/</id>
    <published>2022-06-17T10:25:33.363Z</published>
    <updated>2022-05-01T14:22:20.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Axios封装-API接口管理"><a href="#Axios封装-API接口管理" class="headerlink" title="Axios封装 + API接口管理"></a>Axios封装 + API接口管理</h1><p>axios的封装和api接口的统一管理，其实主要目的就是在帮助我们简化代码和利于后期的更新维护。</p><h2 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h2><p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。</p><p>优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install axios; // 安装axios复制代码</span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装axios，api.js用来统一管理接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在http.js中引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;; // 引入axios</span><br><span class="line">import QS from &#x27;qs&#x27;; // 引入qs模块，用来序列化post类型的数据</span><br><span class="line">// vant的toast提示框组件，大家可根据自己的ui组件更改。</span><br><span class="line">import &#123; Toast &#125; from &#x27;vant&#x27;; </span><br></pre></td></tr></table></figure><h3 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h3><p>项目环境可能有开发环境、测试环境和生产环境。</p><p>通过node的环境变量来匹配我默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 环境的切换</span><br><span class="line">if (process.env.NODE_ENV == &#x27;development&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;https://www.baidu.com&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;https://www.ceshi.com&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;https://www.production.com&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求超时"><a href="#设置请求超时" class="headerlink" title="设置请求超时"></a>设置请求超时</h3><p>通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.timeout = 10000;</span><br></pre></td></tr></table></figure><h3 id="post请求头的设置"><a href="#post请求头的设置" class="headerlink" title="post请求头的设置"></a>post请求头的设置</h3><p>post请求的时候，加上一个请求头，在这里进行一个默认的设置，即设置post的请求头为 <code>application/x-www-form-urlencoded;charset=UTF-8</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;</span><br></pre></td></tr></table></figure><ul><li>请求拦截</li></ul><p>在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p><h3 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 先导入vuex,因为我们要使用到里面的状态对象</span><br><span class="line">// vuex的路径根据自己的路径去写</span><br><span class="line">import store from &#x27;@/store/index&#x27;;</span><br><span class="line"></span><br><span class="line">// 请求拦截器axios.interceptors.request.use(  </span><br><span class="line">    config =&gt; &#123;  </span><br><span class="line">        // 每次发送请求之前判断vuex中是否存在token  </span><br><span class="line">        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况</span><br><span class="line">        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 </span><br><span class="line">        const token = store.state.token;  </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);  </span><br><span class="line">        return config;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    error =&gt; &#123;  </span><br><span class="line">        return Promise.error(error);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！</p><h3 id="响应的拦截"><a href="#响应的拦截" class="headerlink" title="响应的拦截"></a>响应的拦截</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use(  </span><br><span class="line">    response =&gt; &#123;   </span><br><span class="line">        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据   </span><br><span class="line">        // 否则的话抛出错误</span><br><span class="line">        if (response.status === 200) &#123;  </span><br><span class="line">            return Promise.resolve(response);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return Promise.reject(response);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    // 服务器状态码不是2开头的的情况</span><br><span class="line">    // 这里可以跟你们的后台开发人员协商好统一的错误状态码  </span><br><span class="line">    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等</span><br><span class="line">    // 下面列举几个常见的操作，其他需求可自行扩展</span><br><span class="line">    error =&gt; &#123;  </span><br><span class="line">        if (error.response.status) &#123;  </span><br><span class="line">            switch (error.response.status) &#123;  </span><br><span class="line">                // 401: 未登录</span><br><span class="line">                // 未登录则跳转登录页面，并携带当前页面的路径</span><br><span class="line">                // 在登录成功后返回当前页面，这一步需要在登录页操作。  </span><br><span class="line">                case 401:    </span><br><span class="line">                    router.replace(&#123;        </span><br><span class="line">                        path: &#x27;/login&#x27;,        </span><br><span class="line">                        query: &#123; </span><br><span class="line">                            redirect: router.currentRoute.fullPath </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                // 403 token过期</span><br><span class="line">                // 登录过期对用户进行提示</span><br><span class="line">                // 清除本地token和清空vuex中token对象</span><br><span class="line">                // 跳转登录页面  </span><br><span class="line">                case 403:</span><br><span class="line">                     Toast(&#123;</span><br><span class="line">                        message: &#x27;登录过期，请重新登录&#x27;,</span><br><span class="line">                        duration: 1000,</span><br><span class="line">                        forbidClick: true</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // 清除token</span><br><span class="line">                    localStorage.removeItem(&#x27;token&#x27;);</span><br><span class="line">                    store.commit(&#x27;loginSuccess&#x27;, null);</span><br><span class="line">                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 </span><br><span class="line">                    setTimeout(() =&gt; &#123;        </span><br><span class="line">                        router.replace(&#123;            </span><br><span class="line">                            path: &#x27;/login&#x27;,            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;        </span><br><span class="line">                        &#125;);    </span><br><span class="line">                    &#125;, 1000);    </span><br><span class="line">                    break; </span><br><span class="line"></span><br><span class="line">                // 404请求不存在</span><br><span class="line">                case 404:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: &#x27;网络请求不存在&#x27;,</span><br><span class="line">                        duration: 1500,</span><br><span class="line">                        forbidClick: true</span><br><span class="line">                    &#125;);</span><br><span class="line">                    break;</span><br><span class="line">                // 其他错误，直接抛出错误提示</span><br><span class="line">                default:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: error.response.data.message,</span><br><span class="line">                        duration: 1500,</span><br><span class="line">                        forbidClick: true</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            return Promise.reject(error.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。</p><p><strong>要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。</strong></p><h3 id="封装get方法和post方法"><a href="#封装get方法和post方法" class="headerlink" title="封装get方法和post方法"></a>封装get方法和post方法</h3><p>我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post。</p><p> <strong>get方法</strong> ：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * get方法，对应get请求</span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址]</span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数]</span><br><span class="line"> */</span><br><span class="line">export function get(url, params)&#123;  </span><br><span class="line">    return new Promise((resolve, reject) =&gt;&#123;  </span><br><span class="line">        axios.get(url, &#123;  </span><br><span class="line">            params: params  </span><br><span class="line">        &#125;).then(res =&gt; &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;).catch(err =&gt;&#123;</span><br><span class="line">            reject(err.data)  </span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;);&#125;</span><br></pre></td></tr></table></figure><p> <strong>post方法：</strong> 原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * post方法，对应post请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> */</span><br><span class="line">export function post(url, params) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         axios.post(url, QS.stringify(params))</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err =&gt;&#123;</span><br><span class="line">            reject(err.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小细节说下，<code>axios.get()</code>方法和 <code>axios.post()</code>在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！</p><h2 id="axios的封装基本就完成了，下面再简单说下api的统一管理。"><a href="#axios的封装基本就完成了，下面再简单说下api的统一管理。" class="headerlink" title="axios的封装基本就完成了，下面再简单说下api的统一管理。"></a>axios的封装基本就完成了，下面再简单说下api的统一管理。</h2><p>整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。</p><ul><li>首先我们在api.js中引入我们封装的get和post方法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**   </span><br><span class="line"> * api接口统一管理</span><br><span class="line"> */</span><br><span class="line">import &#123; get, post &#125; from &#x27;./http&#x27;</span><br></pre></td></tr></table></figure><p>现在，例如我们有这样一个接口，是一个post请求：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.baiodu.com/api/v1/users/my_address/address_edit_before</span><br></pre></td></tr></table></figure><p>我们可以在api.js中这样封装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const apiAddress = p =&gt; post(&#x27;api/v1/users/my_address/address_edit_before&#x27;, p);</span><br></pre></td></tr></table></figure><p>我们定义了一个 <code>apiAddress</code>方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的 <code>post</code>方法，<code>post</code>方法的第一个参数是我们的接口地址，第二个参数是 <code>apiAddress</code>的p参数，即请求接口时携带的参数对象。最后通过export导出 <code>apiAddress</code>。</p><p>然后在我们的页面中可以这样调用我们的api接口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; apiAddress &#125; from &#x27;@/request/api&#x27;;// 导入我们的api接口</span><br><span class="line">export default &#123;  </span><br><span class="line">    name: &#x27;Address&#x27;,  </span><br><span class="line">    created () &#123;</span><br><span class="line">        this.onLoad();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  </span><br><span class="line">        // 获取数据  </span><br><span class="line">        onLoad() &#123;</span><br><span class="line">            // 调用api接口，并且提供了两个参数  </span><br><span class="line">            apiAddress(&#123;    </span><br><span class="line">                type: 0,    </span><br><span class="line">                sort: 1  </span><br><span class="line">            &#125;).then(res =&gt; &#123;</span><br><span class="line">                // 获取数据成功后的其他操作</span><br><span class="line">                ………………  </span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的api接口，就在pai.js中继续往下面扩展就可以了。友情提示，为每个接口写好注释哦！！！</p><p>api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。</p><p>好了，最后把完成的axios封装代码奉上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**axios封装</span><br><span class="line"> * 请求拦截、相应拦截、错误统一处理</span><br><span class="line"> */</span><br><span class="line">import axios from &#x27;axios&#x27;;import QS from &#x27;qs&#x27;;</span><br><span class="line">import &#123; Toast &#125; from &#x27;vant&#x27;;</span><br><span class="line">import store from &#x27;../store/index&#x27;</span><br><span class="line"></span><br><span class="line">// 环境的切换</span><br><span class="line">if (process.env.NODE_ENV == &#x27;development&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;/api&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123;  </span><br><span class="line">    axios.defaults.baseURL = &#x27;http://api.123dailu.com/&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请求超时时间</span><br><span class="line">axios.defaults.timeout = 10000;</span><br><span class="line"></span><br><span class="line">// post请求头</span><br><span class="line">axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;</span><br><span class="line"></span><br><span class="line">// 请求拦截器</span><br><span class="line">axios.interceptors.request.use(  </span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了</span><br><span class="line">        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</span><br><span class="line">        const token = store.state.token;  </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);  </span><br><span class="line">        return config;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    error =&gt; &#123;  </span><br><span class="line">        return Promise.error(error);  </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use(  </span><br><span class="line">    response =&gt; &#123;  </span><br><span class="line">        if (response.status === 200) &#123;  </span><br><span class="line">            return Promise.resolve(response);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return Promise.reject(response);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    // 服务器状态码不是200的情况  </span><br><span class="line">    error =&gt; &#123;  </span><br><span class="line">        if (error.response.status) &#123;  </span><br><span class="line">            switch (error.response.status) &#123;  </span><br><span class="line">                // 401: 未登录  </span><br><span class="line">                // 未登录则跳转登录页面，并携带当前页面的路径  </span><br><span class="line">                // 在登录成功后返回当前页面，这一步需要在登录页操作。  </span><br><span class="line">                case 401:  </span><br><span class="line">                    router.replace(&#123;    </span><br><span class="line">                        path: &#x27;/login&#x27;,    </span><br><span class="line">                        query: &#123; redirect: router.currentRoute.fullPath &#125; </span><br><span class="line">                    &#125;);</span><br><span class="line">                    break;</span><br><span class="line">                // 403 token过期  </span><br><span class="line">                // 登录过期对用户进行提示  </span><br><span class="line">                // 清除本地token和清空vuex中token对象  </span><br><span class="line">                // 跳转登录页面  </span><br><span class="line">                case 403:   </span><br><span class="line">                    Toast(&#123;    </span><br><span class="line">                        message: &#x27;登录过期，请重新登录&#x27;,    </span><br><span class="line">                        duration: 1000,    </span><br><span class="line">                        forbidClick: true  </span><br><span class="line">                    &#125;);  </span><br><span class="line">                    // 清除token  </span><br><span class="line">                    localStorage.removeItem(&#x27;token&#x27;);  </span><br><span class="line">                    store.commit(&#x27;loginSuccess&#x27;, null);  </span><br><span class="line">                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面</span><br><span class="line">                    setTimeout(() =&gt; &#123;    </span><br><span class="line">                        router.replace(&#123;        </span><br><span class="line">                            path: &#x27;/login&#x27;,        </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;    </span><br><span class="line">                        &#125;);  </span><br><span class="line">                    &#125;, 1000);  </span><br><span class="line">                    break; </span><br><span class="line">                // 404请求不存在  </span><br><span class="line">                case 404:  </span><br><span class="line">                    Toast(&#123;    </span><br><span class="line">                        message: &#x27;网络请求不存在&#x27;,    </span><br><span class="line">                        duration: 1500,    </span><br><span class="line">                        forbidClick: true  </span><br><span class="line">                    &#125;);  </span><br><span class="line">                break;  </span><br><span class="line">                // 其他错误，直接抛出错误提示  </span><br><span class="line">                default:  </span><br><span class="line">                    Toast(&#123;    </span><br><span class="line">                        message: error.response.data.message,    </span><br><span class="line">                        duration: 1500,    </span><br><span class="line">                        forbidClick: true  </span><br><span class="line">                    &#125;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            return Promise.reject(error.response);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">/** </span><br><span class="line"> * get方法，对应get请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> */</span><br><span class="line">export function get(url, params)&#123;  </span><br><span class="line">    return new Promise((resolve, reject) =&gt;&#123;  </span><br><span class="line">        axios.get(url, &#123;  </span><br><span class="line">            params: params  </span><br><span class="line">        &#125;)  </span><br><span class="line">        .then(res =&gt; &#123;  </span><br><span class="line">            resolve(res.data);  </span><br><span class="line">        &#125;)  </span><br><span class="line">        .catch(err =&gt; &#123;  </span><br><span class="line">            reject(err.data)  </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/** </span><br><span class="line"> * post方法，对应post请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> */</span><br><span class="line">export function post(url, params) &#123;  </span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;   </span><br><span class="line">        axios.post(url, QS.stringify(params))  </span><br><span class="line">        .then(res =&gt; &#123;  </span><br><span class="line">            resolve(res.data);  </span><br><span class="line">        &#125;)  </span><br><span class="line">        .catch(err =&gt; &#123;  </span><br><span class="line">            reject(err.data)  </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="axios封装的优化"><a href="#axios封装的优化" class="headerlink" title="axios封装的优化"></a>axios封装的优化</h1><p>axios的封装根据需求的不同而不同。这里非常感谢评论里一些很中肯的建议，我也对此进行了思考和针对不同需求的改善。主要有以下改变：</p><p><strong>1.优化axios封装，去掉之前的get和post</strong></p><p><strong>2.断网情况处理</strong></p><p><strong>3.更加模块化的api管理</strong></p><p><strong>4.接口域名有多个的情况</strong></p><p><strong>5.api挂载到vue.prototype上省去引入的步骤</strong></p><p>http.js中axios封装的优化，先直接贴代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * axios封装</span><br><span class="line"> * 请求拦截、响应拦截、错误统一处理</span><br><span class="line"> */</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">import router from &#x27;../router&#x27;;</span><br><span class="line">import store from &#x27;../store/index&#x27;;</span><br><span class="line">import &#123; Toast &#125; from &#x27;vant&#x27;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 提示函数 </span><br><span class="line"> * 禁止点击蒙层、显示一秒后关闭</span><br><span class="line"> */</span><br><span class="line">const tip = msg =&gt; &#123;  </span><br><span class="line">    Toast(&#123;  </span><br><span class="line">        message: msg,  </span><br><span class="line">        duration: 1000,  </span><br><span class="line">        forbidClick: true  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 跳转登录页</span><br><span class="line"> * 携带当前页面路由，以期在登录页面完成登录后返回当前页面</span><br><span class="line"> */</span><br><span class="line">const toLogin = () =&gt; &#123;</span><br><span class="line">    router.replace(&#123;</span><br><span class="line">        path: &#x27;/login&#x27;,  </span><br><span class="line">        query: &#123;</span><br><span class="line">            redirect: router.currentRoute.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 请求失败后的错误统一处理 </span><br><span class="line"> * @param &#123;Number&#125; status 请求失败的状态码</span><br><span class="line"> */</span><br><span class="line">const errorHandle = (status, other) =&gt; &#123;</span><br><span class="line">    // 状态码判断</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        // 401: 未登录状态，跳转登录页</span><br><span class="line">        case 401:</span><br><span class="line">            toLogin();</span><br><span class="line">            break;</span><br><span class="line">        // 403 token过期</span><br><span class="line">        // 清除token并跳转登录页</span><br><span class="line">        case 403:</span><br><span class="line">            tip(&#x27;登录过期，请重新登录&#x27;);</span><br><span class="line">            localStorage.removeItem(&#x27;token&#x27;);</span><br><span class="line">            store.commit(&#x27;loginSuccess&#x27;, null);</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                toLogin();</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">            break;</span><br><span class="line">        // 404请求不存在</span><br><span class="line">        case 404:</span><br><span class="line">            tip(&#x27;请求的资源不存在&#x27;); </span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            console.log(other);   </span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line">// 创建axios实例</span><br><span class="line">var instance = axios.create(&#123;    timeout: 1000 * 12&#125;);</span><br><span class="line">// 设置post请求头</span><br><span class="line">instance.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;</span><br><span class="line">/** </span><br><span class="line"> * 请求拦截器 </span><br><span class="line"> * 每次请求前，如果存在token则在请求头中携带token </span><br><span class="line"> */ </span><br><span class="line">instance.interceptors.request.use(  </span><br><span class="line">    config =&gt; &#123;  </span><br><span class="line">        // 登录流程控制中，根据本地是否存在token判断用户的登录情况  </span><br><span class="line">        // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token  </span><br><span class="line">        // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码  </span><br><span class="line">        // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。  </span><br><span class="line">        const token = store.state.token;  </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);  </span><br><span class="line">        return config;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    error =&gt; Promise.error(error))</span><br><span class="line"></span><br><span class="line">// 响应拦截器</span><br><span class="line">instance.interceptors.response.use(  </span><br><span class="line">    // 请求成功</span><br><span class="line">    res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res),  </span><br><span class="line">    // 请求失败</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        const &#123; response &#125; = error;</span><br><span class="line">        if (response) &#123;</span><br><span class="line">            // 请求已发出，但是不在2xx的范围 </span><br><span class="line">            errorHandle(response.status, response.data.message);</span><br><span class="line">            return Promise.reject(response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 处理断网的情况</span><br><span class="line">            // eg:请求超时或断网时，更新state的network状态</span><br><span class="line">            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏</span><br><span class="line">            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明</span><br><span class="line">            if (!window.navigator.onLine) &#123;</span><br><span class="line">               store.commit(&#x27;changeNetwork&#x27;, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Promise.reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">export default instance;</span><br></pre></td></tr></table></figure><p>这个axios和之前的大同小异，做了如下几点改变：</p><p>1.去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。</p><p>2.去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。</p><p>3.增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。</p><p>4.公用函数进行抽出，简化代码，尽量保证单一职责原则。</p><p><strong>下面说下api这块，考虑到一下需求：</strong></p><p>1.更加模块化</p><p>2.更方便多人开发，有效减少解决命名冲突</p><p>3.处理接口域名有多个情况</p><p>这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。</p><p>先放index.js代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * api接口的统一出口</span><br><span class="line"> */</span><br><span class="line">// 文章模块接口</span><br><span class="line">import article from &#x27;@/api/article&#x27;;</span><br><span class="line">// 其他模块的接口……</span><br><span class="line"></span><br><span class="line">// 导出接口</span><br><span class="line">export default &#123;  </span><br><span class="line">    article,</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。</p><p>base.js:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口域名的管理</span><br><span class="line"> */</span><br><span class="line">const base = &#123;  </span><br><span class="line">    sq: &#x27;https://xxxx111111.com/api/v1&#x27;,  </span><br><span class="line">    bd: &#x27;http://xxxxx22222.com/api&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default base;</span><br></pre></td></tr></table></figure><p>通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。</p><p>最后就是接口模块的说明，例如上面的article.js:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * article模块接口列表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import base from &#x27;./base&#x27;; // 导入接口域名列表</span><br><span class="line">import axios from &#x27;@/utils/http&#x27;; // 导入http中创建的axios实例</span><br><span class="line">import qs from &#x27;qs&#x27;; // 根据需求是否导入qs模块</span><br><span class="line"></span><br><span class="line">const article = &#123;  </span><br><span class="line">    // 新闻列表  </span><br><span class="line">    articleList () &#123;  </span><br><span class="line">        return axios.get(`$&#123;base.sq&#125;/topics`);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    // 新闻详情,演示  </span><br><span class="line">    articleDetail (id, params) &#123;  </span><br><span class="line">        return axios.get(`$&#123;base.sq&#125;/topic/$&#123;id&#125;`, &#123;  </span><br><span class="line">            params: params  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;,</span><br><span class="line">    // post提交  </span><br><span class="line">    login (params) &#123;  </span><br><span class="line">        return axios.post(`$&#123;base.sq&#125;/accesstoken`, qs.stringify(params));  </span><br><span class="line">    &#125;</span><br><span class="line">    // 其他接口…………</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default article;</span><br></pre></td></tr></table></figure><p>1.通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对post请求时提交的数据进行一个qs序列化的处理等。</p><p>2.请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，axios文档说的很清楚，这个顺序是：在 <code>lib/defaults.js</code> 找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。</p><p>3.restful风格的接口，也可以通过这种方式灵活的设置api接口地址。</p><p>最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27; // 导入路由文件</span><br><span class="line">import store from &#x27;./store&#x27; // 导入vuex文件</span><br><span class="line">import api from &#x27;./api&#x27; // 导入api接口</span><br><span class="line"></span><br><span class="line">Vue.prototype.$api = api; // 将api挂载到vue的原型上</span><br></pre></td></tr></table></figure><p>然后我们可以在页面中这样调用接口，eg：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;  </span><br><span class="line">    onLoad(id) &#123;  </span><br><span class="line">        this.$api.article.articleDetail(id, &#123;  </span><br><span class="line">            api: 123  </span><br><span class="line">        &#125;).then(res=&gt; &#123;</span><br><span class="line">            // 执行某些操作  </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再提一下断网的处理，这里只做一个简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">        &lt;div v-if=&quot;!network&quot;&gt;  </span><br><span class="line">            &lt;h3&gt;我没网了&lt;/h3&gt;  </span><br><span class="line">            &lt;div @click=&quot;onRefresh&quot;&gt;刷新&lt;/div&gt;  </span><br><span class="line">        &lt;/div&gt;  </span><br><span class="line">        &lt;router-view/&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class="line">    export default &#123;  </span><br><span class="line">        name: &#x27;App&#x27;,  </span><br><span class="line">        computed: &#123;  </span><br><span class="line">            ...mapState([&#x27;network&#x27;])  </span><br><span class="line">        &#125;,  </span><br><span class="line">        methods: &#123;  </span><br><span class="line">            // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的</span><br><span class="line">            onRefresh () &#123;  </span><br><span class="line">                this.$router.replace(&#x27;/refresh&#x27;)  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其 <code>beforeRouteEnter</code>钩子中再返回当前页面。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// refresh.vue</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    next(vm =&gt; &#123;  </span><br><span class="line">        vm.$router.replace(from.fullPath)  </span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Axios封装-API接口管理&quot;&gt;&lt;a href=&quot;#Axios封装-API接口管理&quot; class=&quot;headerlink&quot; title=&quot;Axios封装 + API接口管理&quot;&gt;&lt;/a&gt;Axios封装 + API接口管理&lt;/h1&gt;&lt;p&gt;axios的封装和api接口</summary>
      
    
    
    
    <category term="vue" scheme="https://github.com/SUPERQ314/categories/vue/"/>
    
    
    <category term="axios" scheme="https://github.com/SUPERQ314/tags/axios/"/>
    
    <category term="api接口" scheme="https://github.com/SUPERQ314/tags/api%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>自定义侧边栏</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%A7%E8%BE%B9%E6%A0%8F/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%A7%E8%BE%B9%E6%A0%8F/</id>
    <published>2022-06-17T10:25:33.184Z</published>
    <updated>2022-04-15T13:09:17.903Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="侧边栏版块即widget"><a href="#侧边栏版块即widget" class="headerlink" title="侧边栏版块即widget"></a>侧边栏版块即widget</h3><p>可添加自己的widget，也可以对已有的widget进行排序（除 <strong>博客资料</strong> 和 <strong>公告</strong> 两个版块已固定，其余都可以进行自由排序）</p><h3 id="widget排序"><a href="#widget排序" class="headerlink" title="widget排序"></a>widget排序</h3><p>只需要配置 sort_order 就行。（使用了 <strong>Flex</strong> 布局的 <strong>order</strong> 属性，具体可查看 mozilla 文档。简单来讲，就是配置数字來实现排序，如果不配置，则默认为0。数字越小，排序越靠前。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line"> <span class="string">...</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line"></span><br><span class="line"><span class="attr">newest_comments:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure><h3 id="如何自定义widget"><a href="#如何自定义widget" class="headerlink" title="如何自定义widget"></a>如何自定义widget</h3><h4 id="创建widget-yml"><a href="#创建widget-yml" class="headerlink" title="创建widget.yml"></a>创建widget.yml</h4><p>在Hexo博客目录中的 <strong>source&#x2F;_data</strong>（如果没有 <strong>_data</strong> 文件夹，请自行创建），创建一个文件 <strong>widget.yml</strong></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">top:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">class_name:</span></span><br><span class="line">  <span class="attr">id_name:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">  <span class="attr">html:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">class_name:</span></span><br><span class="line">  <span class="attr">id_name:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">  <span class="attr">order:</span></span><br><span class="line">  <span class="attr">html:</span></span><br></pre></td></tr></table></figure><p>参数详解</p><p>top: 创建的 widget 会出现在非 sticky 区域（即所有页面都会显示)</p><p>bottom: 创建的 widget 会出现在 sticky 区域（除了文章页都会显示)</p><table><thead><tr><th align="center">参数</th><th>解释</th></tr></thead><tbody><tr><td align="center">class_name</td><td>所创建的 widget 父类 class 名（可选）</td></tr><tr><td align="center">id_name</td><td>所创建的 widget 父类 id 名（可选）</td></tr><tr><td align="center">name</td><td>所创建的 widget 标题</td></tr><tr><td align="center">icon</td><td>所创建的 widget 图标</td></tr><tr><td align="center">order</td><td>所创建的 widget 排序（可选）</td></tr><tr><td align="center">html</td><td>所创建的 widget 相关代码</td></tr></tbody></table><p>生成的 <strong>代码</strong> 为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-widget 所写的 class_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;所写的 id_name&quot;</span> <span class="attr">style</span>=<span class="string">&quot;order: 所写的 order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-headline&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;所写的 icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>所写的 name<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">        所写的 html</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你需要对添加的 widget 进行 UI 调整，请自行添加 css 到 inject 去。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="以-访客地图-为例子"><a href="#以-访客地图-为例子" class="headerlink" title="以 访客地图 为例子"></a>以 访客地图 为例子</h5><ol><li>获取访客地图的 html 代码</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">id</span>=<span class="string">&quot;clstr_globe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建 widget.yml</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">user-map</span></span><br><span class="line">      <span class="attr">id_name:</span> <span class="string">user-map</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">访客地图</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-heartbeat</span></span><br><span class="line">      <span class="attr">order:</span></span><br><span class="line">      <span class="attr">html:</span> <span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>运行 hexo</p><p><a href="https://www.google.com/">I&#39;m an inline-style link</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;侧边栏版块即widget&quot;&gt;&lt;a href=&quot;#侧边栏版块即widget&quot; class=&quot;headerlink&quot; title=&quot;侧边栏版块即widget&quot;&gt;&lt;/a&gt;侧边栏版块即widget&lt;/h3&gt;&lt;p&gt;可添加自己的widget，也可以对已有的widge</summary>
      
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>添加相册</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C/</id>
    <published>2022-06-17T10:25:33.166Z</published>
    <updated>2022-06-16T08:25:41.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h1><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理<br>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出<br>图片裁剪，因为相册显示的样式最好是正方形的的图片，这里使用脚本处理一下<br>图片压缩，相册显示的图片是压缩后的图片，提高加载的速度，打开后的图片是原图。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="github操作"><a href="#github操作" class="headerlink" title="github操作"></a>github操作</h3><p>建立一个用于存储相册的仓库，我这里建立了名为BlogPicturep的仓库<br>关于git的命令行操作和配置不再给出</p><h3 id="博客操作"><a href="#博客操作" class="headerlink" title="博客操作"></a>博客操作</h3><ul><li>在博客的source文件夹下建立一个photos文件夹</li></ul><p><img src="https://img-blog.csdnimg.cn/2020031510333829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDM5ODE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如果是通过hexo new 的方式创建的记得把index.md文件删掉，我试过不删掉就渲染不出来。</li><li>将样式文件放到photos文件夹下，样式文件我都放到了github上：<a href="https://github.com/hanlinbei/hanlinbei.github.io/tree/master/photos">https://github.com/hanlinbei/hanlinbei.github.io/tree/master/photos</a> 在github上一般很难下载单个文件夹，在这里我可以推荐一个gitzip的谷歌浏览器插件，可以右键很方便的把文件打包成一个压缩包下载，不必下载整个项目。整个项目很难下载得下来。</li><li>修改ins.js文件，主要是里面的render函数</li><li>其中的url对应到你的github放图片的地址</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var render = function render(res) &#123;</span><br><span class="line">    var ulTmpl = &quot;&quot;;</span><br><span class="line">    for (var j = 0, len2 = res.list.length; j &lt; len2; j++) &#123;</span><br><span class="line">        var data = res.list[j].arr;</span><br><span class="line">        var liTmpl = &quot;&quot;;</span><br><span class="line">        for (var i = 0, len = data.link.length; i &lt; len; i++) &#123;</span><br><span class="line">            var minSrc = &#x27;https://raw.githubusercontent.com/lawlite19/blog-back-up/master/min_photos/&#x27; + data.link[i];</span><br><span class="line">            var src = &#x27;https://raw.githubusercontent.com/lawlite19/blog-back-up/master/photos/&#x27; + data.link[i];</span><br><span class="line">            var type = data.type[i];</span><br><span class="line">            var target = src + (type === &#x27;video&#x27; ? &#x27;.mp4&#x27; : &#x27;.jpg&#x27;);</span><br><span class="line">            src += &#x27;&#x27;;</span><br><span class="line">            liTmpl += &#x27;&lt;ul class=&quot;img-box-ul&quot;&gt;&#x27; + liTmpl + &#x27;&lt;/ul&gt;\</span><br><span class="line">            &lt;/section&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200315103355457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDM5ODE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/202003151034044.png" alt="在这里插入图片描述"></p><p>地址一定是点击这个download后浏览器框上出现得地址</p><p><img src="https://img-blog.csdnimg.cn/202003151034044.png" alt="在这里插入图片描述"></p><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>python脚本文件都放在了这里：<a href="https://github.com/hanlinbei/BlogPicture">https://github.com/hanlinbei/BlogPicture</a></p><p>(1). 裁剪图片<br>去图片的中间部分，裁剪为正方形<br>对应的裁剪函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def cut_by_ratio(self):</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">按照图片长宽进行分割</span><br><span class="line">取中间的部分，裁剪成正方形</span><br><span class="line">   &quot;&quot;&quot;   </span><br><span class="line">    im = Image.open(self.infile)   </span><br><span class="line">    (x, y) = im.size   </span><br><span class="line">    if x &gt; y:   </span><br><span class="line">region = (int(x/2-y/2), 0, int(x/2+y/2), y)   </span><br><span class="line">        #裁切图片   </span><br><span class="line">        crop_img = im.crop(region)   </span><br><span class="line">        #保存裁切后的图片   </span><br><span class="line">        crop_img.save(self.outfile)</span><br><span class="line">    elif x &lt; y:   </span><br><span class="line">        region = (0, int(y/2-x/2), x, int(y/2+x/2))</span><br><span class="line">        #裁切图片   </span><br><span class="line">        crop_img = im.crop(region)   </span><br><span class="line">        #保存裁切后的图片   </span><br><span class="line">        crop_img.save(self.outfile)</span><br></pre></td></tr></table></figure><p>(2) 压缩图片<br>把图片进行压缩，方便相册的加载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def compress(choose, des_dir, src_dir, file_list):</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">压缩算法，img.thumbnail对图片进行压缩，</span><br><span class="line">参数   </span><br><span class="line">choose: str</span><br><span class="line">        选择压缩的比例，有4个选项，越大压缩后的图片越小</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">   if choose == &#x27;1&#x27;:</span><br><span class="line">       scale = SIZE_normal</span><br><span class="line">   if choose == &#x27;2&#x27;:</span><br><span class="line">       scale = SIZE_small</span><br><span class="line">   if choose == &#x27;3&#x27;:</span><br><span class="line">       scale = SIZE_more_small</span><br><span class="line">   if choose == &#x27;4&#x27;:</span><br><span class="line">       scale = SIZE_more_small_small</span><br><span class="line">   for infile in file_list:</span><br><span class="line">       img = Image.open(src_dir+infile)</span><br><span class="line">       # size_of_file = os.path.getsize(infile)</span><br><span class="line">       w, h = img.size</span><br><span class="line">       img.thumbnail((int(w/scale), int(h/scale)))</span><br><span class="line">       img.save(des_dir + infile)</span><br></pre></td></tr></table></figure><h2 id="github提交"><a href="#github提交" class="headerlink" title="github提交"></a>github提交</h2><p>处理完成之后需要将处理后的图片提交到github上</p><p>这里同样使用脚本的方式，需要将git命令行配置到环境变量中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def git_operation():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">git 命令行函数，将仓库提交</span><br><span class="line">需要安装git命令行工具，并且添加到环境变量中</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">    os.system(&#x27;git add --all&#x27;)</span><br><span class="line">    os.system(&#x27;git commit -m &quot;add photos&quot;&#x27;)</span><br><span class="line">    os.system(&#x27;git push origin master&#x27;)</span><br></pre></td></tr></table></figure><h2 id="json数据处理"><a href="#json数据处理" class="headerlink" title="json数据处理"></a>json数据处理</h2><p>下面就需要将图片信息处理成json数据格式了，这里为重点<br>最终需要的json格式的数据如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200315103424843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDM5ODE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里我采用的方式是读取图片的名字作为其中的text的内容，图片的命名如下图</p><p><img src="https://img-blog.csdnimg.cn/20200315103434868.png" alt="在这里插入图片描述"></p><p>最前面是日期，然后用_进行分隔<br>后面是图片的描述信息，注意不要包含_和.符号 这个命名一定要规范，不能有问题。<br>实现代码：<br>注意代码中…&#x2F;blog&#x2F;source&#x2F;photos&#x2F;data.json是对应到我的博客的路径，这里根据需要改成自己博客的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def handle_photo():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">根据图片的文件名处理成需要的json格式的数据</span><br><span class="line">最后将data.json文件存到博客的source/photos文件夹下</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    src_dir, des_dir = &quot;photos/&quot;, &quot;min_photos/&quot;</span><br><span class="line">    file_list = list_img_file(src_dir)</span><br><span class="line">    list_info = []</span><br><span class="line">    for i in range(len(file_list)):</span><br><span class="line">        filename = file_list[i]</span><br><span class="line">        date_str, info = filename.split(&quot;_&quot;)</span><br><span class="line">        info, _ = info.split(&quot;.&quot;)</span><br><span class="line">        date = datetime.strptime(date_str, &quot;%Y-%m-%d&quot;)</span><br><span class="line">        year_month = date_str[0:7]</span><br><span class="line">        if i == 0:  </span><br><span class="line">    # 处理第一个文件</span><br><span class="line">            new_dict = &#123;&quot;date&quot;: year_month, &quot;arr&quot;:&#123;&#x27;year&#x27;: date.year,</span><br><span class="line">                                                   &#x27;month&#x27;: date.month,</span><br><span class="line">                                                   &#x27;link&#x27;: [filename],</span><br><span class="line">                                                   &#x27;text&#x27;: [info],</span><br><span class="line">                                                   &#x27;type&#x27;: [&#x27;image&#x27;]</span><br><span class="line">                                                  &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">            list_info.append(new_dict)</span><br><span class="line">        elif year_month != list_info[-1][&#x27;date&#x27;]:  </span><br><span class="line">    # 不是最后的一个日期，就新建一个dict</span><br><span class="line">            new_dict = &#123;&quot;date&quot;: year_month, &quot;arr&quot;:&#123;&#x27;year&#x27;: date.year,</span><br><span class="line">                                                   &#x27;month&#x27;: date.month,</span><br><span class="line">                                                   &#x27;link&#x27;: [filename],</span><br><span class="line">                                                   &#x27;text&#x27;: [info],</span><br><span class="line">                                                   &#x27;type&#x27;: [&#x27;image&#x27;]</span><br><span class="line">                                                   &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">            list_info.append(new_dict)</span><br><span class="line">        else:  </span><br><span class="line">    # 同一个日期</span><br><span class="line">            list_info[-1][&#x27;arr&#x27;][&#x27;link&#x27;].append(filename)</span><br><span class="line">            list_info[-1][&#x27;arr&#x27;][&#x27;text&#x27;].append(info)</span><br><span class="line">            list_info[-1][&#x27;arr&#x27;][&#x27;type&#x27;].append(&#x27;image&#x27;)</span><br><span class="line">    list_info.reverse()  </span><br><span class="line">    # 翻转</span><br><span class="line">    final_dict = &#123;&quot;list&quot;: list_info&#125;</span><br><span class="line">    with open(&quot;../lawlite19.github.io/source/photos/data.json&quot;,&quot;w&quot;) as fp:</span><br><span class="line">       json.dump(final_dict, fp)</span><br></pre></td></tr></table></figure><p>每次图片有改动都需要执行此脚本文件<br>效果展示</p><p><img src="https://img-blog.csdnimg.cn/2020031510345189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDM5ODE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="可能会遇到得问题"><a href="#可能会遇到得问题" class="headerlink" title="可能会遇到得问题"></a>可能会遇到得问题</h2><h3 id="缩略图不显示"><a href="#缩略图不显示" class="headerlink" title="缩略图不显示"></a>缩略图不显示</h3><p>首先，去下载“empty.png” 点这里<br>直接右键另存，保存为“empty.png”。名字也要一样，别问为什么，实现了，自己再去看源码。<br>在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。我的结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200315103504493.png" alt="在这里插入图片描述"></p><p>这样做好像就完事了，可以成功看到缩略图显示出来。其实操作本不复杂严格按照教程来，细心点</p><h3 id="网页没有渲染出来"><a href="#网页没有渲染出来" class="headerlink" title="网页没有渲染出来"></a>网页没有渲染出来</h3><p>如果是github操作一定要及时查看邮件，如果渲染不出来有错误你会收到github发送过来的邮件</p><p><img src="https://img-blog.csdnimg.cn/20200315103512825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDM5ODE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果没有错误记得请一下浏览器的缓存，可能会是浏览器缓存造成的 刷新还是原来的页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;添加相册&quot;&gt;&lt;a href=&quot;#添加相册&quot; class=&quot;headerlink&quot; title=&quot;添加相册&quot;&gt;&lt;/a&gt;添加相册&lt;/h1&gt;&lt;h2 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h</summary>
      
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="icon" scheme="https://github.com/SUPERQ314/tags/icon/"/>
    
    <category term="iconfont" scheme="https://github.com/SUPERQ314/tags/iconfont/"/>
    
  </entry>
  
  <entry>
    <title>添加图标</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87/</id>
    <published>2022-06-17T10:25:33.149Z</published>
    <updated>2022-04-16T07:42:07.941Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><p>国内最出名的莫过于iconfont,功能很强大且图标内容很丰富的矢量图标库。很多Font Awesome不支持的图标都可以在这里找到。同时，iconfont支持选择需要的图标生成css链接，减少不必要的CSS加载。</p><h3 id="註册账号"><a href="#註册账号" class="headerlink" title="註册账号"></a>註册账号</h3><p>打开iconfont的网站，点击导航栏的人像图标，会跳出註册界面，按要求註册账号。</p><h3 id="添加图标入库"><a href="#添加图标入库" class="headerlink" title="添加图标入库"></a>添加图标入库</h3><p>选择自己需要的图标，把鼠标移到图标上，会显示三个按钮（依次是添加入库、收藏和下载），而我们需要的是把图标添加入库</p><p>添加入库后，你可以看到网站右上角购物车图标显示了1字，代表图标已经添加入库，点击购物车图标，会弹出侧边栏显示详情。</p><p>已选择的图标会显示在上面，你可以重复上面的操作，把需要的图标添加入库，然后点击添加到项目。</p><p>接下来会要求选择项目名称，没有的自己创建一个。</p><h3 id="生成CSS链接"><a href="#生成CSS链接" class="headerlink" title="生成CSS链接"></a>生成CSS链接</h3><p>在添加到项目之后，会跳到项目的详情界面。点击Font class，然后再点击暂无代码，点击生成文字。网站会自动生成CSS链接，我们只需要复製链接就行。</p><h3 id="添加链接进主题配置文件"><a href="#添加链接进主题配置文件" class="headerlink" title="添加链接进主题配置文件"></a>添加链接进主题配置文件</h3><p>打开主题配置文件，找到inject配置，按要求把链接填入</p><p>在我们需要使用的地方填入icon，例如Menu，图片使用格式为iconfont icon名字</p><p>运行Butterfly之后，你就可以看到menu的图标生效了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;iconfont&quot;&gt;&lt;a href=&quot;#iconfont&quot; class=&quot;headerlink&quot; title=&quot;iconfont&quot;&gt;&lt;/a&gt;iconfont&lt;/h2&gt;&lt;p&gt;国内最出名的莫过于iconfont,功能很强大且图标内容很丰富的矢量图标库。很多F</summary>
      
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="icon" scheme="https://github.com/SUPERQ314/tags/icon/"/>
    
    <category term="iconfont" scheme="https://github.com/SUPERQ314/tags/iconfont/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-域名设置+收录</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-6/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-6/</id>
    <published>2022-06-17T10:25:33.135Z</published>
    <updated>2022-04-14T09:46:56.176Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>PicGo：搭建图床</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-5/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-5/</id>
    <published>2022-06-17T10:25:33.132Z</published>
    <updated>2022-04-14T09:46:47.080Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-使用阿里iconfont图标</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-4/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-4/</id>
    <published>2022-06-17T10:25:33.129Z</published>
    <updated>2022-04-14T09:46:39.265Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之更换背景及透明度</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-3/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-3/</id>
    <published>2022-06-17T10:25:33.127Z</published>
    <updated>2022-04-14T09:46:34.708Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly美化</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-2/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-2/</id>
    <published>2022-06-17T10:25:33.124Z</published>
    <updated>2022-04-14T09:46:19.760Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>hexo、部署、上线</title>
    <link href="https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-1/"/>
    <id>https://github.com/SUPERQ314/2022/06/17/Hexo+Butterfly/index-1/</id>
    <published>2022-06-17T10:25:33.122Z</published>
    <updated>2022-04-16T07:42:17.747Z</updated>
    
    
    
    
    <category term="Butterfly" scheme="https://github.com/SUPERQ314/categories/Butterfly/"/>
    
    
    <category term="butterfly" scheme="https://github.com/SUPERQ314/tags/butterfly/"/>
    
  </entry>
  
</feed>
